00a) Zaawansowane pojęcia JS  (interview)
00b) Algorytmy
000) Skróty
01a) Mobica - pytania z interwiuchy
01b) EDC - pytania z interwiuchy

02) Types: primitives & objects
03) Truthy and falsey
04) Lexical scoping
05) Coercion and   == vs ===
06) "use strict"
07) try catch throw
08) Tips & gotchas
09) Troubleshooting
10) Wzorce projektowe

11) Scope
12) Scope - cheating by eval
13) Scope - hoisting

17) Ternary
18) Associativity
19) Pierwszeństwo operatorów  (precedence)

21) JSON - tips
22) JSON - cudzysłowy
23) JSON - parse / stringify
24) JSON - stringify

25) Date - new Date()
26) Date - new Date() - get methods
27) Date - new Date() - set methods
28) Date - new Date().setUTCHours()
29) Date - Date.parse()
30) Date - Dates compare
31) Date - formatowanie
32) Date - formatowanie .toLocalTimeString()
33) Date - formatowanie polskich dat słownie

35) Array - podsumowanie
36) Array - functional  - podsumowanie
37) Array - map vs forEach
38) Array - map over JSON
39) Array - map over JSON - search
40) Array - for in
41) Array - filter
42) Array - filter > map (array)
43) Array - filter > map (json)
44) Array - concat
45) Array - reduce 1
46) Array - reduce 2
47) Array - every

48) Array - some
49) Array - join
50) Array - split
51) Array - slice (non mutating)
52) Array - splice (mutating)
53) Array - substr vs substring
54) Array - indexOf, lastIndexOf
55) Array - push, pop, unshift, shift
56) Array - reverse, sort  ( też 331 )
57) Array - entries
58) Array - concat
59) Array - porównywanie
60) Array - flat
61) Array - from

64) String - indexOf, lastIndexOf
65) String - search
66) String - slice
67) String - substr i substring
68) String - replace
69) String - toUpperCase, toLowerCase
70) String - trim
71) String - charAt
72) String - charCodeAt
73) String - String.fromCharCode
74) String - split

76) Lodash top 16

77) ES6 - wybrane części - ściąga
78) ES6 - let
79) ES6 - const
80) ES6 - class
81) ES6 - class extends
82) ES6 - shorthand object creation
83) ES6 - enhanced object literals
84) ES6 - lexical this
85) ES6 - string templates
86) ES6 - destructuring
87) ES6 - default parameters
88) ES6 - default parameters: options object
89) ES6 - named parameters
90) ES6 - rest vs spread
91) ES6 - rest parameters
92) ES6 - spread parameters
93) ES6 - set
94) ES6 - weakSet
95) ES6 - map
96) ES6 - weakMap

97) ES6 - arrow functions
98) ES6 - arrow functions: fixy
99) ES6 - arrow functions (partial function, curry)

100) ES6 - modules
101) ES6 - modules:  default export vs named export
102) ES6 - porównanie modułowości w Nodzie
104) ES6 - arrays (of, find, findIndex, fill, copyWithin )
105) ES6 - array workarounds  (union, intersection, difference)
106) ES6 - computed object  ( ręczne tworzenie obiektu )
107) ES6 - object assign  ( patrz 122 OOP - object.assign)
108) ES6 - promises: teoria
109) ES6 - promises: then, catch  ( promise example )
110) ES6 - promises: fetch example
111) ES6 - promises: interview example
112) ES6 - promises: chaining
113) ES6 - promises: all
114) ES6 - promises: race
115) ES6 - promises: reject  ( kasowanie trwającego promisa )
116) ES6 - for of
117) ES5 - for in
118) ES7 - **  (potęgowanie)
119) ES7 - includes (string i array)


120) ES8 - string methods (padStart, startsWith, endsWith)
121) ES8 - Object.values
122) ES8 - Object.entries
123) ES8 - Object.getOwnPropertyDescriptors
124) ES8 - Trailing commas w parametrach i wywołaniach funkcji
125) ES6 - promises
126) ES8 - async / await
127) ES8 - async / await - try/catch
128) ES8 - async / await - for

129) ES Next - object spread
130) Functions - intro
131) Functions - declaration i expression
132) Functions - Hoisting: variables
133) Functions - Hoisting: functions
134) Functions - IIFE: immediately invoked function execution
135) Functions - IIFE: Revealing module pattern 1
136) Functions - IIFE: Revealing module pattern 2
137) Functions - passing arguments (zwykłe, call i bind)
138) Functions - overloading

139) Functions - Event Loop
140) Functions - Closures
141) Functions - Closures - Elliott
142) Functions - methods chaining
143) Functions - higher order functions
144) Functions - recursion (fibonacci)

147) OLOO - Object.keys, .values i .entries
148) OLOO - forEach
149) OLOO - for in
150) OLOO - Object.create
151) OLOO - zarys
152) OLOO - pełne
153) OLOO - Object.assign
154) OLOO - computed object (ES6)

155) OOP - intro 1
156) OOP - intro 2

157) OOP - konstruktory
158) OOP - in
159) OOP - for in
160) OOP - usuwanie właściwości
161) OOP - prototype 1
162) OOP - prototype 2
163) OOP - isPrototypeOf i __prototype: sprawdzanie co jest prototypem obiektu
164) OOP - prototype: rozszerzanie obiektu wbudowanego (Array)
165) OOP - klonowanie obiektu (Object.assign - płytkie)
166) OOP - mixiny - dziedziczenie wielokrotne

167) OOP - ograniczanie modyfikacji obiektów
168) OOP - preventExtensions() i isExtensible()
169) OOP - seal
170) OOP - freeze
171) OOP - dynamic prototypes
172a)OOP - this - 1
172b)OOP - this - 2
173) OOP - this - 3
174) OOP - via JSON creating
175) OOP - typeof vs instanceof
176) OOP - call vs apply
177) OOP - bind
178) OOP - module pattern
179) OOP - factory function
180) OOP - factory i Object.create()
181) OOP - enumeracja przez elementy obiektu
182) OOP - Object.defineProperty
183) OOP - programowe tworzenie obiektu
184) OOP - metody klonowanie obiektu  ( object cloning )
185) OOP - ćwiczenia

190) Best practices - clean code JS
191) Best practices - V8 optimization killers

200) Design Patterns - Module:  Classical
201) Design Patterns - Module:  Revealing Module Pattern ( IIFE )
202) Design Patterns - Module:  Object Literal
203) Design Patterns - Prototypal (OLOO)

204) Design Patterns - Module:  Extension
205) Design Patterns - Module:  Extension - 2 pliki
206) Design Patterns - Module:  naming convention
207) Design Patterns - Chaining

220) FP - Functional Programming: założenia
221) FP - funkcje wyższego rzędu  ( HOF )
222) FP - przekazanie funkcji do funkcji  ( HOF )
223) FP - map-filter-reduce
224) FP - zestaw funkcji pure i immutable
225) FP - ES6: klonowanie obiektu
226) FP - ES6: usuwanie elementu obiektu
227) FP - ES6: tablice  ( CRUD )
230) FP - curry
231) FP - RxJS
232) FP - Ramda
233) FP - Ramda: pipe - user functions
234) FP - deepFreeze (slice)

240) Regex - links
241) Regex - cheatsheet
242) Regex -  Sublime
243) Regex - ^ i $
244) Regex - greedy vs lazy
245) Regex - in JS 'match' command
246) Regex - grouping
247) Regex - OR
248) Regex - word boundaries
249) Regex - backreferences
240) Regex - positive lookehead
241) Regex - positive lookehead: double testing
242) Regex - negative lookehead

245) JS Regex - summary
246) JS RegEx - {n}
247) JS RegEx - (..)
248) JS RegEx - | (lub)
249) JS RegEx - \w \W \d \D \s
250) JS Regex - escapowanie znaków specjalnych
251) JS Regex - grupy: () $1,2.. - łatwe
252) JS Regex - grupy: () $1,2.. - trudne
253) JS Regex - greedy / lazy
254) JS Regex - capture groups \cyfra
255) JS Regex - lookaheads
256) JS Regex - lookbehind: positive
257) JS Regex - lookbehind: negative
258) JS Regex - named groups

271) JS RegEx
272) JS RegEx - match
273) JS RegEx - exec
274) JS RegEx - test
275) JS RegEx - string.replace
276) JS RegEx - string.replace kodu pocztowego
277) JS RegEx - walidacja daty

280) ESlint - instalacja
281) ESlint - konfigurowanie
282) ESlint - konfiguracja: plik .eslintrc.json
283) ESlint - reguły
284) ESlint - rozszerzanie i nadpisywanie reguł
285) ESlint - online validator i narzedzia
286) ESlint - autofixing
287) ESlint - ESLint-Formatter  ( Sublime plugin )
288) ESlint - troubleshooting
289) ESlint - prettier-eslint
290) ESLint i Prettier w Vue

300) Jest - config
301) Jest - numbers: toBe
302) Jest - refaktorowanie implementacji
303) Jest - stringi: toMatch()
304) Jest - array: toContain, arrayContaining, toBeDefined, toBeNull
305) Jest - objects: toEqual, toMatchObject, toHaveProperty
306) Jest - toThrow, toBeGreaterThan
307) Jest - mockowanie
308) Jest - unit test tokena

309) Jest - integracyjny: get i post
310) Jest - integracyjny: get
311) Jest - istanbul (coverage)
312) Jest - axios
313) Jest - mocking
314) Jest - tablica obiektów
315) Jest - crash course


326) CDN failure fallback dla plików .css
327) SEO - Fetch as Google (bot)
330) Ikonki unicode w HTML
331) Sortowanie tablicy obiektów
332) Tablica obiektów - wyszukiwanie po Object.keys
333) Zagnieżdżony obiekt - trawersowanie  ( traversing nested objects )
334) Włączanie / wyłaczanie wyświetlania console.logów
335) eval

336) console.log - tips & gotchas
337) console.log - color
338) console.time
339) console.trace
340) console.clear i console.assert

341) console.table
342) JS style - feross: standardJS
343) High performance
344) Skrótowce testów logicznych: && i ||
345) DOM - szukanie, sprawdzanie, tworzenie, dodawanie i usuwanie noda
346) Chrome debugger - zakładki VMxx
347) Formatowanie liczb  ( tysiące i dziesiętne )
348) sleep - samoróbka
349) Haversine - dystans między punktami na Ziemi
350) Strzelanie bąblami GPS do serwera node.js
351) parseInt, parseFloat i toString
352) setTimeout
353) setInterval

380) Testing
400) Continuous Integation

420) Licenses: AGPL
421) RethinkDB postmortem blog post
422) Refactoring 30k codebase with types
423) Keyboard events
424) Filtrowanie obiektem tablicy obiektów + ustawianie kolejności

426) commonjs vs requirejs vs amd
427) mocha
428) chai
430) encoding URI
440) webpack 4
441) moment
442) snyk
443) parcel
444) sanitizing
445) axios w browserze
446) email validation
447) lazysizes (lazy loading images)
448) picsum.photos
449) masonry / macy
450) cookies


500) Algo - primes
501) Algo - highAndLow
502) Algo - jedyna parzysta
503) Algo - Disemvowel Trolls
504) Algo - Exes and Ohs
505) Algo - find the divisors
506) Algo - Printer Errors
507) Algo - scramblies
508) Algo - Pete, the baker
509) Algo - count sheeps
510) Algo - fibo
511) Algo - primes
512) Algo - silnia (factorial)
513) Algo - różnica tablic
514) Algo - iloczyn tablic

520) Algo - Codility: Lesson 1 - BinaryGap
521) Algo - Codility: Lesson 2 - OddOccurrencesInArray
522) Algo - Codility: Lesson 3 - CyclicRotation

600) DOM - tips
601) DOM - interwiucha
602) DOM - access methods
603) DOM - iteracja
604) DOM - traversing: parentElement / parentNode
605) DOM - traversing: children
606) DOM - traversing: children
607) DOM - innerText, innerHTML, textContent
608) DOM - nextElementSibling, previousElementSibling
609) DOM - createElement (id, class, setAttribute), createTextNode, appendChild, insert.., replace
610) DOM - events
611) DOM - event object
612) DOM - events: button
613) DOM - events: mouse
614) DOM - events: <input>
615) DOM - events: form
616) DOM - event bubbling vs event capturing

620) DOM - form hello weird
621) DOM - edipresse: ilość celi w tabeli

700) PWA - tips
701) PWA - hello weird
702) PWA - caching strategies
703) PWA - workbox: generateSW
704) PWA - workbox: injectManifest - lokalnie
705) PWA - workbox: injectManifest - netlifajka
710) PWA - Vue 1
711) PWA - Vue 2

720) TWA - tips
721) TWA - intro
722) TWA - Android Studio

__________________________________________________________________________________________
00a) Zaawansowane pojęcia JS (do interview)

                                    Punkt
    1. scope
    2. hoisting
    3. IIFE
    4. this                        88, 172, 173
    5. closure                    140, 141
    6. call, apply, bind          137, 176
    7. prototypal inheritance     155, 6, 7,  171
    8. class
    9. DOM: delegation, bubbling vs capturing
   10. event loop
   11. arrow function - lexical scope


  10.  ES6 - fat arrow        94
  11.  ES6 - destructuring    89, 90
  12.  ES6 - spread           94
  13.  ES6 - rest             95
  14.  ES6 - promise          107 - 114
  15.  FP                            220

  16.  git - podstawy
  17.  git - fetch vs merge vs rebase
  18.  commonjs vs requirejs
  19.  testy (mocha, chai)
__________________________________________________________________________________________
000) Skróty

      YAGNI - you aint gonna need it: nie rób nic potrzebnego dopiero i to tylko ewentualnie w przyszłości

      SOLID - Single Responsibility +
              Open for extension, closed for modification
              Liskov - subklasa nie może nadpisywać metody klasy tak, by łamać funkcjonalność z punktu widzenia klienta

__________________________________________________________________________________________
01a) Mobica - pytania z interwiuchy

    JS ok 8-miu,  HTML ok 3-ech

    JS:
      a) co tzn że js jest językiem dynamicznym

      b) IIFE - self-invoking anonymous function

      c) function declaration i expression  (hoisting)

      d) klasy i dziedziczenie prototypowe

      e) document.ready - stan, gdy budowany z HTML DOM is ready
         onLoad - stan, gdy załadowane obrazki, biblioteki

      f) co robi use strict

      g) palindrom - jak sprawdzić czy mamy z nim do czynienia
          str.split('').reverse().join(')

    HTML:

      a) co się dzieje od chwili wciśnięcia Entera po wpisaniu adresu w okno przeglądarki
          1) komp śle request po ip do dns'a
          2) dns zwraca do kąpa ip
          3) kąp wysyła request używając ip i ścieżki
          4) serwer generuje dokument (i/lub ściąga dane z db)
          5) serwer odsyła do przegladarki dane lub stronę HTML
          6) przeglądarka - budowa DOMu
          7) rendering obrazu na ekranie

      b) struktura dokumentu html

      c) co załatwia <!document html>
          Mówi przeglądarce z którą wersja html ma pracować.
          Sam <!document html> nie jest jeszcze znacznikiem HTML 5

__________________________________________________________________________________________
01b)  EDC - pytania z interwiuchy

        Żadnego pytanie nt gita, algo, 1 CSS (flexbox)

        1) hoisting
        2) closure
        3) scope
        4) by value i by reference
        5) IIFE (4 console logi, w tym 2 z setTimeoutami)
        6) event loop
        7) call, apply, bind
        8) functional programming (pure functions)
        9) obiektowość w JS
       10) arr.filter
       11) flexbox
       12) konfiguracja webpacka
       13) płytkie i głębokie klonowanie
       14) arrow function - lexical scope
       15) const i let
       16) vuex
       17) event delegation
       18) tdd
       19) scrum

       5-6 krótkich code snippetów - co powie console.log

         object literal

        funkcja(ww obiekt) {
          var

        }


__________________________________________________________________________________________
02) Types: primitives & objects

      Primitives
        1) number     ( typeof NaN  =  number )
        2) boolean
        3) string
        4) null       ( mimo, że typeof zwraca błędnie 'object' )
        5) undefined

      Obiekty
        6) Object  (w tym Array)
        7) Function
__________________________________________________________________________________________
03) Truthy and falsy

        6 Falsy values:
            false
            0, +0, -0
            empty string ( “” or '' )
            null
            undefined
            NaN

       2 Truthy values: true i negacja powyższych

       Falsy określane jest na podstawie wyniku funkcji Boolean(wartość):
            Undefined  false
            Null       false
            Boolean    false
            Number     false: +0, -0 i NaN  (reszta true)
            String     false: empty         (reszta true)
            Object     true


     Konwersja truthy / falsey do buljona:
         x = !!"" // false
         x = !!0 // false
         x = !!null // false
         x = !!undefined // false
         x = !!NaN // false

         x = !!"hello" // true
         x = !!1 // true
         x = !!{} // true
         x = !![] // true

     console.log( x )
        lub:
     console.log( Boolean ( x ) )

     OR i AND ( || i && )
        javascript.info/logical-operators

             let x = null
             let y = ''
             let z = 0

             console.log( x && y && z ) // szuka 1-szej falsy. jeśli nie znajdzie, zwraca pierwszą wartość
             console.log( x || y || z )  // szuka 1-szej truthy. jeśli nie znajdzie, zwraca ostatnią wartość

     Nawiasy ( ) wykonywane są przed AND który wykonywany jest przed OR

        console.log(  5 || 1  && 0 )     // 5, bo 1 && 0 = 0, a 5 || 0 = 5
        console.log( ( 5 || 1 ) && 0 )  // 0

        console.log( 2 || 3 )  // 2
        console.log( 2 && 3 ) // 3 - na głowę: musi być inaczej niż przy AND

        age = 33
        x = age > 13 && age < 90  // true

        ( 5 > 2 ) && console.log( 'dupa' )  // 5

__________________________________________________________________________________________
04) Lexical scoping

      Zmienne zewnętrzne (const a = 5) są widziane w funkcji (przeciekają do niej),
      ale zmienne wewnętrzne (const b = 7) - nie są widoczne poza nią (nie wyciekają z niej)

      const a = 5

      function sum() {
        const b = 7
        return a + 1
      }

      console.log(sum()) // 6
      console.log(b)       // not defined
__________________________________________________________________________________________
05) Coercion and == vs ===

    Konwersja jawna = type casting, nie jawna = koersja
    Koersja odbywa się przy użyciu operatora:  ==
    Czyli  - użycie  == powoduje odpalenie koersji

    Kiedy porównywane operandy są innych typów, jeden z nich będzie skonwertowany na ekwiwalent, wyrażony w typie drugiego

    Rules:
        a) If both operands are same type use ===
        b) string and number, convert string to number
        c) boolean and non-boolean, convert boolean to number
        d) string or number to an object, try to convert the object to a primitive
        e) undefined == null


        However, if you use the non-converting comparison operator ===, no such conversion occurs.

        When the operands are of different types, this operator returns false, and only compares the values when they're of the same type.

    Podwójny równaś sprawdza tylko wartość,
    Potrójny - wartość i typ

    Number('3')                   // 3
    Number(false)              //  0
    Number(undefined)   //   NaN
    Number(null)            //     0

    Boolean(0)              // false
    Boolean(1)             //  true
    Boolean('kupa')    //   true
    Boolean('false')    //   true

    Equality comparisons and sameness

        https://developer.mozilla.org/pl/docs/Web/JS/Equality_comparisons_and_sameness

        ES6 Object.is przydaje się do +0 vs -0  i NaN - przy property descriptors (Object.defineProperty)

        console.log(Object.is(NaN, NaN))   // true
        console.log(NaN === NaN)           //  false

    Do sprawdzenia czy parametr został zdefiniowany, tzn czy nie jest aby undefined, zamiast częstego:
        if ( !x )
     lepsze jest if ( typeof x !== 'undefined' ), lub id  ( x !== undefined )  bo przy x = 0,  !x będzie spełnione  (  = true )

     Przy typeof używa się 'undefined' w skobkach,  albowiem,  wynikiem jest string:
        console.log( typeof (  typeof x ) )  // string
__________________________________________________________________________________________
06) "use strict"

      .. lub "use-strict"

      Strict mode wszedł w ES5. Chodzi wszędzie, ale w IE tylko 9+
      W ES6 jest wbudowany, nie wymaga wpisania "use strict"

      In normal JS, mistyping a variable name creates a new global variable.
      In strict mode, this will throw an error, making it impossible to accidentally create a global.

      Assigning values to non-writable properties - throws an error

      Sometimes makes code faster allowing for code optimizations

      var kupa = 3
      zupa = 4    // bez strict -  ok, w strict wywali błąd i nie zadeklaruje zmiennej globalnej
_____________________________________________________________
07) try catch throw

      UWAGA !
        throw ('Błąd !')           - tylko rzuca błąd, ale gubi stacktrace'a
        throw new Error('Błąd !')  - nie gubi

      Przykład ogólny rzucania i przechwytywania błędów

      try {
        throw 4/0
      }
      catch (error) {
        console.log('byk: ' + error)    // byk: Infinity
      }
_____________________________________________________________
08) Tips & gotchas

       a) 0.1 + 0.2 === 0.3  // false, bo 0.1 + 0.2 = 0.3000000000004

       b) type inferring
            '4' - 1    // 3
            '4' + 1     // 41
             4 + 1 + '2' //  52

            Rozwiązaniem jest poprzedzenie "n"plusem +"4"+1 = 5, albo parseInt("4") + 1 = 5

       c) nie wstawiaj nowej linii między return i wyrażenie:
            return 3 + 4  // 7
            return
                3+4       // undefined

          Mimo, że średniki na końcu linii są opcjonalne, kompilatór na końcu 'return'
          wstawi średnik co spowoduje zwrócenie undefined

       d) 4 / 0       // Infinity
         -4 / 0     // -Infinity

       e) console.log (a)     // undefined
            var a             // undefined
            typeof null       // object
            "a" + 5           // a5
            "a" - 5           // NaN
            "a" * 5           // NaN
            "a" / 5           // NaN

       f)  JS Essentials Travis Tidwell @ 38:40

            for(var i = 0; i < 5; i++) {        //  var - źle  ( 5  5  5  5  5 )
                setTimeout(function(){
                  console.log(i)
                }, i * 1000)
            }
    -------------------------------------------------
            for ( let i = 0; i < 5; i++) {      // ket - dobrze  ( 0  1  2  3  4  )
                setTimeout ( function ( ) {
                        console.log ( i )
                    }, i * 1000 )
            }
    -------------------------------------------------

       g)  var a = b = c

            Ewaluacja idzie od prawej,  tzn najpierw liczone jest b = c,  a potem a = b

             var a = 1
             var b = 2
             var c  = 3

            var a = b = c

            console.log( 'a = '  + a)  // 3
            console.log( 'b = '  + b)  // 3
            console.log( 'c = '  + c)  // 3

       h) semicolon-less js   ( bez średników )

            blog.izs.me/post/2353458699/an-open-letter-to-JS-leaders-regarding

            Aby nie używać średnika, nie otwieraj nowej linii, od:

              a) _otwierającego_ nawiasu okrągłego lub kwadratowego: ( [
              b) operatora arytmetycznego:  +   -   *   /
              c) przecinka
              d) kropki

______________________________________________________________________________________________
09) Troubleshooting

      a) Nibysynchroniczne ładowanie bibliotek

          Biblioteki zewn ładuj w headzie,  a własne skrypty na końcu body
          W przeciwnym wypadku,  kompilator odpali metodę z własnej, nim zewn biblioteka zdąży się ściągnąć

          To wywalało w script.js błąd:
            <head>
                <script src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/4.1.0/rx.all.min.js"></script>
                <script src="script.js"></script>
            </head>
            <body>
            </body>

          A to naprawiło go:
            <head>
                <script src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/4.1.0/rx.all.min.js"></script>
            </head>
            <body>
                <script src="script.js"></script>
            </body>

______________________________________________________________________________________________
10) Wzorce projektowe

        Addy Osmani - JS Design Patterns

        MV*
        Constructor
        Factory
        Singleton
        Module
        Prototype
        Mixin

        Revealing Module
        Observer
        Mediator
        Command
        Facade
        Decorator
        Flyweight


_____________________________________________________________
11) Scope

      Youtube LearnAcademy - JS is WEIRD and AWESOME: 4 - Scope

          let a = 1

          function x ( ) {
            a = 2   // kompilator nie znajdzie tu let ani const, ale znajdzie wyżej
                    // wiec uzna że tutejsze a, to to samo co powyższe
          }

          x ( )
          console.log( a )  // 2

      Ale jeśli wewnątrz funkcji przed 'a = 2' dodamy 'let',
      kompilator uzna to za nowe 'a', nie związane z tym wyżej

        let a = 1

        function x ( ) {
          let a = 2   // kompilatór nie zajrzy nawet wyżej, bo let znajdzie tu
        }

        x ( )
        console.log( a )  // 1

_____________________________________________________________
12) Scope - cheating by eval

    Considered bad practice

    var a =  2

    function foo(a) {
      eval(a)          // cheating!
      console.log(a)
    }

    foo(a)  // 2

    foo("var a = 3")   //  3

    "var a = 3"  actually creates variable  b  inside of  foo(..)  that shadows the  b,
    that was declared in the outer (global) scope.
_____________________________________________________________
13) Scope - hoisting

    https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&%20closures/ch4.md

        a = 2
        var a
        console.log ( a )

    Kompilator rozbija var a = 2, na 2 części:
        deklarację:   var a
        i przypisanie  ( assignment ):  a = 2
    I tylko deklarację przesuwa na samą górę funkcji

    Dlatego w przypadku var (ES5):
      console.log(a)
      var a - nie wywali kodu w wyniku błędu, a tylko wypisze 'undefined'

    ES6 (let i const) naprawia ten błąd i analogiczny kod:
      console.log(a)
      const a  // albo let a
    spowoduje zakończenie wykonywania programu w wyniku błędu

    To samo w przypadku funckcji:

        functionDeclaration('fD')   //  fD
        functionExpression('fE')    //  Bład

        function functionDeclaration(a) {
            console.log(a)
        }

        var functionExpression = function (a) {
            console.log(a)
        }

--------------------------------------

console.log( a )
var a = 2

Wypisze: 'undefined' - bo kompilatór przerobi to na:

var a
console.log( a )
a = 2

Bo dla niego var a = 2, to 2 operacje: deklaracja zmiennej (var a ) i przypisanie (a = 2)
A tylko deklaracja jest przesuwana na górę (przypisanie zostaje tam gdzie było)
---------------------------------------------------------------------------------------------------
Dlatego ten kod wykona się poprawnie:

foo ( )

function foo ( ) {
    console.log( a )    // undefined
    var a = 2
}

.. bo deklaracja funkcji (function foo() ) zostanie umieszczona na samej górze
---------------------------------------------------------------------------------------------------

Hoisting działa w obrębie scopu, tzn deklaracje w obrębie funkcji,
przesunięte będę na jej początek, a nie początek całego kodu

_Deklaracje_ funkcji są hojstowane, ale już wyrażenia funkcyjne - nie

foo ( )        // not ReferenceError, but TypeError!

var foo = function bar() { ... }    // gdyby nie było 'var foo = ' - wykonałoby się dobrze

---------------------------------------------------------------------------------------------------
foo()   // 1

var foo

function foo() {
    console.log( 1 )
}

foo = function() {
    console.log( 2 )
}

1 is printed instead of 2! This snippet is interpreted by the Engine as:

function foo ( ) {
    console.log ( 1 )
}

foo() // 1

foo = function() {
    console.log( 2 )
}

Notice that var foo was the duplicate (and thus ignored) declaration,
even though it came before the function foo()... declaration,
because function declarations are hoisted before normal variables.

While multiple/duplicate var declarations are effectively ignored,
subsequent function declarations do override previous ones.

foo() // 3

function foo() {
    console.log( 1 )
}

var foo = function() {
    console.log( 2 )
}

function foo() {
    console.log( 3 )
}

______________________________________________________________________________________________
17) Ternary

  Dużo przejrzystsza wersja if'a

    var age = 12
    console.log(  ( age > 17 ) ? 'Adult': 'Kid' )

 Wersja z wykonywaniem więcej niż 1 operacji  ( obie grupy ując w nawiasy okrągłe,  komendy oddzielając przecinkami  ):
      var a  = 5
      a === 5 ? ( console.log( 'tak' ), console.log( 'TAK' ) ) : (  console.log( 'nie' ), console.log( 'NIE' ) )
-  -  -  -  -  -  -  -  -  -  -  -  -

        e.target.value  === 'All' ? e.target.value  =  'Completed' :
            e.target.vale  === 'Completed' ? e.target.value  =  'Incomplete' :0,
            +-*/                e.target.value  === 'Incomplete' ? e.target.value  =  'All' :  ''
-  -  -  -  -  -  -  -  -  -  -  -  -
Jeśli status  =  'started' to ustaw go na 'completed' i wizawi

toggle (  ) {
    this.status =
        this.status == 'started'
        ? 'completed'
        :  'started'
}

______________________________________________________________________________________________
18) Associativity

    https://developer.mozilla.org/en-US/docs/Web/JS/Reference/Operators/Assignment_Operators

    var a = 2
    var b = 3
    var c = 4

    a = b = c   // wszustkie = 4, bo associativity is right (to left)
    -----------------------------
    var a = b = c  //   b = c   var a = b - b jest globalsem !! Unikaj takich łańcuchów
    -----------------------------
    console.log( 3 < 2 < 1 )   // true   associativity - left (to right)

    Dzieje się tak bo najpierw liczona jest wartość 3 < 2 = false,
    a potem wynik, czyli false < 1 = true

_________________________________________________________________________________________
19) Pierwszeństwo operatorów  ( precedence )

        developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Operatory/Pierwsze%C5%84stwo_operator%C3%B3w

        Skrót ww tabelki:
             19  ()
             15  !
             14  *  /   %
             13  +   -
             11  <  >
             10  ==    ===     !==    !===
              6  &&
              5  ||
              3  =,  +=, -=


        if ( a || a === 0 )  // === ma wyższy precedens od || więc będzie najprzód policzone, a dopirusz po nim ||
_________________________________________________________________________________________
21) JSON - tips

    a) online tools
        jsonlint.com
        jsoneditoronline.org
        jsonquerytool.com/#/JS
        mocky.io  // zwraca z serwera http obiekt / tablice, która mu wkleisz

    b) JSON pretty

      console.log( JSON.stringify ( part2, null, 2 ) )
      Ostatni parametr(2) ,  to ilość spacji
_____________________________________________________________
22) JSON - cudzysłowy

      youtube.com/watch?v=gsfbh17Ax9I

      ASI - Automatic Semicolon Insertion

      Wystarczy nie zaczynać linii od [ ani (  ani nie rozdzielać 'return x' na 2 linie:
      return
          x

       W takim razie,  co zrobić z:
           [ 1, 2, 3 ].forEach...   -  na początku jest ' [ '
       Rozw: zadeklarować najprzód tablicę a potem jej użyć:
          var arr =  [ 1, 2, 3 ]
          arr.forEach

      A co z IIFE ? :

          var x = 5

          (function() {
            console.log('zupa')
           }) ()

       Rozw: dodaj średnik na początku IIFE:
         ;( function ( ) {

_____________________________________________________________
23) JSON.parse / stringify - na przykładzie Twittera

      Ponieważ wczytanie danych z twittera funkcją przez JSON.parse - wywalało błąd,
      pomogło najpierw przepuszczenie ich przez stringify i dopiero parse:

        var x = JSON.stringify ( data )
        var y = JSON.parse ( x ).statuses
______________________________________________________________________________________________
24) JSON stringify - zwracanie wybranych propertasków

      var obj = {
        'prop1': 'value1',
        'prop2': 'value2',
        'prop3': 'value3'
      }

      console.log( obj )            // { prop1: 'value1', prop2: 'value2', prop3: 'value3' }

      var selectedProperties = ['prop1', 'prop2']

      var str = JSON.stringify(obj, selectedProperties)

      console.log(str)            // {"prop1":"value1","prop2":"value2"}

______________________________________________________________________________________________
25) new Date()

      w3schools.com/jsref/jsref_obj_date.asp
      w3schools.com/js/js_date_methods.asp

      Uwzględnienie polskiej strefy czasowej:
        let plTime = new Date().toLocaleString("pl-PL", { timeZone: "Europe/Warsaw" });
        plTime = new Date(plTime).toLocaleString()
        console.log(plTime)


      There are 4 ways of initiating a date:
          new Date()
          new Date(milliseconds)
          new Date(dateString)
          new Date(year, month, day, hours, minutes, seconds, milliseconds)

      There are generally three types of valid JS date formats:

          a) ISO Dates
              d = new Date ( "2015-03-25" )
              d = new Date ( "2015-03" )
              d = new Date ( "2015" )
              d = new Date ( "2015-03-25T12:00:00" )

          b) Long Dates
              year, month, and day can be in any order
                  d = new Date ( "Mar 25 2015" )
                  d = new Date ( "25 Mar 2015" )
                  d = new Date ( "2015 Mar 25" )

              month can be written in full (January), or abbreviated (Jan):
                  d = new Date("January 25 2015")

              Commas are ignored. Names are case insensitive:
                  d = new Date("2015, JANUARY, 25")

          c) Short Dates
              most often written with an "MM/DD/YYYY" syntax:
                  d = new Date("03/25/2015")

              either "/" or "-" can be used as a separator:
                  d = new Date("03-25-2015")

               also ok is  "YYYY/MM/DD":
                  d = new Date("2015/03/25")

           d) Full Format
               JS will accept date strings in "full JS format":
                   d = new Date("Wed Mar 25 2015 09:56:24 GMT+0100 (W. Europe Standard Time)")

               JS will ignore errors both in the day name and in the time parentheses:
                  d = new Date("Fri Mar 25 2015 09:56:24 GMT+0100 (Tokyo Time)")

_____________________________________________________________
26) new Date()  - get methods

      Get the time (Epoch timestamp - milliseconds since Jan 1, '70)

          new Date().getTime()
          Date.now()  to samo, co ww
          +new Date ( )                // timestamp
          Number(new Date())

      var x = new Date().getTime()  // 1446804434676
      var y = new Date(x)          //  Fri Nov 06 2015 11:08:14

      getDate()          Get the day as a number (1-31)
      getDay()           Get the weekday as a number (0-6)
      getFullYear()      Get the four digit year (yyyy)
      getHours()         Get the hour (0-23)
      getMilliseconds()  Get the milliseconds (0-999)
      getMinutes()       Get the minutes (0-59)
      getMonth()         Get the month (0-11)
      getSeconds()       Get the seconds (0-59)
_____________________________________________________________
27) new Date()  - set methods

      setTime()   Set the time (Epoch timestamp - milliseconds since Jan 1, 70)

      setDate()         Set the day as a number (1-31)
      setFullYear()     Set the year (optionally month and day)
      setHours()        Set the hour (0-23)
      setMilliseconds() Set the milliseconds (0-999)
      setMinutes()      Set the minutes (0-59)
      setMonth()        Set the month (0-11)
      setSeconds()      Set the seconds (0-59)

      Timestamp godziny 00:00 dziś
        const timestampTodayMidnight = new Date().setUTCHours(0, 0, 0, 0)
        console.log('todayMidniteTimestamp = ', todayMidniteTimestamp)

      String timestampa 00:00 dziś
        const todayMidniteString = new Date(todayMidniteTimestamp)
        console.log('todayMidniteString = ', todayMidniteString)
_____________________________________________________________
28) Date - new Date().setUTCHours()

      Timestamp czasu w odległości od godziny 0:00 dziś:
        new Date().setUTCHours(0, 0, 0, 0)

      To samo dla jutra:
        new Date().setUTCHours(24, 0, 0, 0)

_____________________________________________________________
29) Date.parse()

      If you have a valid date string, you can use the Date.parse() method,
      to convert it to Epoch timestamp

      timestamp = Date.parse("March 21, 2012")
_____________________________________________________________
30) Dates compare

    The following example compares today's date with January 14, 2100:

      var today, someday, text

      today = new Date()
      someday = new Date()
      someday.setFullYear(2100, 0, 14)

      if (someday > today) {
          text = "Today is before January 14, 2100."
      } else {
          text = "Today is after January 14, 2100."
      }
_____________________________________________________________
31) Date - formatowanie

      var d = new Date()

      d.toLocaleTimeString()    // 14:49:35
      d.toLocaleDateString()    // 17.09.2015
      d.toLocaleString()       //  17.09.2015, 14:49:35
      d.toDateString()        //   Thu Sep 17 2015
      d.toISOString()         //   2015-09-17T12:48:48.169Z

      new Date().toJSON().slice(0,19).replace('T', ' ')

      var x = new Date()

      console.log( x.getDate() + "-" + ( x.getMonth() + 1 ) + "-" + ( x.getYear() + 1900 ) + "  " + x.toLocaleTimeString() )
_____________________________________________________________
32) Date - formatowanie .toLocalTimeString()

      https://developer.mozilla.org/en-US/docs/Web/JS/Reference/Global_Objects/Date/toLocaleTimeString

      .toLocaleTimeString( [], { hour: '2-digit', minute:'2-digit', hour12: false  }  // w [] może być locale np. pl-PL, ale nie widać co to zmienia

       var timestamp = 1448973600000
       var t = new Date( parseInt( timestamp ) ).toLocaleTimeString( [], { hour: '2-digit', minute:'2-digit', hour12: false  } )
       var d = new Date( parseInt( timestamp ) )


      var time = t + '       ' +
                       d.getDate() + "-" +
                     ( d.getMonth() + 1 ) + "-" +
                     ( d.getYear() + 1900 )

      console.log(t)
      console.log( d.getDate() )
      console.log( d.getMonth() + 1 )
      console.log( d.getYear() + 1900 )
      console.log(time)
______________________________________________________________________________________________
33 Date - formatowanie polskich dat słownie

      Z ponizszego dostaje się datę w formacie 'Pon 11 Sty'

      const weekDayNames = ['Nie', 'Pon', 'Wt', 'Śr', 'Czw', 'Pt', 'Sob']
      const monthNames = ['Sty', 'Luty', 'Mar', 'Kwi', 'Maj', 'Cze', 'Lip', 'Sie', 'Wrz', 'Paź', 'Lis', 'Gru']

      for (let index = 0; index < 7; index++) {
        const day = new Date().getTime() + index * 1000 * 60 * 60 * 24

        const startOfDay = new Date().setUTCHours(index * 24, 0, 0, 0)

        const dayName = weekDayNames[new Date(startOfDay).getDay()]
        const dayOfMonth = new Date(startOfDay).getDate()
        const monthName = monthNames[new Date(startOfDay).getMonth()]

        const dayString = dayName + ' ' + dayOfMonth + ' ' + monthName
      }
______________________________________________________________________________________________
35) Array - podsumowanie

     thecodeship.com/web-development/common-pitfalls-when-working-with-javascript-arrays/

     o) sprawdzanie typu: Array.isArray (  )
     a) tworzenie: split, join
     b) dodawanie / odejmowanie elementów: push / pop,  unshift / shift,  slice, splice
     c) zmiana kolejności elementów: sort, reverse
     d) iteracja: forEach, map, filter
     e) test: filter, every, some
     f) dostęp: [ index ], indexOf, lastIndexOf
     g) wycinka: slice i splice
     h) wstawianie: splice
     i) łączenie tablic: a.concat(b)
     j) klonowanie tablicy: a.concat()
______________________________________________________________________________________________
36) Array - functional  - podsumowanie

      Funkcjonalna  obróbka tablicy np reducera
      Tzn przy użyciu pure function,  czyli nie zmieniając danych wejsciowych

      Mamy tablice obiektów o strukturze:
        [{ key = 0, id: 323, text: 'honda', completed: true }]

      W 1 z rekordów trzeba zmienic completed na przeciwne (true / false)

      Żeby nie tworzyc klona oryginalnej tablicy, a potem po chamsku nie usuwac z niej
      wybranego elementu, po to by na jego miejsce wstawic taki sam tylko o przeciwnym completed,
      lepiej zwrocic sklejke zlozoną z 3 jej czesci. Użyjemy slice'a bo w odróżnieniu od splice'a nie modyfikuje tablicy:

        a) od poczatku tablicy do kliknietego elementu  ( patrz var start  )
        b) dodaj concatem zmieniony element  ( patrz var mid  )
        c) od miejsca za ww elementem do końca tablicy  ( patrz var end )

      export const reducer =  ( state = [  ] ,  action   )  =>  {

        if ( action.type === 'COMPLETING'  )  {
          console.log( JSON.stringify (  action.key  ) )

          var start  =  state.slice ( 0, action.key )
          var mid =    [ { id: action.id,  text:  action.text,   completed: !action.completed } ]
          var end  = state.slice ( action.key + 1 )
          var arr  =   [ ...start, ...mid, ...end  ]

          console.log( JSON.stringify ( start ))
          console.log( JSON.stringify ( mid ))
          console.log( JSON.stringify ( end ))

          console.log( JSON.stringify ( arr ))
          return   [ ...start, ...mid, ...end  ]
        }

______________________________________________________________________________________________
37) Array - map vs forEach

      Udemy: Stephen Grider - ES6 Javascript: The Complete Developer's Guide    #3-6 forEach

      UWAGA !!
        Funkcji map() nie można przerwać. Ani breakiem, ani returnem.
        Zawsze wykona się do końca ilości elementów
        Jeśli potrzebna jest funkcja, przerywająca działanie na tablicy
        gdy znajdzie jakiś element, użyj find() i findIndex()

      Funkcja map, nie zmienia oryginalnej tablicy
      map() służy stworzeniu nowej, przekształconej z oryginalnej, tablicy - zwraca NOWĄ tablice.

      Dlatego nadaje się do chainingu (pipe'owania), a więc jest częścią functional programming

      forEach() służy działaniu na elementach tablicy - nie zwraca NOWEJ tablicy. Ale może zwracać wynik działania na jej elementach

          let a = [ 1, 2, 3 ]

          let b = arr.map(function(item) {
            return item * 2
          })

          console.log(a)     // [ 1, 2, 3 ] - nie zmieniona
          console.log(b)    //  [ 2, 4, 6 ]

       Przekształcenie klasycznej składni map,  w fat-arrow'ową:

          const a = [ 1, 2, 3, 4 ]

          let b = a.map(function (item) {
            return item * 2
          })

          let c = a.map(item => item * 2)
          console.log( 'c = ', c)   //  [ 2, 4, 6, 8 ]

       forEach iterates over a list and applies some operation with side effects to each list member
      (such as saving each one to the database for example)

   --------------------------------------------------------------
     var arr = [ 1, 2, 3, 4 ];

      let sum = 0

      let tablica = arr.forEach ( function ( item,  index ) {
        sum = sum + item
        console.log( index +  ' = ' +  item + ' sum = ' + sum )
        return sum
      })

      console.log ( 'sum = ',  sum )

   -------------lub można wyłączyć funkcję iteratora : ---------------------------------------

        var arr = [ 1, 2, 3, 4 ];

        let sum = 0

        let iterator = function ( item, index ) {
            sum = sum + item
            console.log( index +  ' = ' +  item + ' sum = ' + sum )
            return sum
        }

        let tablica = arr.forEach ( iterator )

        console.log ( 'sum = ',  sum )
______________________________________________________________________________________________
38) Array - map over JSON

    var magazyn = require('../data/magazyn')

    function znajdzTowar() {
      console.log( 'SKU     Name         Qty'   )
      magazyn.map(function(item) {
          console.log( item.sku + '  ' + item.name + '  ' + item.qty)
      })
    }

    znajdzTowar()

-------------------- data/magazyn.json ------------------------------------------

    [
      {
        "inStock": "1456",
        "category": "Solar panels",
        "name": "K-Eco 180",
        "qty": "1",
        "sku": "KE180",
        "power": "180",
        "footprint": "12.1",
        "cost": "$162.00",
        "retail": "$315.00",
        "product": "Economy",
        "target": "Domestic",
        "avail": "In stock"
      },
      {
        "inStock": "2500",
        "category": "Solar panels",
        "name": "K-Eco 200",
        "qty": "1",
        "sku": "KE200",
        "power": "200",
        "footprint": "13.4",
        "cost": "$180.00",
        "retail": "$350.00",
        "product": "Economy",
        "target": "Domestic",
        "avail": "In stock"
      },
      {
        "inStock": "2136",
        "category": "Solar panels",
        "name": "K-Eco 225",
        "qty": "1",
        "sku": "KE225",
        "power": "225",
        "footprint": "14.2",
        "cost": "$198.00",
        "retail": "$385.00",
        "product": "Economy",
        "target": "Domestic",
        "avail": "In stock"
      }
  ]
______________________________________________________________________________________________
39) Array - map over JSON - search

      var magazyn = require('../data/magazyn')

      function znajdz(sku) {
        return magazyn.map(function(item) {
          return item.sku
        }).indexOf(sku)
      }

      console.log(znajdz('KE225'))

-------------------- data/magazyn.json ------------------------------------------

    [
      {
        "inStock": "1456",
        "category": "Solar panels",
        "name": "K-Eco 180",
        "qty": "1",
        "sku": "KE180",
        "power": "180",
        "footprint": "12.1",
        "cost": "$162.00",
        "retail": "$315.00",
        "product": "Economy",
        "target": "Domestic",
        "avail": "In stock"
      },
      {
        "inStock": "2500",
        "category": "Solar panels",
        "name": "K-Eco 200",
        "qty": "1",
        "sku": "KE200",
        "power": "200",
        "footprint": "13.4",
        "cost": "$180.00",
        "retail": "$350.00",
        "product": "Economy",
        "target": "Domestic",
        "avail": "In stock"
      },
      {
        "inStock": "2136",
        "category": "Solar panels",
        "name": "K-Eco 225",
        "qty": "1",
        "sku": "KE225",
        "power": "225",
        "footprint": "14.2",
        "cost": "$198.00",
        "retail": "$385.00",
        "product": "Economy",
        "target": "Domestic",
        "avail": "In stock"
      }
  ]
______________________________________________________________________________________________
40) Array - for in

    var arr = [ 'Joe', 'Mary' ]

    for (var prop in arr) {
        console.log( prop + ' : ' + arr[ prop ] )  //  0:Joe   1:Mary
    }

    Ale, jeśli wcześniej zmodyfikowany został wbudowany typ Array, np:
      Array.prototype.mojaPropertka = 'syf'
    to wynikiem pętli będzie:
      0:Joe   1:Mary    mojaPropertka : syf

    Dlatego do arrajek lepiej zamiast for-in używać zwykłego for'a:

      for (var i = 0 i < arr.length i++) {
        console.log(arr[i])   // 0:Joe   1:Mary
      }
______________________________________________________________________________________________
41) Array - filter

      Tworzy nową tablicę z wszystkimi elementami, które przechodzą test
      Nie zmienia oryginalnej tablicy

---------------
      const a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]

      const b = a.filter ( function( item, index ) {
        console.log ( index )
        return item % 2 === 0       // [ 2, 4, 6, 8, 10 ]
      })
      .filter ( function ( item ) {
        return item > 5                   // [ 6, 8, 10 ]
      })

      console.log ( b )    // [ 6, 8, 10 ]

--------------- Znajdowanie rekordów w których jest substring --------------------

      const baza = [
      [1,"szyszki chmielu","kwiat lawendy","ziele serdecznika","liść melisy","kwiatostan głogu","liść mięty pieprzowej","korzeń kozłka","kwiat tarniny"],
      [2,"koszyczek rumianku pospolitego","korzeń kozłka","kwiatostan głogu","korzeń arcydzięgla","liść melisy","kwiat lawendy","szyszki chmielu"],
      [3,"liść rozmarynu","ziele miłka wiosennego","liść ruty","korzeń kozłka"]
      ]

      let b = baza.filter ( function( item1 ) {
        let c = item1.some ( function ( item2 ) {
          if (item2.toString().lastIndexOf('szysz')  != -1 )  {
            return true
          }
        })
          return c
      }).filter (function(item) {
        if (item.toString().lastIndexOf('głogu') != -1) {
          return true
        }
      })

      console.log ( b )

--------------------------------
    ES6:
      let bears = ['polar', 'koala'].filter((bear) => bear !== 'koala')
      console.log(bears)
______________________________________________________________________________________________
42) Array - filter > map (array)

      var people = [
        { fname: 'John', lname: 'Smith', bday: '2/2/1979' },
        { fname: 'Jane', lname: 'Smith', bday: '3/3/1981' },
        { fname: 'Jack', lname: 'Smith', bday: '4/4/1982' }
      ]

      people.filter(function(person) {
        return new Date(person.bday).getFullYear() > 1979
      })
      .map(function(person) {
        return {
          name: person.fname + ' ' + person.lname,
          age:  new Date().getFullYear() - new Date(person.bday).getFullYear()
        }
      })
      .map(function(person) {
        console.log(person)
      })
______________________________________________________________________________________________
43) Array - filter > map (json)

      Z tablicy obiektów w 61c) zrób zewnętrzny plik, sformatuj go jako jsona (ujmij keys w skobki),
      zaimportuj plik w index.js i reszta jak w 61c)

-------------- people.json -------------------------------------

        [
          { "fname": "John", "lname": "Smith", "bday": "2/2/1979" },
          { "fname": "Jane", "lname": "Smith", "bday": "3/3/1981" },
          { "fname": "Jack", "lname": "Smith", "bday": "4/4/1982" }
        ]

------------- index.js -------------------------------------------

        var people = require('./people')

        people.filter(function(person) {
            return new Date(person.bday).getFullYear() > 1979
        })
        .map(function(person) {
          return {
            name: person.fname + '  ' + person.lname,
            age: new Date().getFullYear() - new Date(person.bday).getFullYear()
          }
        })
        .map(function(person) {
            console.log( person  )
        })
______________________________________________________________________________________________
44) Array - concat

      Klonowanie przez arrA = arrB jest niebezpieczne, bo tablica to typ referensowy,
      więc '=' nie tworzy nowej tablicy a tylko linkę (reference) do tablicy oryginalnej (arrA).
      W efekcie zmiana arrB spowoduje zmianę w arrA:

      var a = [ 1, 2, 3, 4 ]
      var b = a
      b.push(5)
      console.log(b)  [ 1, 2, 3, 4, 5 ]
      console.log(a)  [ 1, 2, 3, 4, 5 ]

      Dlatego lepiej stworzyć klona funkcją concat  ( patrz p.63 )

        let b = a.concat()    // klon a

______________________________________________________________________________________________
45) Array - reduce 1

      medium.com/@joshpitzalis/reduce-f47a7da511a9#.65s2saxlk

      Sumuje elementy tablicy na zasadzie akumulatora, którym jest 'total'
      Co okrążenie, jest do niego dodawana nowa, wzięta z tablicy wartość ( 'amount' )

      const arr = [ 1, 2, 3 ];

      let sum = arr.reduce ( function ( akumulator, item, index ) {
        console.log ( 'index = ',  index )
        console.log ( 'akumulator = ',  akumulator )
        console.log ( 'item = ',  item )
        console.log( '___________________________________' )

          return akumulator + item
      }, 0 )   // wartość początkowa akumulatora.
                // Przy jej braku, akumulator = 1-szemu itemowi

      console.log ( 'sum = ',  sum )

 -  -  -  -  -  -  -  - wyświetli:  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

      akumulator =  0
      index =  0
      item =  1
      ___________________________________
      akumulator =  1   //  = akumulator + item
      index =  1
      item =  2
      ___________________________________
      akumulator =  3   //  = akumulator + item
      index =  2
      item =  3
      ___________________________________
      sum =  6         //  = akumulator + item

______________________________________________________________________________________________
46) Array - reduce 2

      UWAGA !
        Pamiętaj o umieszczeniu wartości początkowej

      const stock = [
        { title: 'Harry Potter', price: 10 },
        { title: 'Eloquent JS', price: 15 }
      ]

      function shop(stock) {
        return {
          stock,
          stockValue() {
            return this.stock.reduce((sum, book) => {
              return sum + book.price
            }, 0)
          }
        }
      }

      const newShop = shop(stock)

      console.log(newShop.stock)
      console.log(newShop.stockValue())

______________________________________________________________________________________________
47) Array - every

      Sprawdza, czy wszystkie elementy tablicy przechodzą test

      var nums = [ 1, 2, 3 ]

      var test = nums.every ( function ( item ) {
        return item > 0
      })

      console.log( test )    // true
______________________________________________________________________________________________
48) Array - some

      Sprawdza, czy choć 1 element tablicy przechodzi test

      var nums = [ 1, 2, 3 ]

      var test = nums.some(function(item) {
        return item > 2
      })

      console.log( test )    // true
______________________________________________________________________________________________
49) Array - join

    Robi z tablicy, stringa.
    Jeśli w nawiasie poda się pusty string, elementy nie będą niczym rozdzielone
    Jeśli w cudzysłowie poda się jakiś znak lub string, zostanie on użyty jako separator
    Join nie zmiena oryginalnej tablicy

    var a = [ 1, 2, 3, 4 ]

    console.log(a.join())          // 1,2,3,4
    console.log(a.join(','))       // 1,2,3,4
    console.log(a.join(''))      //   1234

______________________________________________________________________________________________
50) Array - split

      Robi ze stringa tablicę substringów

    UWAGA !
      Mutuje oryginalną tablicę
      Dzieje się tak, bo obiekty tworzone są przez referencję,
      czyli tworzony jest tylko link do adresu w pamięci pierowtnej tablicy

      W efekcie, jak w poniższym przykładzie, fizycznie tablica jest  jedna,
      a stworzenie nowej przez arr2 = arr1, tworzy tylko linkę o nazwie 'arr2'

      W konsekwencji, jeśli na tablicy arr2 zrobimy jakąś operację, np reverse,
      to arr1 zmieni się tak samo:

      var arr1 = "dupa".split('')
      var arr2 = arr1.reverse()

      console.log(arr2)  // apud
      console.log(arr1)  // apud
______________________________________________________________________________________________
51) Array - slice (non mutating, exclusive index)

      Zwraca wycinek tablicy, bez zmieniania jej
        const arr = [1, 2, 3, 4]
        const x = arr.slice(1, 3)   // [2, 3]   pozycja 3 się nie łapie
        const x = arr.slice(0, 2)   // [1, 2,]  pozycja 2 się nie łapie

      Jeśli nie ma drugiego argumentu, brana jest cała tablica od argumentu pierwszego
        const x = arr.slice(1)      // [2, 3, 4]

      Jeśli nie ma drugiego argumentu, a pierwszy jest ujemny, branych jest n elementów od końca
        const x = arr.slice(-1)     // [4]
        const x = arr.slice(-2)     // [3, 4]

      --------- wstawienie do środka innej tablicy (ale nie splicem, ktory ja mutuje)  ------

      const arr1 = [1, 2, 3, 4]

      const arr2 = arr.slice(0,2).concat([5, 6]).concat(arr.slice(2,4))

      console.log(arr1)  // [1, 2, 3, 4]
      console.log(arr2)  // [1, 2, 5 , 6, 3, 4]

      --------- wycięcie wybranego elementu z tablicy --------------------

      const arr1 = [1, 2, 3, 4]

      const deleteNo = 2  // 3

      const arr2 = arr1.slice(0, deleteNo).concat(arr1.slice(deleteNo + 1))  // [1, 2, 4]

______________________________________________________________________________________________
52) Array - splice (mutating, count)

      w3schools.com/jsref/jsref_splice.asp

      Dodaje i odejmuje elementy tablicy, mutując ją:

        array.splice(index, deleteCount, item1,.....,itemX)

      Jeśli nie chcesz mutowania (side effect sprzeczny z FP immueability), użyj slice'a j/w

      var fruits = ["Banana", "Orange", "Apple", "Mango"]
      fruits.splice(2, 0, "Lemon", "Kiwi")      //  Banana,Orange,Lemon,Kiwi,Apple,Mango

      Negative index -  position from the end of the array
-----------------------------
      var a = [ 1, 2, 3, 4 ]

      console.log(a.splice(1, 2))    // [ 2, 3 ]
      console.log(a)                //  [ 1, 4 ] - pozostała część tablicy

      UWAGA !
        Co prawda można do wykasowania elementu tablicy użyć
            delete a[1]
          ale zamiast faktycznego skasowania elementu, jego wartość zostanie zastąpiona undefined,
          a długość tablicy pozostanie taka sama
            [ 1, undefined, 3, 4 ]

______________________________________________________________________________________________
53)  Array - substr vs substring

      const x = "HelloWorld"

      x.substring (1, 5)  // 'ello'  od, do
      x.substr (1, 5)     // 'elloW'  od, ilość
______________________________________________________________________________________________
54) Array - indexOf, lastIndexOf

      Znajduje index pozycji, na której wystepuje w tablicy szukany element

      var x = [ 1, 2, 3, 5, 1 ]

      console.log(x.indexOf(5))      // 3
      console.log(x.lastIndexOf(1))  // 4
______________________________________________________________________________________________
55) Array - push, pop, unshift, shift

      var x = [ 1, 2, 3 ]

      x.push(4)
        console.log(x)  // [1,2,3,4] - dodaje element na koniec tablicy

      x.pop()
        console.log(x)  // [1,2,3] - ściąga element z końca tablicy

      x.unshift(9)
        console.log(x)  // [9,1,2,3] -  - dodaje element na początek tablicy

      x.shift()
        console.log(x)  // [1,2,3] -  - ściąga element z początku tablicy

______________________________________________________________________________________________
56) Array - reverse, sort  ( też 331 )

      var x = [ 9, 1, 7 ]
      x.sort ( )     // [1,7,9] - sortuje rosnąco
      x.reverse( )  //  [7,1,9] - odwraca kolejnośc elementów
                    //  jeśli wcześniej było sort(), to teraz reverse posortuje malejąco

      sort() domyślnie sortuje stringi, lub cyfry
      Liczby posortuje tekstowo, czyli: [1, 2, 11, 121].sort() = [1, 11, 121, 2]

      Żeby liczby posortował dobrze, trzeba mu dać callbacka:
      [1, 2, 11, 121].sort((a, b) => { return a - b })  // rosnąco. Lub b - a  - malejąco

______________________________________________________________________________________________
57) Array - entries

      Zwraca iteratora tablicy zawierającej key/value dla każdego elementu tablicy

      var arr = ["a", "b", "c"]

      var x = arr.entries()

      console.log ( x.next ( ).value )    // [ 0, 'a' ]
      console.log ( x.next ( ).value )    // [ 1, 'b' ]
      console.log ( x.next( ).value )   //  [ 2, 'c' ]
______________________________________________________________________________________________
58) Array - concat

      let ar1 = [ 1, 2, 3 ]
      let ar2 = [ 4, 5, 6 ]

      let ar3 = ar1.concat(ar2)
      let ar4 = ar1.concat()    // klon ar1

      console.log(ar3)  //  [ 1, 2, 3, 4, 5, 6 ]
      console.log(ar4)  //  [ 1, 2, 3 ]  = klon ar1
______________________________________________________________________________________________
59) Array - porównywanie

      Trzeba porównać też długości obu tablic, bo pętla every porówna tylko,
      czy każdy z elementów tablicy a równy jest odpowiedniemu elementowi tablicy b

      const a = [ 1, 2, 3 ]
      const b = [ 1, 2, 4 ]

      const test = a.every((item, index) => item == b[index])
      const odp = test && a.length === b.length

      console.log(odp)
______________________________________________________________________________________________
60) Array - flat

      const arr = [[1, 2 ], [3, [[4]]]]
      console.log(arr.flat())         //  [ 1, 2, 3, [ [ 4 ] ] ]
      console.log(arr.flat(1))        //  [ 1, 2, 3, [ [ 4 ] ] ]
      console.log(arr.flat(2))        //  [ 1, 2, 3, [ 4 ] ]
      console.log(arr.flat(3))        //  [ 1, 2, 3, 4 ]
      console.log(arr.flat(Infinity)) //  [ 1, 2, 3, 4 ]
______________________________________________________________________________________________
61) Array - from

    const arr1 = [1, 2, 3, 4]
    const arr2 = Array.from(arr1)   // płytka kopia

    // tablica z 5 losowymi liczbami
    const arr3 = Array.from({length: 5}, el => parseInt(Math.random() * 10))

______________________________________________________________________________________________
64) String - indexOf, lastIndexOf

      Szukaj indeksu na którym zaczyna się substring
      Jako substringa nie można użyć regexa

      string.indexOf(substring, start)

      const string = 'abc123a'

      console.log(string.indexOf('a'))     // 0
      console.log(string.indexOf('a', 4))     // 6

      console.log(string.lastIndexOf('a')) // 6
      console.log(string.lastIndexOf('a', 6)) // 6
______________________________________________________________________________________________
65) String - search

      Szukaj indeksu na którym zaczyna się substring
      Jako substringa można użyć regexa

      string.search(substring)

      const string = 'abc123a'

      console.log(string.search('a'))  // 0
______________________________________________________________________________________________
66) String - slice

      Wycina kawałek stringa wg indeksów początku i końca
      przy czym index końca się nie łapie.
      Nie mutuje oryginalnego stringa

      string.slice(start, end)

      const string = 'abc123a'

      console.log(string.slice(2,4))  // c1
      console.log(string)             // abc123a

______________________________________________________________________________________________
67) String - substr i substring

      string.substr(start, ilość)
      string.substring(start, end - nie łapie się)

      const string = 'abc123a'

      console.log(string.substr(2,4))  // c123
      console.log(string.substring(2,4))  // c1

______________________________________________________________________________________________
68) String - replace

      const string = 'abc123'
      console.log(string.replace('abc', 'ABC'))  // ABC123a

______________________________________________________________________________________________
69) String - toUpperCase, toLowerCase

      const string = 'aBc123A'

      console.log(string.toLowerCase())  // abc123a
      console.log(string.toUpperCase())  // ABC123A
______________________________________________________________________________________________
70) String - trim

      Wycina ze stringa początkowe i końcowe spacje

      const string = '  abc 123  '
      console.log(string.trim())  // abc 123

______________________________________________________________________________________________
71) String - charAt

      const string = 'abc123'
      console.log(string.charAt(1))   // b
______________________________________________________________________________________________
72) String - charCodeAt

      Kod litery

      const string = '12ABab'

      console.log(string.charCodeAt(0))   // 49
      console.log(string.charCodeAt(1))   // 50
      console.log(string.charCodeAt(2))   // 65
      console.log(string.charCodeAt(3))   // 66
      console.log(string.charCodeAt(4))   // 97
      console.log(string.charCodeAt(5))   // 98
______________________________________________________________________________________________
73) String - fromCharCode

      String.fromCharCode(65)  // A

______________________________________________________________________________________________
74) String - split

      Ze stringa tworzy tablicę

      const string = '12ABab'
      console.log(string.split(''))  // [ '1', '2', 'A', 'B', 'a', 'b' ]
______________________________________________________________________________________________
76) lodash - top 16

  yarn add lodash  // albo
  const _ = require('lodash/core')  // 14k zamiast 71 przy całym lodaszu

  ------------------------------------------------------
  1) Utils (times, deburr, uniqueId, random, range)

    // 1. times
    _.times(5, () => console.log('dupa'))

    // 2. random
    _.random(15, 20) // Get a random number between 15 and 20.

    // 3. range
    range(1, 4) // [1,2,3]   range(4,1) // [4,3,2]

  ------------------------------------------------------
  2) Object (pick, omit, assign, cloneDeep)

      // 1. pick
        const objA = { name: "colin", car: "suzuki", age: 17 }
        const objB = _.pick(objA, ["car", "age"]); // {"car": "suzuki", "age": 17}

      // 2. omit - removing props from the object
        const objA = { name: "colin", car: "suzuki", age: 17 }
        objA = _.omit(objA, ["car", "age"]) // {"name": "colin"}

      // 3. cloneDeep
        const original = { foo: "bar" }
        const copy = _.cloneDeep(original)
        copy.foo = "new value"   // copy -> { foo: "new value" } Yeah!
                                //  original -> { foo: "bar" } Yeah!

      // 4. assign
        const objA = { name: "colin", car: "suzuki" }
        const objB = { name: "james", age: 17 }
        const objC = { pet: "dog" }

        _.assign(objA, objB, objC) // {"name": "james", "car": "suzuki", "age": 17, "pet": "dog"}

  ------------------------------------------------------
  3) Array (union, difference, intersection, sample, unique, shuffle, take)

      const a = [1, 2, 3, 4]
      const b = [1, 2, 3, 5]

      const a = [ 1, 2, 3 ]
      const b = [ 1, 2, 4 ]

      console.log('union = ' + _.union(a, b))                // [1, 2, 3, 4]
      console.log('difference = ' + _.difference(a, b))      // [3]
      console.log('intersection = ' + _.intersection(a, b))  // [1, 2]
      console.log('sample = ' + _.sample(a))                 // [3]
      console.log('uniq = ' + _.uniq([1, 2, 2, 3, 4, 4]))    // [1, 2, 3, 4]
      console.log('shuffle = ' + _.shuffle(a))               // [ 1, 3, 2]
      console.log('take = ' + _.take(a, 2))                  // [ 1, 2]
      console.log('takeRight = ' + _.takeRight(a, 2))        // [ 2, 3]
  ------------------------------------------------------
  4) Array of objects (find, sortBy, keyBy)

      // 1. find

          const a = [
            { name: 'jan', age: 11, city: 'wwa'},
            { name: 'adam', age: 22, city: 'gda'},
            { name: 'bob', age: 22, city: 'gda'}
          ]

          const x = _.find(a, { age: 22 }) // { name: 'adam', age: 22, city: 'gda' } - 1-szy spełniający kryteria

      // 2. sortBy

          const a = [
            { name: 'adam', age: 22, city: 'wwa'},
            { name: 'jan', age: 11, city: 'gda'},
            { name: 'adam', age: 22, city: 'poz'}
          ]

          _.sortBy(a, ['age', 'city'])

      // 3. keyBy - szuka tylko 1 rekordu, wiec nadaje się do szukania unikalnego rekordu (np id)

          const a = [
            { name: 'jan', age: 33, city: 'wwa'},
            { name: 'jan', age: 22, city: 'gda'},
            { name: 'bob', age: 22, city: 'gda'}
          ]

          _.keyBy(a, 'city') // { name: 'bob', age: 22, city: 'gda' }
______________________________________________________________________________________________
77) ES6 - wybrane części - ściąga

      CodeSchool  - ES 2015
      https://ponyfoo.com/articles/es6

      1) let, const

      2) Arrow functions (fat arrow) - skrót przydatny przy jednolinijkowych funkcjach

          let x = function(a,b) return a + b
          let x = (a,b) => a + b   // pominięcie słowa kluczowego function
                                  //  zastąpienie nawiasów i return tłustą strzalką (choć nawiasy i return są opcjonalne)
          x(1,2) // 3

      3) String templates

          a)  wieloliniowe stringi (bacticks)
                let x = `bl ada
                dupa`            // blada
                                      // dupa
          b)  templates
                let bear = 'grizzly'
                let say = 'growl'
                console.log( `The ${bear} says ${say}` )

      4) Default parameters  - function bear ( type='grizzly' ) {        // typ='grizzly' - default argument

      5) Rest parameters -  function bear(...types) {  console.log(types)  }     bear('polar', 'uszatek')     // ["polar", "uszatek"]

      6) Object.assign - dodanie obiektów
          let obj1 = { one: 1 }
          let obj2 = { two: 2 }

          let obj12 = Object.assign(obj1, obj2)
          console.log(obj12)       //  { one: 1, two: 2 }

      7) Set - struktura danych trzymająca tylko unikalne wartości

      8) Map - tworzy uproszczony obiekt, zawiera tylko pary key-value, żadnych funkcji. Dzięki temu łatwiejsza iteracja, bo nie trzeba sprawdzać, czy bieżący element to key-value czy funkcja

      9) Promises
______________________________________________________________________________________________
78) ES6 - let

    CodeSchool: ES 2015  - 1.2 let in for loops

     a) scopem var jest funkcja, a let'a  -  blok   ( nawiasy klamrowe  - curly braces )
     b) let ani const nie można redefiniować,  a const nawet reassignować
     c) z let lub const nie można używać tablicy arguments

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
      let type = 'grizzly'

      if ( true) {
          let type = 'uszatek'
          console.log('1: ' + type)   // 1: uszatek

          if ( true ) {
              let type = 'polar'
              console.log('2: ' + type)  // 2: polar
          }
      }

      console.log('3: ' + type)   // 3: grizzly

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    var a = 5
    var a  = 10

    let b = 5
    let b = 10   // Identifier 'b' has already been declared

______________________________________________________________________________________________
79) ES6 - const

    CodeSchool: ES 2015  - 1.3 const

      a) scopem var jest funkcja, a let'a - blok ( nawiasy klamrowe  - curly braces )
      b) let ani const nie można redefiniować
      c) z let lub const nie można używać tablicy arguments
      d) const nie można najpierw zadeklarować a dopiero potem dać jej wartość  ( assign )

      e) const - prymitywa nie można zmienić, ale obiekt - tak
                Wniosek: const nie zapewnia immutability, a tylko stałość (niezmienność) bindingu (no rebinding)
                Jeśli chcesz immutability - użyj Object.freeze()

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

  b) constant nie może być zmieniana  ( reassign )

      const A = 5
      const A = 55  // error

  d) zmiennej constant trzeba w chwili deklaracji nadać wartość
      Nie można najprzód zadeklarować, a dopiero potem dać wartość
        const A
        A = 5          // error

  e) const - prymitywa nie można zmienić, ale obiekt - tak

      const user = { name: 'jan', age: 11, city: 'wwa'}
      user.name = 'adam'
      user.size = 'XL'

      { name: 'adam', age: 11, city: 'wwa', size: 'red' }


      const user = Object.freeze({ name: 'jan', age: 11, city: 'wwa'})

______________________________________________________________________________________________
80) ES6 - class

      Udemy - S.Grider: ES6  #15 class

      Między metodami klasy nie ma przecinków
      Klasa dziedzicząca zawiera 'extends' i nazwę klasy parenta

      Child w swym konstruktorze zawiera komendę super(), która woła konstruktor parenta
      Tak więc super(arg1, arg2) przekazuje argumenty do kontruktora parenta

      class Car {
        constructor() { }

        drive() {
          return 'Car: vrrrrrrrrrrr '
        }
      }

      class Toyota extends Car {
        constructor() {
          super()
        }

        horn() {
          return 'Toyota: beeep !'
        }
      }

      const toyota = new Toyota

      console.log(toyota)
      console.log(toyota.drive())
      console.log(toyota.horn())
______________________________________________________________________________________________
81) ES6 - class extends

      Udemy - S.Grider: ES6  #15 class

      class Car {
        constructor(options) {
          this.title = options.title
        }

        drive() {
          return 'vrooooom'
        }
      }

      class Toyota extends Car {
        constructor(options) {
          super(options)
          this.color = options.color
        }

        honk() {
          return 'beep'
        }
      }

      const toyota = new Toyota({ color: 'red', title: 'Honda' })
      console.log(toyota)
      console.log(toyota.title)
      console.log(toyota.color)
      console.log(toyota.honk())
      console.log(toyota.drive())
______________________________________________________________________________________________
82) ES6 - shorthand object creation

      Jeśli key i value są tym samym stringiem, definiując obiekt, można użyć tylko jednego z nich

        age = 40
        name = 'Joe'

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
        ES5:
          let guy = { name: name, age: age }

          function guy(name, age)  {
            return { name: name, age: age }
          }
-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
       ES6:
        let guy = { name, age }

        function guy(name, age)  {
          return { name, age }
        }
-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
      Jeśli ww to jakby fukcja zapisu, analogiczną funkcją odczytu będzie
      Object Destructuring  ( patrz 90, 91 )
______________________________________________________________________________________________
83) ES6 - enhanced object literals

      Enhanced object literals pozwala na skrócony zapis propertek i metod obiektów:

        a) propertka:
            jeśli jej nazwa i wartość są takie same, to wystarczy jedno słowo
            ( zwyczajowo ustawia się je na początku ) :

              function save ( url, data )  {
                $.ajax ( {  url, data, method: 'POST' } )
              }

        b) metoda:
            można pominąć  dwukropek i 'function'
 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

      function createShop ( inventory )  {
        return  {
          //inventory: inventory,
          inventory,
          // inventoryValue: function () {
          inventoryValue() {
              return this.inventory.reduce ((acc, book )  => acc + book.price, 0)
          }
        }
      }

      const inventory =  [
        { title: 'Harry Potter', price: 10 },
        { title: 'JS', price: 15 }
      ]

      const shop = createShop(inventory)
      console.log(shop.inventory)
      console.log(shop.inventoryValue())

______________________________________________________________________________________________
84) ES6 - lexical this

    const obj = {
      x: 1,
      getX() {
        // const inner = function() {   // undefined (ES5)
        const inner = () => {          //  1 (ES6)
          console.log(this.x)
        }
        inner()
      }
    }

    obj.getX()

    -------------------------------------------------------------

    const profile = {
      name: 'dupa',
      // getName: function() {      // dupa
      getName: () =>         {      // undefined
        console.log(this.name)
      }
    }

    profile.getName()

______________________________________________________________________________________________
85) ES6 - string templates

      a) templates
            let bear = 'grizzly'
            let say = 'growl'
            console.log( `The ${bear} says ${say}` )

      b) multiline strings (bacticks)
            let x = `blada
            dupa`            // blada
                            // dupa

______________________________________________________________________________________________
86) ES6 - destructuring

      developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Operatory/Destructuring_assignment

      a) object destructuring
          const user = { name: 'jan', age: 11, city: 'wwa'}

          function ada({name, age, city}) {  // tu jest destr
            console.log('Tu + ', name)
            console.log('Tu + ', age)
            console.log('Tu + ', city)
          }

          ada(user)
          -------------------------------------------------------

          const { name, age, city } = user.name  // tu jest destr
          console.log(name)


      b) Array destructuring

          Przy małych tablicach można użyć  nast skrótów:

          const cars = [ 'fiat', 'honda', 'bmw' ]

          let [ pierwszy, drugi ]  =  cars  // pierwszy  =  fiat
                                              // drugi  =  honda

          let [ ,,trzeci ]  =  cars      // trzeci  =  bmw
          let [ pierwszy, , trzeci ]  =  cars      // trzeci  =  bmw
          Gdy chodzi o początkowe elementy, można użyć:

          let [ pierwszy,...reszta ]  =  cars      // trzeci  =  bmw

          console.log ( 'pierwszy = ',  pierwszy )   // fiat
          console.log ( 'rest = ',  ...reszta )               //  honda bmw

      d)  Arrays destructuring default values

          const cars = [ 'fiat' ]
          const [ pierwszy, drugi  =  'ford' ]  =  cars  // pierwszy  =  fiat, drugi  =  honda

      e) Array values swapping

          const a = 2
          const b = 5

          [ a, b ] = [ b, a ]
          console.log ( a )  // 5
          console.log ( b )  // 2

      f) Default values  ( in case of undefined )

          const { foo = 3 } = { foo: undefined }
          console.log(foo) // 3       to samo, co:  var bar = undefined || 3

      g) Object destructuring with aliases

          const car = { marka: 'honda', cena: 1000 }
          const { marka: nazwa, cena: koszt } = car

          console.log( nazwa + ' ' + koszt )   // honda  1000

      h) Object destructuring with default values  ( and aliases  )

            var car = { marka: 'honda', cena: 1000 }
            var { marka, cena, kolor: masc =  'szary' } = car
            console.log( marka + ' ' + cena + ' ' + masc)   // honda  1000  szary

______________________________________________________________________________________________
87)  ES6 - default parameters: 1

      function x(a, b = 10) {
        return b
      }

      console.log(x())    // 10
      console.log(x(5))   // 10
      console.log(x(5,6)) // 6

______________________________________________________________________________________________
88) ES6 - default parameters: 2

      Zamiast:

        function User(id) {
          this.id = id
        }

        function generateId() {
          return Math.random() * 999999
        }

        function createAdmin(user) {
          user.admin = true
          return user
        }

        const a = createAdmin(new User(generateId()))

        console.log(a)
    ---------------------------------------------
      Lepiej:

        function makeId() {
          return Math.random() * 999999
        }

        function User(id) {
          this.id = id
        }

        function userAdmin(user = new User(makeId())) {
          user.admin = true
          return user
        }

        const juzek = userAdmin()
        console.log(juzek)

______________________________________________________________________________________________
89) ES6 - named parameters

      CodeSchool: ES2015 - 2.1 Functions

        function oferta(msg, { name, city, age } = {}) {
          console.log('msg = ', msg)
          console.log('name = ', name)
          console.log('city = ', city)
          console.log('age = ', age)
        }

        oferta('Kup samochód !', {
          city: 'warszawa',
          name: 'fiat',
          age: 500
        })

      Parametry podaje się jako short-hand notation obiekt:
        function x ( msg,  { popular, expires, activeClass } )  { .. }

      co odpowiada pełnej wersji:
        function x ( msg,  { popular: popular, expires: expires, activeClass: activeClass } )  {

     Dzięki temu, w wywołaniu funkcji, kolejność parametrów może być dowolna, np:

      x('Hi all !', {
        activeClass: 'kupa',
        expires: 1000,
        popular: true
      })

      Mało tego, można pominąć część parametrów i zamiast błędu,
      brakujące paramtery będą miały wartość undefined

        x('Hi all !', {
          popular: true,
        })

      Można też pominąć obiekt w ogóle, ale wtedy, by uniknąć błędu, trzeba podać defaulta:
        function x ( msg,  { popular, expires, activeClass }  =  {  } )  {

______________________________________________________________________________________________
90) ES6 - rest vs spread

      function liczby(...nums) {       // rest
        console.log(nums)              // [12, 3, 56]
        console.log(...nums)           // 12  3  56 - spread
        console.log(Math.max(...nums)) // 56 - spread
        const arr = [1, 2, ...nums, 100, 101]
        console.log(arr)               // [ 1, 2, 12, 3, 56, 100, 101 ]
        const arr2 = [...nums].map(el => el *2)  // spread
        console.log(arr2)              // [ 24, 6, 112 ]
      }

      liczby(12, 3, 56)


      a) Rest z listy argumentów funkcji robi tablicę,
         Spread odwrotnie: z tablicy robi listę argumentów

      b) Rest - w sygnaturze funkcji
         Spread - w ciele

      c) Rest musi wystąpić na końcu listy argumentów

      Rest b przydaje się do obróbki tablicy np funkcją map
      zaś Spread tam gdzie wymagana jest lista, a nie tablica - np Math.max()

      Przykład object spreada w Reakcie - jest modyfikowanie propertki obiektu:

        function car(propertki) {
          const person = {
            ...propertki,
            price: 220
          }

          console.log(person)
        }

        car({ name: 'merc', price: 100 })

______________________________________________________________________________________________
91) ES6 - rest parameters

      CodeSchool - ES2015: 2.2 Rest, Spread and Arrow functions @ 5: 50

      Dają możliwość dodania dowolnej liczby parametrów do wołanej funkcji
      i dostępu do niej, jak do tablicy

      Różni się od obiektu arguments tym, że:
        a) jest prawdziwą tablicą, pozwalającą użyć push, pop, forEach, sort czy map
        b) jej parametry są nienazwane

      Jeśli 3 kropki są wśród argumentów funkcji - to jest to Rest:
          function  ( cos, ...params )  { }

      Jeśli 3 kropki są w ciele funkcji - to jest to Spread:
          function ( params )  { console.log( ...params ) }

      Parametry rest mogą być wołane z innymi, ale muszą być na końcu:
          function ( cos, ...params )   - ok
          function ( ...params, cos )   - źle

-----------------------------------------------------------------
        ES5:
          function bear() {
              console.log(arguments)   // { 0: 'polar', 1: 'uszatek' }

              for ( var i = 0; i < arguments.length; i++) {
                 console.log(arguments [ i ] )
              }
          }

          bear('polar', 'uszatek')  // polar, uszatek
-----------------------------------------------------------------
        ES6:
          function x (...args) {
              args.push(0)
              console.log(...args.sort())   // 0 1 2 3
              args.pop()
              console.log(args)                   //  [ 0, 1, 2 ]
              args.forEach(function(i) {
              console.log(i)                          // 0  1   2
            })
          }

          x ( 3, 1, 2 )
______________________________________________________________________________________________
92) ES6 - spread parameters

        https://leanpub.com/understandinges6/read#leanpub-auto-the-spread-operator

        Operator Spread '...' - przekształca tablicę w jej argumenty
        Przydaje się, gdy funkcja przyjmuje pojedyńcze argumenty,
        a mamy właśnie ich tablicę

        Jeśli trzykropki i nazwa są w ciele funkcji - to jest to Spread:
          function  ( params )  { console.log( ...params ) }

        Jeśli trzykropki i nazwa są wśród argumentów funkcji - to jest to Rest:
          function  ( cos, ...params )  { }

        i)  przykład z życia - uzupełnienie brakującego koloru:

              function colors(...colors) {
                if (colors.indexOf('black') < 0 ) return [...colors, 'black']
                return colors
              }

              console.log(colors('red', 'green', 'blue'))
              console.log(colors('red', 'green', 'blue', 'black'))


        a) Calling function without apply
            function doStuff ( x, y, z ) { ... }
            var args = [ 0, 1, 2 ]

            ES5:
              doStuff.apply( null, args )   // Call the function, passing args

            ES6:
              doStuff(...args)

        a) Math.max
            console.log ( Math.max ( 10, 15, 25 ) ) // 25 - funkcja Math.max elementy przyjmuje ..
            var arr = [ 10, 15, 25 ]
            console.log ( Math.max ( arr ) )      //  .. tablicy już nie  ( err )
            console.log ( Math.max ( ...arr ) )  //  .. ale spread działa  ( 25 )

            let values = [-25, -50, -75, -100 ]
            console.log( Math.max (...values, 0) )  // 0

        b) Arrays concatenation
            ES5: [ 1, 2 ].concat ( more )
            ES6: [ 1, 2, ...more ]

        c) Arrays copying
            var arr = [ 1, 2, 3 ]
            var arr2 = [ ...arr ]    // like arr.slice()
            arr2.push ( 4 )

            Remember !
              Objects within the array are still by reference, so not everything gets "copied", per se.

        d) Push to list
            ES5:  list.push.apply( list, [ 3, 4 ] )
            ES6:  list.push(...[ 3, 4 ] )

        e) Destructuring
            let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }
            console.log ( x ) // 1
            console.log ( y ) // 2
            console.log ( z ) // { a: 3, b: 4 }
______________________________________________________________________________________________
93) ES6 - set

      Struktura danych trzymająca tylko unikalne wartości

      let set = new Set()
      set.add('a')
      set.add('b')
      set.add('a')    // nie wywali błędu, ale go nie przyjmie

      console.log ( 'set.size = ',  set.size ) // 2

      set.forEach (function(item) {
        console.log (item)  //  a  b
      })

      let a = new Set([1, 2, 3])
      console.log(a.has(2))        // true
      a.delete(2)
      console.log(Array.from(a))  // array from set
     --------------------------------------------
      const set = new Set(arr)    // set from array

______________________________________________________________________________________________
94) ES6 - weakSet

     More memory efficient niż Set  ( garbage collection )
     Ponadto, przez metodę has, pozwala tworzyć grupy i sprawdzać je,  bez mutowania jej elementów
______________________________________________________________________________________________
95) ES6 - map

      CodeSchool - ES 2015: 4.2 Maps
      https://medium.com/ecmascript-2015/es6-set-map-weak-a2aeb7e2d384#.nxfalce39

      Mapy to pojemniki par klucz / wartość
      Klucz i wartość mogą być zarówno prymitywem jak i referencją obiektu

      Mapę trzeba wybrać,  gdy nieznana jest nazwa klucza, aż do runtime'u:
          createPost ( newPost,  function( data )  {
              posts.set ( data.author, data.message )
          }  )

      Mapę warto  ( choć musu nima ) wybrać, gdy wszystkie klucze i wszystkie wartości są tego samego typu  ( np string )

      Różnice między mapą a obiektem:

          a) mapa trzyma pary w kolejności ich dodania  ( w odróżnieniu od obiektu )

          b) kluczem obiektu może być string lub symbol, zaś kluczem mapy  - wszystko, w tym funkcje, obiekty i prymitywy

          c) iteracja: obiekt - for .. in,  mapy - for .. of

          d) obiekt ma  prototyp, więc ma domyślne klucze

          e) rozmiar mapy jest dostępny przez wbudowaną propertke size, a obiektu trzeba liczyć ręcznie

          f) mapa ma metody set i get

      let map = new Map (  [
           [ 1, 'raz' ],
           [ 2, 'dwa' ],
           [ 3, 'trzy' ],
      ]  )

      console.log( map.get ( 1 )  )    // raz
      map.set ( 4, 'cztery' )               // Map { 1 => 'raz', 2 => 'dwa', 3 => 'trzy', 4 => 'cztery' }
      console.log( map.get ( 4 )  )  //   cztery
      console.log( map )                //   Map { 1 => 'raz', 2 => 'dwa', 3 => 'trzy', 4 => 'cztery' }

      console.log ( map.size )    // 3

      for ( var [ key, value ] of map ) {
         console.log ( key, value )
      }

      for ( var key of map.keys (  )  )  {
          console.log( key )                       // 1  2  3
      }

      for ( var value of map.values (  )  )  {
          console.log( value )                    // raz dwa trzy
      }

      for ( var entry of map.entries (  )  )  {
          console.log( entry )           // [ 1, 'raz' ]  [ 2, 'dwa' ]   [ 3, 'trzy' ]
      }

      map.forEach ( function ( value, key )  {
          console.log( key, value )              // 1 'raz'    2 'dwa'     3 'trzy'
      } )

      map.set (  'czleniu', {  imie: 'jasiu', wiek: 23 } )
      console.log( map )

      console.log( map.get ( 'czleniu' ).imie )     // jasiu
      console.log( map.get ( 'czleniu' ).wiek )    // 23

      map.delete ( '1' )
      map.clear (  )

      Konwersja obiektu do mapy:

          const x = { imie: 'Ziutek', wiek: 22, miasto: 'Wwa' }
          Object.entries = obj => Object.keys ( obj ).map ( k => [ k, obj [ k ] ] )
          const map = new Map ( Object.entries( x ) )

          console.log( map )
          console.log( map.get( 'imie' ) )
______________________________________________________________________________________________
96) ES6 - weakMap

      CodeSchool - ES 2015: 4.2 Maps @ 6: 10

      Kluczem może być tylko obiekt prymitywy - nie
      Uzywa się metod get, set i has - jak w zwykłej Mapie
      WeakMap nie jest iterowalna

      Jej sens polega na oszczędności pamięci, nie blokuje garbage collectora,
      gdy w trakcie wykonywania kodu nie ma już dalej referencji do obiektu ( ów )  WeakMapy
      A Map - blokuje

          let user = {}
          let map = new WeakMap()
          map.set(user, 'user')
          console.log(map.get (user))
______________________________________________________________________________________________
97) ES6 - arrow functions

        ryanpcmcquen.org/JS/2016/05/15/arrow-functions-a-good-part.html
        CodeSchool - ES2015: 2.2 Rest, Spread and Arrow functions @ 5: 50

        Udemy: Stephen Grider - ES6 lesson 29, 30

        Arrow functions mają lexical scoping, tzn są związane (bind)
        z miejscem ich zdefiniowania, a nie użycia.

        Naprawia to częste kłopoty z użyciem 'this'

        Ponadto, ponieważ przy arrow functions nie ma etapu deklaracji i przypisania
        nie występuje hoisting z jego problemami.

        1-liniowe arrow functions, nie wymagają ujęcia ich w brejsy  {  }
        Zawierają też domyślny return:

            const add = ( a, b ) => a + b

        1-argumentowe arrow functions, nie wymagają ujęcia argumentu w nawias (  ):

            const addTwo = num => num + 2       // return jest domyślny  ( implicit / implied )
            console.log ( addTwo ( 4 )                    // 6


         Co ciekawe, po użyciu brejsów, nawet przy 1 linii w środku,  nie ma implicit returna
         i trzeba go jawnie umieścić:

            const addTwo = num =>  {
                return num + 2   // return NIE jest już domyślny  ( implied )
            }

         console.log(addTwo(4))

         a w przypadku > 1 instrukcji w ciele funkcji, użycie nawiasów klamrowych:

            const addTwo = num => {        // przy użyciu nawiasów klamrowych ..
              console.log('cokolwiek')  //  return nie jest domyślny
              return num + 2              //  i trzeba go podać jawnie
            }

         'const' na początku jest istotne, bo funkcje nie powinny być redefiniowane

        Fat-arrow naprawia też this (aka lexical scoping):

 -  -  -  -  -  -  -  Wersja ES5 z zepsutym this -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

        const team =  {
          members:  [ 'Jane', 'Bill' ] ,
          name: 'Zupa',
          summary: function() {
            return this.members.map ( function ( member ) {
                return `${member} is on team ${this.tname}`
            })
          }
        }

        console.log(team.summary())   // [ 'Jane is on team undefined', 'Bill is on team undefined' ]

        I trzeba było albo cache'ować this:

            summary: function() {
                let self = this
                return this.members.map ( function ( member ) {
                    return `${member} is on team ${self.name}`
                } )
            }

         ... albo dodawać .bind ( this )

            summary: function (  ) {
                return this.members.map ( function ( member ) {
                    return `${member} is on team ${this.name}`
                }.bind ( this )  )
            }

 -  -  -  -  -  -  -  Wersja ES6 z naprawonym this -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

        const team =  {
          members:  [ 'Jane', 'Bill' ] ,
          name: 'Zupa',
          teamSummary: function (  ) {
              return this.members.map ( member  => `${member} is on team ${this.name}`)
          }
        }

        console.log(  team.teamSummary (  ) )   // [ 'Jane is on team Zupa', 'Bill is on team Zupa' ]

______________________________________________________________________________________________
98) ES6 - arrow functions: fixy

    ---- 1) setTimeout w funkcji -----------------------------

        Przy klasycznej funkcji, this wewnątrz bloku setTimeout nie widzi this'a z powyżej
        Przy arrow-f - widzi

        function x() {
          this.val = 1
          // setTimeout(function() {    // 1
          setTimeout(() => {      // 2
            console.log(this.val)  // 1 - undefined, 2 - 1
            this.val++
            console.log(this.val)  // 1 - NaN, 2 - 2
          }, 1)
        }

        x()
        // lub: const obj = new x()

    ---- 2) tablica arguments -----------------------------

        Przy arrow functions nie działa, dlatego jest rest:

        const x = function() {
          console.log(arguments[0]) // 1
        }

        x(1, 2, 3)

      ---------------------

        const y = () => {
          console.log(arguments[0]) // {}
        }

        y(1, 2, 3)  // {}

      ---------------------

        const z = (...args) => {
          console.log(args[0]) // {}
        }

        z(1, 2, 3)  // 1


______________________________________________________________________________________________
99) ES6 - arrow functions (partial function, curry)

      Napisz funkcję 'mul', zwracającą wynik mnożenia przez siebie liczb x, y i z

      console.log(mul(2)(3)(4))

      ----- 1) wersja ES5 --------------------------

      function mul(x) {
        return function(y) {
          return function(z) {
            return x * y * z
          }
        }
      }

      ----- 2) wersja ES6 --------------------------

      const mul = x => {
        return y => {
          return z => {
            return x * y * z
          }
        }
      }

      ----- 3) wersja ES6 turbo --------------------

      const mul = x => y => z => x * y * z

______________________________________________________________________________________________
100) ES6 - modules

      CodeSchool - ES 2015: 5.2 Modules

      medium.com/dailyjs/es6-modules-node-js-and-the-michael-jackson-solution-828dc244b8b

      stackoverflow.com/questions/32746615/namespacing-with-iife-in-es6
      hacks.mozilla.org/2015/08/es6-in-depth-modules/

      UWAGA
          Więcej o modułach w pliku react.txt p.02c do 02g

      Wszystko zadeklarowane wewnątrz modułu jest domyślnie lokalne.
      Ale nie każdy plik jest modułem.

      Ten który nie jest, powinien nadal używać IIFE by nie polucić global scope'a
      Albo ująć kod w nawiasy  {  }
      Aby coś uczynić publicznym, trzeba to wyksportować, tzn opatrzyć słowem 'export'

      Może to być każda top-level funkcja, stała  ( const )  czy zmienna  ( var, let )
      Wtedy inny moduł może to zaimportować używając słowa 'import'
      Dzięki modułom, nie trzeba już używać IIFE, by uniknąć naming konfliktów

      Ponieważ przeglądarki nie obsługują modułów, niezbędny jest bundler, np webpack
      Dlatego więcej - patrz webpack.txt p.17

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
      export function detectCats ( canvas, options )  {
          var kittydar = new Kittydar ( options )
          return kittydar.detectCats ( canvas )
      }

      export class Kittydar {  ...   }

      function resizeCanvas ( ) {  ... }   //  Ta funkcja jest prywatna - niewidzialna na zewn
-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

      import { detectCats } from "kittydar.js"

      function go() {
        var canvas = document.getElementById ( "catpix" )
        var cats = detectCats ( canvas )
        drawRectangles ( canvas, cats )
      }

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

  To import multiple names from a module, you would write:
      import {detectCats, Kittydar} from "kittydar.js"

  When you run a module containing an import declaration, the modules it imports, are loaded first, then each module body is executed in a depth-first traversal of the dependency graph, avoiding cycles by skipping anything already executed.

  Export lists
      Rather than tagging each exported feature, you can write out a single list of all the names you want to export, wrapped in curly braces:

          export { detectCats, Kittydar }

      function detectCats(canvas, options) { ... }      // no `export` keyword required here
      class Kittydar { ... }

  Aliases (import and export 'as')
      // Both these modules export something named `flip`.
      // To import them both, we must rename at least one.

          import {flip as flipOmelet} from "eggs.js"
          import {flip as flipHouse} from "real-estate.js"

          export {
            v1 as streamV1,
            v2 as streamV2,
            v2 as streamLatestVersion
          }

    External libs
      ES6 code can import individual functions from Lodash:

          import {each, map} from "lodash"
          or  import _ from "lodash" - by używać funkcji z prefiksem '_'

          ww to to samo, co :
              import {default as _} from "lodash"

    Namespace import
      import * as cows from "cows"

      When you import *, what’s imported is a module namespace object.
      Its properties are the module’s exports.

      So if the “cows” module exports a function named moo(), then after importing “cows” this way, you can write: cows.moo().


______________________________________________________________________________________________
101) ES6 - modules: default export vs named export

        UWAGA !
          Więcej o modułach w pliku react.txt p.17
          Moduły zaczną chodzić w Nodzie w 2018
          Dlatego teraz, trzeba odpalać webpack -dev server i Chroma

        a) named
              export  const double =  num  =>  num * 2
               -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
              import  { double } from './flaszka'
              console.log ( double ( 3 ) )

        b) default
              Export default eksportuje bez nazwy, dzieki czemu importować można pod dowolną nazwą:

                  export default =  ( a, b )  => a - b

              albo:

                  const subtract =  ( a, b )  => a - b
                  export default subtract
               -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

              import subtract from './flaszka'

        c) named i default

              export  function shout ( message ) {
                  console.log ( message )
              }
               -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

              export  const double =  num  =>  num * 2

              const subtract =  ( a, b )  => a - b
              export default subtract
  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
              import subtract, { shout, double } from './flaszka'

              shout ( 'Siemanko5' )

              console.log ( double ( 3 ) )

              console.log ( subtract ( 6, 3 )  )

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

        d) * - Asterisk

            Import wszystkich named exportów do obiektu
            import * as flaszka from "./flaszka"

            Woła się ją przez flaszka.jakasMetoda ( ),
            ale nie działa jako  <Counter action =  { flaszka.jakasMetoda ( ) }

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

            Zamiast wstawiac 'export' przed kazda funkcją, można wbić na koncu pliku:
                export  { onInc,  onDec, Counter }
            Analogicznie:
                import { onInc,  onDec, Counter } from "./Counter"


---------------- Dupa.js -----------------------------

    import React from 'react'

    export class Dupa extends React.Component {
        render() {
            return (
                <div>
                    <h1> Dupax1 </h1>
                </div>
            )
        }
    }

    export function add ( a, b  )  {
         console.log( a+b )
    }

---------------- App.js -----------------------------

    import React from 'react'
    import ReactDOM from 'react-dom'
    import   { Dupa,  add } from './Dupa'

    add ( 6, 5  )

    class App extends React.Component {
        render() {
            return (
                <div>
                    <h1> Contacts List </h1>
                    <Dupa />
                </div>
            )
        }
    }

    ReactDOM.render(<App />, document.getElementById('app'))

______________________________________________________________________________________________
104) ES6 - arrays  (of, find, findIndex, fill, copyWithin )

     a) Array.of
          Tworzy tablicę, z podanych jej parametrów:
            var z = Array.of (1, 'a', 2, 'b')
            console.log(z)    // [ 1, 'a', 2, 'b' ]

     b) find i findIndex
          let numbers = [ 25, 30, 35, 40, 45 ]

          console.log(numbers.find(n => n > 33))         // 35  1-sza wartość będąca true
          console.log(numbers.findIndex(n => n > 33))    // 2   pozycja wystapienia

     c) fill(value, [start, end])
          let numbers = [ 1, 2, 3, 4, 5 ]
          numbers.fill(1)        // 1, 1, 1, 1, 1
          numbers.fill('x', 3, 5) // [ 1, 2, 1, 'x', 'x' ]

     d) copyWithin
          let numbers = [ 1, 2, 3, 4 ]
          numbers.copyWithin(2, 0)     // [ 1, 2, 1, 2 ]

          // Poczynając od indexu = 2 (cyfra 3)
          // wklej wartości począwszy od indeksu = 0
          // Wklej, a nie nadpisuj !
______________________________________________________________________________________________
105) ES6 - array workarounds (union, intersection, difference )

    a) union

        let a = [1, 2, 3]
        let b = [4, 3, 2]
        let union = new Set([ ...a, ...b ])

        console.log(union)         //  1, 2, 3, 4

    b) intersection

        const arr1 = [1, 2, 3]
        const arr2 = [2, 3, 4]

        const arr3 = arr1.filter(el => arr2.includes(el))

    c) difference

        const arr1 = [1, 2, 3]
        const arr2 = [2, 3, 4]

        const arr3 = arr1.filter(el => !arr2.includes(el))
______________________________________________________________________________________________
106) ES6 - computed object  ( ręczne tworzenie obiektu )

    a) computed key and value

        var a = 'miasto'
        var b = 'Warszawa'

        var x =  { [ a ]: b }  // { miasto: 'Warszawa', kraj: 'Polska' }

   -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

        let a =  [ 'imie', 'wiek', 'miasto' ]
        let b =  [ 'Wacek', 22, 'Wwa' ]
        let c =  {  }

        a.map(function(item, id) {
          Object.assign (c,{[ item ]: b [ id ]})
        })

        console.log( c )   // { imie: 'Wacek', wiek: 22, miasto: 'Wwa' }

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    b) computed value only

          var id = 1
          var name = 'Jan'

          var x = {['id']: id, ['name']: name}

          console.log( x )   // { id: 1, name: 'Jan' }

______________________________________________________________________________________________
107) ES6 - object assign  ( patrz 122 OOP - object.assign)

        Pusty : )

______________________________________________________________________________________________
108) ES6 - promises: teoria

      https://youtu.be/104J7_HyaG4       How to use JS Promises
      www.2ality.com/2014/10/es6-promises-api.html

      Obiekt deferred ma 3 propertki:
        a) obiekt promise
        b) propertke resolved
        c) propertke reject

      Obiekt promise ma:
        2 property:
          a) state
               i) pending
              ii) resolved
             iii) rejected

          b) value
               W chwili początkowej:  status = 'pending',  value = 'undefined'
               W chwili końcowej:     status = 'resolved', value = to co przyszło
               W chwili końcowej:     status = 'rejected', value = error jakiś

      i 2 metody:
          a) then   ( jeśli status był resolved )
          b) catch  ( jeśli status był rejected )

      W chwili gdy defer otrzyma odpowiedź ( z db, neta, filesystemu )  = np 17
          a) propertka defer.resolve  = 17
          b) promise.status = 'resolved'
          c) promise.value = 17
          d) odpalona zostanie metoda promise.then (  )  i przekazana jej 17-tka
          e) odetnie połączenie do metody catch (  )

      Analogicznie, jeśli defer otrzyma błąd  ( dowolna wartość, ale typowo JS error )
          a) propertka defer.reject  = error
          b) promise.status = 'rejected'
          c) promise.value = error
          d) odpalona zostanie metoda promise.catch (  )  i przekazany jej error
          e) odetnie połączenie do metody then (  )

      Do obiektu promise, możesz się odwołać przez deferred.promise, lub bezpośrednio  ( promise )

      console.log ( JSON.stringify ( deferred ) )   //  {"promise": { } }

      const promise = deferred.promise   // obiekt deferred ma property promise

      console.log ( JSON.stringify ( promise ) )   //  { }

______________________________________________________________________________________________
109) ES6 - promises: then, catch  ( promise example )

       youtube.com/watch?v=s6SH72uAn3Q - JS promises explained tutorial
       CodeSchool:  ES2015 -  6.1 Promises
       Udemy - S.Grider: ES6

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    let promise = new Promise((resolve, reject) => {
      setTimeout(() => {
       resolve()
       // reject()
      }, 1000)
    })

    promise
      .then(() => console.log('then 1'))
      .then(() => console.log('then 2'))
      .catch(() => console.log('catch'))
      .finally(() => console.log('finally'))

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    let x = new Promise (function (resolve, reject) {
        reject ()
    })
    .then ( function ( res ) {
        console.log ( 'OK' )
        //console.log( JSON.parse ( res.body).address )
    })
    .catch ( function ( err ) {
       console.log(  'ERR: ' )
    })


Można też użyć dłuższej formy ( bez chainowania ) :

x.then ( function ( res ) {
    console.log( res )
})

x.catch ( function ( err ) {
    console.log( err )
} )

______________________________________________________________________________________________
110) ES6 - promises: fetch example

      Przykład ze ściąganiem danych z urla spod Sublime'a, a więc nodem
      Dlatego potrzebny jest import pakietu 'fetch',
      który jest czymś innym niż metoda 'fetch' WebAPI

      Jeśli chcesz użyć then i catch bez chainingu,
      musisz wcześniej promisa przypisać do zmiennej
      I dopiero na niej wykonać then i catch  ( patrz poniżej )

      Zwróć uwagę, że w kontekście fetch'a błędem będzie tylko
      brak odpowiedzi serwera (czyli najczęsciej zły adres http)

      UWAGA !
        Jeśli serwer zwróci kod błędu  ( 404 czy 500 ),
        fetch weźmie to za poprawną odpowiedź i wykona then a nie catch

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

const fetchUrl = require ('fetch').fetchUrl

let x = new Promise ( function ( resolve, reject ) {

    fetchUrl("httpstat.us/404", function ( error, meta, body ) {  // zmień adres na foo by zwrócił błąd w catch'u
      if (error) reject ('dupsko')
      else {
        console.log( body.toString())
        resolve ('git')
      }
    })

})

x.then ( function ( res ) {
  console.log( res )
})

x.catch ( function (err) {
  console.log ('Erroras !')
  console.log (err)
})

______________________________________________________________________________________________
111) ES6 - promises: interview example

      https://blog.risingstack.com/node-js-interview-questions-and-answers-2017/

      Promise.resolve(1)   //  A new Promise is created, that will resolve to 1.
        .then((x) => x + 1)  // Resolved value is incremented with 1 and returned instantly

        .then((x) => { throw new Error('My Error') })  // Resolved value is discarded, and error is thrown

        .catch(() => 1)  //  Error is discarded, and a new value (1) is returned

        .then((x) => x + 1)  //  Execution did not stop after the catch, but before the exception was handled, it continued, and a new, incremented value (2) is returned.

        .then((x) => console.log(x))  // Value is printed

        .catch(console.error)   // This line won't run, as there was no exception.

______________________________________________________________________________________________
112) ES6 - promises: chaining

        youtube.com/watch?v=s6SH72uAn3Q

        let cleanRoom = function  ( ) {
          return new Promise ( function ( resolve, reject ) {
            resolve ( 'Cleaned the room\n' )
          })
        }

        let removeGarbage = function  ( message ) {
          return new Promise ( function ( resolve, reject ) {
            resolve ( message + 'Removed garbage\n' )
          })
        }

        let winIceCream = function  ( message ) {
          return new Promise ( function ( resolve, reject ) {
            resolve ( message + 'Won icecream\n' )
          })
        }

        cleanRoom ()
          .then ( function ( result ) {
              return removeGarbage ( result )
          } )
          .then ( function ( result ) {
              return winIceCream ( result )
          } )
          .then ( function ( result ) {
              console.log( 'Finished !\n' + result )  // Finished !
                                                                          // Cleaned the room
                                                                          // Removed garbage
                                                                          //  Won icecream
          } )

______________________________________________________________________________________________
113) ES6 - promises: all

    youtube.com/watch?v=s6SH72uAn3Q
    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all

    Jeśli chcemy poczekać aż wszystkie promisy się skończą, użyjemy:
        Promise.all ([ promise1 (), promise2 (), ... ])

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    var p1 = Promise.resolve(3)
    var p2 = 1337
    var p3 = new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve("foo")
      }, 100)
    })

    Promise.all([p1, p2, p3]).then(values => {
      console.log(values) // [3, 1337, "foo"]
    })

----------------------------------------------------------------------------------------------------------

  Zwracana jest zawsze tablica [ 'p1', 'p2', 'p3' ] mimo, że biorąc pod uwagę wielkości timeoutów
  kolejnośc powinna być odwrotna. Wniosek: runtime odpala promisy równolegle i czeka na ukończenie
  ich wszystkich, po czym zwraca je w przekazanej mu na początku kolejności.

  Jeśli któryś z promisów się wywali (np reject('p3')), tylko on zostanie wypisany,
  a potem wykonanie promise.all się zakończy


  const p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('p1')
    }, 5000)
  })

  const p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('p2')
    }, 3000)
  })

  const p3 = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('p3')
    }, 1000)
  })

  Promise.all([p1, p2, p3])
    .then(res => console.log(res))
    .catch(err => console.log(err))



 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
  const axios = require('axios')

  async function get() {
    const p1 = await axios.get('https://jsonplaceholder.typicode.com/users/1')
    const p2 = await axios.get('https://jsonplaceholder.typicode.com/users/2')
    const p3 = await axios.get('https://jsonplaceholder.typicode.com/users/3')

    Promise.all([p1, p2, p3])
      .then(res => console.log(res[0].data.id, res[1].data.id, res[2].data.id,))
      .catch(err => console.log(err))
  }

  get()

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

  const axios = require('axios')

  async function get(user) {
    const url = 'https://jsonplaceholder.typicode.com/users/' + user
    return await axios.get(url)
  }

  function go() {
    const p1 = get(1)
    const p2 = get(2)
    const p3 = get(3)

    Promise.all([p1, p2, p3])
      .then(res => console.log(res.map(el => console.log(el.data.id))))
      .catch(err => console.log(err))
  }

  go()

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

  const axios = require('axios')

  function get(user) {
    const url = 'https://jsonplaceholder.typicode.com/users/' + user
    return axios.get(url)
  }

  async function go() {
    const p1 = await get(1)
    const p2 = await get(2)
    const p3 = await get(3)

    Promise.all([p1, p2, p3])
      .then(res => res.map(el => console.log(el.data.id)))
      .catch(err => console.log(err))
  }

  go()
 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

  const axios = require('axios')

  function get(user) {
    const url = 'https://jsonplaceholder.typicode.com/users/' + user
    return axios.get(url)
  }

  async function go() {
    const arr = []
    arr.push(await get(1))
    arr.push(await get(2))
    arr.push(await get(3))

    Promise.all(arr)
      .then(res => {
        const arr = res.map(el => el.data.name)
        processing(arr)
      })
      .catch(err => console.log(err))
  }

  function processing(arr) {
    console.log(arr)
  }

  go()


______________________________________________________________________________________________
114) ES6 - promises: race

      Jeśli chcemy poczekać tylko do chwili, aż 1-szy z promisów się skończy

      Np gdy dla redundancy, wysyłamy kilka takich samych requestów, do różnych serwerów:
        Promise.race ( [ promise1 (), promise2 (), ... ])

      let cleanRoom = function  ( ) {
        return new Promise ( function ( resolve, reject ) {
          resolve ( 'Cleaned the room\n' )
        })
      }

      let removeGarbage = function  ( message ) {
        return new Promise ( function ( resolve, reject ) {
          resolve ( message + 'Removed garbage\n' )
        })
      }

      let winIceCream = function(message) {
        return new Promise(function(resolve, reject) {
          resolve ( message + 'Won icecream\n' )
        })
      }

      Promise.race ([ cleanRoom (), removeGarbage (), winIceCream ()])
        .then ( function ( msg ) {
          console.log( 'race won: '  + msg )   // race won: Cleaned the room
        })

______________________________________________________________________________________________
115) ES6 - promises: reject  ( kasowanie trwającego promisa )

        https://youtu.be/104J7_HyaG4?t=925       How to use JS Promises

        By skasować trwającego ( pending ), a zbędnego już promisa,
        trzeba przypisać go z metodą defer() do zmiennej
        i wykonać na niej metodę reject (  ):

        const promis = Promise.defer ()
        promis.reject ( 'Manually rejected' )

______________________________________________________________________________________________
116) ES6 - for of

      Iteracja przez tablicę.
      Zwięźlej niż tradycyjna pętla for
      Lepsza od pętli .map, bo można z niej wyjść przed dojściem do końca tablicy

      let arr = [ 1, 2, 3, 4 ]

      for (let item of arr ) {
        console.log ( 'item = ',  item )
        if ( item === 3 )
          break
      }
______________________________________________________________________________________________
117) ES5 - for in

      Iteracja przez klucze obiektu
      Jak Object.keys ( obiekt ).forEach  -  tylko zwięźlej

      const list = [ 4, 5, 6 ]

      let ziutek =  {
        name: 'ziutek',
        age: 12
      }

      for (let i in ziutek) {
        console.log(i, user[i])
      }
______________________________________________________________________________________________
118) ES7 - **  ( potęgowanie )

      console.log( 2**4 )   // 16
______________________________________________________________________________________________
119) ES7 - includes (string i array)

      'michał'.includes('mi')    // true
      'michał'.includes('mc')    // false

      ["Banana", "Orange", "Apple", "Mango"].includes("Mango")  // true
______________________________________________________________________________________________
120) ES8 - string methods  ( padStart, startsWith, endsWith )

      hackernoon.com/es8-was-released-and-here-are-its-main-new-features-ee9c394adf66

        a) padStart

            Dodaje z przodu stringa tyle znaków, by miał on zadaną długość.

            Domyślnym padakiem jest spacja

            console.log('abc'.padStart(6))            // "    abc"
            console.log('abc'.padStart(5, 'X'))      // "XXabc"
            console.log('abc'.padStart(6,'123465') ) // "123abc"
            console.log('abc'.padStart(8, '0'))      // "00000abc"
            console.log('abc'.padStart(1))           // "abc"

         b) startsWith
              console.log('abc123'.startsWith('ab'))    // true

         c) endsWith
              console.log('abc123'.endsWith('123'))    // true

______________________________________________________________________________________________
121) ES8 - Object.values

      let ziutek =  {
        name: 'ziutek',
        age: 12,
        sayName() {
          return this.name
        }
      }

      console.log(Object.values(ziutek))   // [ 'ziutek', 12, [Function: sayName] ]

      // when we use numeric keys, the values returned in a numerical
      // order according to the keys

      const obj = { 10: 'xxx', 1: 'yyy', 3: 'zzz' }
      console.log(Object.values(obj))  // ['yyy', 'zzz', 'xxx']

      Object.values('es8') //  ['e', 's', '8']
______________________________________________________________________________________________
122) ES8 - Object.entries

      let ziutek =  {
        name: 'ziutek',
        age: 12,
        sayName (  )  {
          return this.name
        }
      }

      console.log(Object.entries (ziutek))   // [ [ 'name', 'ziutek' ],  [ 'age', 12 ],  [ 'sayName', [Function: sayName] ] ]

      Object.entries('es8')  //  [[ '0', 'e' ], [ '1', 's' ], [ '2', '8' ]]
______________________________________________________________________________________________
123) ES8 - Object.getOwnPropertyDescriptors

      Zwraca własne  ( czyli nie odziedziczone z prototypu ) deskryptory właściwości obiektu

      let ziutek =  {
          name: 'ziutek',
          age: 12,
          sayName()  {
            return this.name
          }
      }

      console.log ( Object.getOwnPropertyDescriptors ( ziutek ))

      { name:
          { value: 'ziutek',
            writable: true,
            enumerable: true,
            configurable: true },

        age:
          { value: 12,
            writable: true,
            enumerable: true,
            configurable: true },

        sayName:
          { value: [Function: sayName],
            writable: true,
            enumerable: true,
            configurable: true }}

______________________________________________________________________________________________
124) ES8 - Trailing commas w parametrach i wywołaniach funkcji

        function es8 ( arg1, arg2, ) {   // tu
            console.log ( arg1 )
            console.log ( arg2 )
        }

        es8 ( 'dupa', 'kwas',  )   // i tu1

        When you want to add a value to an array, the adding of comma is create diff between the code versions in the versions control.
        For example:

        const arr = [
          thisIsTheFirstValue
        ]

        After commit:

        const arr = [
          thisIsTheFirstValue,       // ta linia będzie podświetlona choć zmieniło ją tylko dodanie myślnika
          thisIsTheSecondValue
        ]
______________________________________________________________________________________________
125) ES6 - promises

      Wywołanie funkcji asynchronicznej nie blokuje flow programu

      Jeśli masz długo trwające zadanie np pętla licząca do miliarda,
      wyrzuć ją z głównego wątku do api przeglądarki przez:

        a) Promise.resolve.then  lub
        b) setTimeout(() {}, 0)

   ------ 1. Zwykłe wykonanie pętli -------------------------

      console.log('1')

      let i = 0
      while(i < 1000000000) { i++ }
      console.log('Billion loops done')

      console.log('2')

   ------ 2. Wyrzucenie długiego taska jako asynchronicznego do Promise'a -----

      console.log('1')

      Promise.resolve().then(() => {
        let i = 0
        while(i < 1000000000) { i++ }
        console.log('Billion loops done')
      })

      console.log('2')

   ------ 3. Wyrzucenie długiego taska do asynca przez setTimeout -----

    console.log('1')

    setTimeout(() => {
      let i = 0
      while(i < 1000000000) { i++ }
      console.log('Billion loops done')
    }, 0)

    console.log('2')

   ------ 4. Promise ma wyższy priorytet niż setTimeout -----

    console.log('1')

    setTimeout(() => {
      let i = 1
      while (i < 1000000000) {
        i++
      }
      console.log('setTimeout')
    })

    Promise.resolve().then(() => {
      let i = 1
      while (i < 1000000000) {
        i++
      }
      console.log('Promise.resolv')
    })

    console.log('2')

______________________________________________________________________________________________
126) ES8 - async / await

      Tuba: The Async Await Episode I Promised (fireship)

      W przypadku promisa, komendy wykonywane są asynchronicznie, tzn przy napotkaniu długo
      wykonującej się komendy, opakowujemy ją w promisa, który nie zatrzymuje wykonywania reszty kodu
      Nie ma przy tym pewności w jakiej kolejności promisy zwrócą wynik ('1' -> '2', czy '2' > '1' )

      W przypadku async/awaita, komendy wykonywane są synchronicznie,
      więc wykonanie kodu zatrzymywane jest do czasu wykonania każdej z komend
      Jest więc pewność kolejności wyników promisów

    --------- Promise -------------------------------------------------

      const axios = require('axios')

      const promise = () => {
        console.log('A')

        axios.get('https://jsonplaceholder.typicode.com/posts/1')
          .then(res => console.log(res.data.id))
          .catch(err => console.log(err))

        axios.get('https://jsonplaceholder.typicode.com/posts/2')
          .then(res => console.log(res.data.id))
          .catch(err => console.log(err))

        console.log('B')
      }

      promise()  // A  B  1  2

    ------- Async / Await - serial ---------------------------------------------------

      const axios = require('axios')

      const promise = async () => {
        console.log('A')

        const post1 = await axios.get('https://jsonplaceholder.typicode.com/posts/1')
        console.log(post1.data.id)

        const post2 = await axios.get('https://jsonplaceholder.typicode.com/posts/2')
        console.log(post2.data.id)

        console.log('B')
      }

      promise()  // A  1  2  B

    ------- Async / Await - zrównoleglenie ---------------------------------------------------

      const axios = require('axios')

      const promise = async () => {
        const promise1 = axios.get('https://jsonplaceholder.typicode.com/posts/1')
        const promise2 = axios.get('https://jsonplaceholder.typicode.com/posts/2')
        return await Promise.all([promise1, promise2])
      }

      promise().then(res => res.map(el => console.log(el.data.id)))

______________________________________________________________________________________________
127) ES8 - async / await - try/catch

    Tuba: The Async Await Episode I Promised (fireship)

    async/await nie ma wbudowanej obsługi błędów (jak promise ma catcha)
    Dlatego trzeba używać try / catcha

    ----------------------------------------------------------
    const axios = require('axios')

    const promise = async () => {
      try {
        const promise1 = axios.get('https://jsonplaceholder.typicode.com/posts/1')
        const promise2 = axios.get('https://jsonplaceholder.typicode.com/posts/2')
        throw 'broken !'
        return await Promise.all([promise1, promise2])
      }
      catch(err) {
        console.log('Erroras: ', err)
      }
    }

    promise().then(res => res.map(el => console.log(el.data.id)))


______________________________________________________________________________________________
128) ES8 - async / await - for

    Żeby synchronicznie iterować używając async/awaita, trzeba użyć 'for ..of',
    Użycie .map spowoduje odpalenie wszystkich promisów równolegle

  ------- .map ------------------------------------------------------

      const axios = require('axios')
      const arr = [1, 2, 3]

      async function user(el) {
        return await axios.get('http://jsonplaceholder.typicode.com/users/' + el)
      }

      arr.map(el => user(el).then(res => console.log(res.data.id)))  // 231;  213;  312 ...

  ------- .for .. of ------------------------------------------------------

    const axios = require('axios')
    const arr = [1, 2, 3]

    async function user(el) {
      return await axios.get('http://jsonplaceholder.typicode.com/users/' + el)
    }

    for (el of arr) {
      user(el).then(res => console.log(res.data.id))  // 1  2  3
    }
______________________________________________________________________________________________
129) ES Next - object spread

        let ziutek = {
          name: 'ziutek',
          age: 12,
        }

        console.log({
          city: 'Warsaw',
          ...ziutek,
          price: 2000
        })

        //  { age: 12,  city: 'Warsaw',  name: 'ziutek', price: 2000 }

______________________________________________________________________________________________
130) Functions - intro

        Każda funkcja jest metodą obiektu.

        Jeśli nie jawnie zadeklarowana lub przekazana do obiektu, to domyślnie jako funkcja:
           obiektu window - jeśli wykonywana jest w przeglądarce, lub
           obiektu global - jeśli poza nią (node)

        DRY - Dont Repeat Yourself
        DOT - Do One Thing
        KISS - Keep It Simple
        LIM  - Less Is More (less code = more readability, hence efficiency )
        YAGNI - You Aint Gonna Nee It (nie pisz na zapas, bo tego nie użyjesz)
        SOLID - Single Responsibility Principle
                Open (for extending) / Close (for modifications)
                Liskov ?

        Jeśli funkcja wołana jest ze zbyt dużą ilościa argumetów, nadmiarowe są ignorowane,
        ale zapisywane są w tablicy arguments [ ]

        Jeśli za mała jest ilośc argumentów, pozostałe uzupełniane są jako = undefined
        Dzieki ww nie wywalany jest błąd

        Typy argumentów nie są sprawdzane przez kompilatór
______________________________________________________________________________________________
131) Function - declaration i expression

        function foo() {}        - declaration
        var foo = function() {}  - expression
______________________________________________________________________________________________
132) Function - Hoisting: variables

        Poniżej występuje ta sama zmienna score w 2 scope'ach:
        zewn (globalnym) i wewn (lokalnym, wewn funkcji)

        Zasada hoistingu jest taka, że jeśli zmienna jest od razu przypisana
        (a nie najpierw zadeklarowana) gdzieś wewnątrz funkcji,
        kompilator sam deklaruje ją na początku funkcji, a przypisanie pozostawia tam gdzie jest,

        W poniższym przykładzie, var score = 100, rozbije na 2 części:
        var score  i score = 100  var score przeniesie na samą górę funkcji (do linii tuż pod słowo function),
        a przypisanie (score = 100) zostawi tam, gdzie jest

        var score = 1000

        function play() {
            //  Tu kompilator wstawi var score (hoisting)

            console.log( 'begin: ' + score )

            if ( !score ) {
                console.log( 'setting default' )
                var score = 100
            }

            console.log( 'end: ' + score )
        }

        console.log( score ) // 1000
        play()  // begin: undefined   setting default:  end: 100
        console.log( score ) // 1000
______________________________________________________________________________________________
133) Function - Hoisting: functions

        Analogicznie jak w ww przypadku zmiennych, function expression - rozbijana jest na 2 kawałki: declaration i assignment:
                declaration hojstowana jest na samą górę scope'a
                a assignement - pozostaje tam gdzie jest

        Function statement przenoszona jest w całości na górę scope'a

         //  function sayGoodbye() { console.log( 'Goodbye' ) }   # hoisting
         //  var sayHello     # hoisting

        sayGoodbye()    // Goodbye
        sayHello()         //  sayHello is not a function

        function sayGoodbye() { console.log( 'Goodbye' ) }
        var sayHello = function() {  console.log( 'Hello' ) }

        //  sayHello = function() {  console.log( 'Hello' ) }   # hoisting

______________________________________________________________________________________________
134) Function - IIFE: immediately invoked function expression

        aka self-invoked function expression

        https://addyosmani.com/blog/essential-js-namespacing/

        Jej kod wykonywany jest tylko raz  ( przykład singletona )

        ( function ( ) {
              ...
        } ) ( )

        UWAGA !
            Jeśli nie używamy w kodzie przecinków, trzeba go postawić na początku IIFE !
            Jeśli nie - wywali TypeErrora

        Często wykorzystywany  ( m.in. w angularze 1 ) do tworzenia namespace'u
        ( unikania globali by nie doszło do kolizji nazw zmiennych ):

        Tworzy się go w 2 krokach:
            1) robiąc iffe
            2) zwracając w nim obiekt składający sie z metod i zmiennych - te będą publiczne reszta - prywatne

             let x = ( function x ( ) {               // 1) iffiak

                let a = 5
                let b = 'dupa'

                return  {                                 // 2) zwrócenie obiektu złożonego z metod i zmiennych
                    sayHi: function ( ) {
                        return 'Hi'
                    },
                    sayBye: function ( ) {
                        return 'Bye'
                    },
                    c: 5,
                    d: 'dupa'
                }
            } )  (  )

            console.log( x.a )                  // undefined
            console.log( x.b )                  // undefined
            console.log( x.sayHi (  )  )     //  Hi
            console.log( x.sayBye (  )  )   //  Bye
            console.log( x.c )                  //   5
            console.log( x.d )                 /     dupa

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
        Trafia się też ociupinę inna składnia:

            var kupa = kupa || { }       // musi być var ! let ani const nie dają rady

            ( function( o ) {

                o.foo = "foo"

                o.bar = function ( ) {
                    return "bar"
                }

            } ) ( kupa )                 // kupa - parametr podawany ww funkcji

            console.log ( kupa )             // { foo: 'foo', bar: [Function] }
            console.log( kupa.foo )        // foo
            console.log( kupa.bar (  )  )  // bar

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
            Przykład enkapsulacji dzięki IIFE

            var counter = ( function ( ) {
               var privateCounter = 0

              function changeBy ( val ) {
                 privateCounter += val
              }

              return {
                increment: function() {
                   changeBy ( 1 )
                },

                decrement: function() {
                   changeBy ( -1 )
                },

                value: function ( ) {
                   return privateCounter
                }
              }
            } ) ( )

            console.log ( counter.value ( ) )   // logs 0
            counter.increment ( )
            counter.increment ( )
            console.log ( counter.value ( ) )   // logs 2
            counter.decrement ( )
            console.log ( counter.value ( ) )  // logs 1
______________________________________________________________________________________________
135)  Function - IIFE: Revealing module pattern 1

---------  Najpierw wersja object literal - wszystkie metody są publiczne -------------------

        var person = {
            chew: function() { console.log( 'chew' ) },
            swallow: function() { console.log( 'swallow' ) },
            eat: function() {
                for (var i = 0 i < 3 i++) { this.chew() }
                this.swallow()
            }
        }

        person.chew()       // chew
        person.swallow()  //  swallow
        person.eat()         //  chew chew swallow

---------   Wersja Revealing Module pattern - publiczne są tylko te zwracane return'em -----------------------------

        var person = (function() {
            var chew = function(i) { console.log( 'chew '+ i ) }
            var swallow = function() { console.log( 'swallow' ) }
            var eat = function() {
                for (var i = 0 i < 3 i++) {
                    chew(i)
                }
                swallow()
            }

            return { eat: eat }    // eat jest public chew i swallow - private
        })()

        person.eat()            // chew 0  chew 1  chew 2   swallow
        person.chew()        // undefined
        person.swallow()   // undefined
______________________________________________________________________________________________
136)  Function - IIFE: Revealing module pattern 2

            W object literal, wszystkie metody są publiczne, bo ten format nie pozwala na zwracanie czegoś wybranego ( brak return'a )
            Z definicji, zwracane  ( dostępne na zewnątrz ) jest wszystko

            Za to funkcja daje taką możliwość.
            Dlatego Revealing module opiera się na funkcji  ( na marginesie, funkcja w JS jest obiektem )

---------  Najpierw wersja object literal - wszystkie metody są publiczne -------------------

      var store = {
        prices:  {
            apple: 1.25,
            banana: 0.75,
            orange: 1.0
        },

        getPrice:  function(item, qty) {
            return store.prices[ item ] * qty
        }
      }

      console.log( store.getPrice('apple', 2) )

---------   Wersja Revealing Module pattern - publiczne są tylko te zwracane return'em -----------------------------

            var store - tworzy namespace'a pozwalającego wołać metody zamknięte
            w nowoutworzonym przez function() scopie

            https://toddmotto.com/mastering-the-module-pattern/

            var store = ( function ( ) {

                var prices = {
                    apple: 1.25,
                    banana: 0.75,
                    orange: 1.0
                }

                var getPrice = function ( item, qty )  {
                    return prices [ item ] * qty
                }

                return { getPrice: getPrice }

            } ) ( )

            console.log( store.getPrice('apple', 2) )   // 2.5
______________________________________________________________________________________________
137) Function - passing arguments (zwykłe, call i bind )

      Call i apply służą przekazaniu obiektu do: funkcji albo metody obiektu

      Bind służy przekazaniu obiektu do metody obiektu

----a) przekazanie parametru do funkcji ------------------------------------------------------------

      function person(name) {
        console.log('Hello ' + name)
      }

      person('Krzysiu')   // Hello Krzysiu

----b) call - przekazanie obiektu do funkcji ------------------------------------------------------------

      function person() {
        console.log('Hello ' + this.name)
      }

      person.call({ name: 'Krzysiu'})   // Hello Krzysiu

----c) bind - przekazanie obiektu do metody innego obiektu  --------------------------------------------------------------

      var osoba =  {
        imie: 'Ola',
        pozdrow: function() {
          console.log( 'Hello ' + this.imie )
        }
      }

      let krzysiu = osoba.pozdrow.bind ( { imie: 'Krzysiu' } )

      osoba.pozdrow()  // Hello Ola
      krzysiu()       //  Hello Krzysiu
______________________________________________________________________________________________
138) Function - overloading

      W JS nie ma function overloading (funkcja o tej samej nazwie, różniąca sie tylko ilością parametrów)

        function text() { console.log( '1' ) }
        function text(kupa) { console.log( '2' ) }    // ostatnia z funkcji o tej samej nazwie wygrywa.
                                                                          //  Nie mają znaczenia parametry nawiasie
        text()        // 2
        text('syf')  // 2

      Ale, jeśli bardzo się chce, to można function overloading zaprogramować:

        function text() {

          if (arguments.length === 0)
            console.log('0')
          else if (arguments.length === 1)
            console.log('1')
          else if (arguments.length === 2)
            console.log('2')
        }

        text()        // 0
        text('syf')  // 1
        text('kupa', 'siku')  // 2

______________________________________________________________________________________________
139) Event Loop  ( setTimeout )
            Tidwell video @ 34:30

        for ( var i = 0; i < 5; i++) {
          setTimeout ( function ( ) {
            console.log ( i ) }, 1 )   // 5  5  5  5  5
        }

        Dzieje się tak, bo setTimeout działa asynchronicznie, tzn odkłada na stos funkcję  console.log(msgs[ i ])
        i czeka na upływ czasu (tu 1 ms). Gdy ta upłynie, bierze obecną wartośc indeksu i,
        i znajduje odpowiadający jej element.

        Problem w tym, że w międzyczasie, licznik pętli for się obraca.
        I nawet tylko po 1ms, przyjmuje wartośc koncową, czyli i = 1.

        A msgs [ 1 ] = 'wafle'.
        Stąd 5-krotne wywołanie pętli przy liczniku który za każdym razem = 1, daje: 5  5  5  5  5

        Rozw:

        for ( var i = 0; i < 5; i++) {
             ( function ( x ) {
                setTimeout ( function ( ) { console.log ( x ) }, i * 1000 )
            } ) ( i )
        }

        Teraz licznik pętli for nie będzie przekręcony, póki funkcja nie zwróci wyniku.

        W efekcie: 0  1  2  3  4
______________________________________________________________________________________________
140) Closures

      JS closures - programming with Anthony
          youtube.com/watch?v=R_ZvxMyFSCU

      Tuba - FunFunFunctions: 5. Closures
      developer.mozilla.org/en/docs/Web/JS/Closures

      Aby omówić closures, trzeba zacząć od zakresu zmiennych w JS  ( variable scopes )
      Zakres zmiennej określony jest jej położeniem w kodzie

      Closure to funkcja wewnętrzna, która ma dostęp do zmiennych i _argumentów_ funkcji zewnetrznych
      (tylu w góre ile ich tylko jest)

      Wszystkie funkcje są closures, bo wszystkie  (nawet najwyżej położona z nich)
      są zagnieżdżone w global scopie

      Closure - to kombinacja argumentów funkcji i zmiennych, dostępnych w chwili jej tworzenia

      Gdy kompilatór nie widzi definicji zmiennej (brak var, let czy const),
      szuka jej w scopie wyżej i wyżej aż znajdzie

      Jeśli znajdzie na jakimś poziomie, to nie szuka już dalej.
      Jeśli nie znajdzie, to ją tworzy jako zmienną globalną

      Więc jeśli zmienna jest na poziomie 4 (czyli głębszym) i 3-cim, jej wartość będzie wzięta
      z poziomu 4, nawet jeśli na wartość na poziomie 3 jest inna

      Przykładem closure jest również IIFE która daje enkapsulację (patrz p.102)
      czyli pozwala uczynić dostępnymi na zewnątrz tylko te funkcje (metody), które chcemy

      Funkcje zagnieżdżone powinny być używane tylko tam gdzie muszą,
      bo mają negatywny wpływ na performance (cpu i ram) - patrz ostatni przykład w tym punkcie

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
        let x = 1
        console.log( 'x = ' + x )   // 1

         function a ( ) {
            let x = 2              // nowa zmienna x, niezależna od ww globala x
                                  // A wiec ma swój własny scope  ( block scope,  bo to let )

            console.log( 'x = ' + x )  // 2
        }

        a()
        console.log('x = ' + x)   //  1

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
        Teraz spójrzmy co się dzieje, jeśli pominiemy let przed 'x' w funkcji

        let x = 1
        console.log( 'x = ' + x )   // 1

         function a() {
            x = 2   // kompilator nie widzi gdzie x został zdefiniowany, wiec idzie do scope'a wyżej
                    // scope wyżej to global  ( wszystko co nie jest wewn funkcji jest globalem )
                    //  znajduje definicję 'x' w scopie globalnym,  wiec uznaje, że 'x' wymieniony w funkcji
                    //  to ten sam, co wyżej, czyli ma scope globalny

            console.log( 'x = ' + x )  // 2
        }

        a()
        console.log( 'x = ' + x )   //  2  - global

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
        Jeszcze wyraźniej widać to na poniższej funkcji zagnieżdżonej:

        let x = 1
        console.log( 'x = ' + x )   // 1

         function a ( ) {
            x = 2
            console.log( 'x = ' + x )  // 2

            function b ( ) {
                x = 3                                // jeśli poprzedzę 'x' let'em, w końcowym console.logu będzie 2, zamiast 3
                console.log( 'x = ' + x )  // 3
            }

            b (  )
        }

        a (  )
        console.log( 'x = ' + x )   //  3

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

        A teraz widać co się dzieje, jeśli brak w ogóle definicji zmiennej

         function a ( ) {
            x = 2    // kompilatór nie znajduje definicji zmiennej ani wewn funkcji
                     // ani nigdzie w zakresie wyżej, wiec uznaje ją jako zadeklarowaną
                     // tu czyli wewnątrz funkcji zmienną globalną
                     // To samo co:  global.x = 2

            console.log( 'x = ' + x )  // 2

            function b() {
              x = 3
              console.log( 'x = ' + x )  // 3
            }

            b()

        }

        a()
        console.log( 'x = ' + x )   //  3

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

        Przykład dostępu funkcji wewn do argumentu funkcji zewnętrznej

         function a ( slowo ) {
           global.x = 2
           console.log( 'x = ' + x )  // 2

            function b ( ) {
              x = 3
              console.log( 'x = ' + x )  // 3
              console.log( slowo )      // dupa
            }

            b()
        }

        a('dupa')
        console.log( 'x = ' + x )   //  3

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

        let slowo = 'jeden'

        function a() {
            console.log( slowo )      // dwa

            function b() {
                slowo = 'trzy'
                console.log( slowo )      // trzy
            }

            b()
        }

        slowo = 'dwa'
        a()

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
        Przykład pokazujący, jak funkcja może być zwrócona przed jej wywołaniem

        Closure - to kombinacja funkcji i zmiennych dostępnych w chwili jej tworzenia  ( środowiska )

        Pytanie: dlaczego w poniższym kodzie wartość zmiennej 'name'
                 jest pamietana mimo, że wołana jest poza funkcją ?

        Odp: Instancja funkcji inner, utrzymuje referencję ( powiązanie ) do jej środowiska,
             w którym jest zmienna 'name'

        Dzięki temu, w chwili wywołania myFunc (  ) zmienna 'name' jest dostępna
        i 'Mozilla' jest przekazana do wyświetlenia w konsoli

       developer.mozilla.org/en/docs/Web/JS/Closures

        function outer() {
          let name = "Mozilla"

          function inner() {
            return name
          }
          return inner
        }

        let myFunc = outer()
        console.log( myFunc())         // Mozilla

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

      let outest = 3

      let f = () => {
        let outer = 2
        return () => {
          let inner = 1
          console.log(outest)
          console.log(outer)
          console.log(inner)
        }
      }

      f()()

      console.log(outest)
      // console.log(outer)
      console.log(inner)


______________________________________________________________________________________________
141) Closures - Elliott

      medium.com/JS-scene/master-the-JS-interview-what-is-a-closure-b2f0d2152b36#.ett0ijoqc

        Closure jest tworzona, gdy funkcja korzysta ze zmiennej położonej poza jej scopem:

        var a = 5

          function sum( ) {
              return a + 1    // funkcja korzysta ze zmiennej położonej poza jej scopem
          }

          Closure = stworzyć funkcje zagnieżdżoną i zwrócić ją returnem, albo przekazując ją do innej funkcji
          Zmienne funkcji zagnieżdżonej będą dostępne dla tej nowej, nawet gdy funkcja zewn skończy działanie

          Closures są podstawą enkapsulacji, asynchronizmu i zabezpieczają przed efektami ubocznymi

          A closure is an inner function that has access to the variables in the outer (enclosing) function’s scope chain.

          The closure has access to variables in three scopes; specifically: (1) variable in its own scope, (2) variables in the enclosing function’s scope, and (3) global variables.
-------------------------------------------------------------------------------------------------------------------
            let globalVar = 'globalVar'

            function outer ( outerArg )  {
                let outerVar = 'outerVar'

                function inner ( innerArg )  {
                    let innerVar = 'innerVar'

                    console.log(
                        globalVar + "\n" +   // globalVar
                        outerArg + "\n" +    // outerArg
                        innerArg + "\n" +    // innerArg
                        innerVar                     //  innerVar
                    )
                }

                inner (  'innerArg')
            }

            outer ( 'outerArg' )

-------------------------------------------------------------------------------------------------------------------

        function z ( a ) {
            return function  ( x, y ) {
                console.log ( 'a = ',  a )
                console.log ( 'x = ',  x )
                console.log ( 'y = ',  y )
            }
        }

        let c = z ( 3 ) ( 4, 5 )   // a =  3
                                          // x =  4
                                          // y =  5
-------------------------------------------------------------------------------------------------------------------

        const getSecret = (secret) => {
          return {
            get: ( ) => secret
          }
        }

        console.log(  getSecret ( 33 ).get (  ) )   // 33

-------------------------------------------------------------------------------------------------------------------

        //const secret = (msg) => ( ) => msg

        const secret = function  ( msg ) {
            return function  (  ) {
                return msg
            }
        }

        console.log( secret ( 'kicha' ) (  )   )   // kicha


-------------------------------------------------------------------------------------------------------------------
        Funkcja zwracająca funkcję (pewien rodzaj funkcji zagnieżdżonej)

            function greet(sth) {
                return function (name) {
                    console.log( sth + ' ' + name )
                }
            }

            greet('siema')('fiuty')  // siema fiuty

            var saySiema =  greet('siema')
            saySiema('fiuty')        //  siema fiuty

-----------------------------------------------------
        Funkcja zagnieżdżona

        var addThree = function(a) {

            var addTwo = function() {
                return a + 2
            }

            return addTwo ( ) + 1
        }

        console.log( addThree( 1 ) )

-----------------------------------------------------
         You can use closures to create data privacy using factory function:
         Closure daje enkapsulację - funkcja factory
         Konstruktor zwraca 2 metody: get i set

            var Counter = function() {
                 var count = 0              // niedostępna z zewnątrz ..
                                                    // var x = new Counter() console.log(x.count) - zwróci undefined

                  return {
                        get: function() {
                            return count          // dostępna z zewnątrz
                        },
                        set: function set() {
                           count += 1             // dostępna z zewnątrz
                        }
                 }
            }

            var x = new Counter()

            console.log( x.count )    // undefined
            console.log( x.get ( ) )  //   0

            x.set( )
            console.log( x.get ( ) )  // 1
-----------------------------------------------------

        Closure to funkcja wewnętrzna mająca dostęp do zmiennych i argumentów funkcji zewnętrznej

        function add ( a, b ) {              // funkcja zewn i jej argumenty (parametry)

            var sum = 'Sum = '           // zmienna funkcji zewn

            function resultMsg() {         // funkcja wewn
                console.log( a)  // 1
                return sum + ( a + b )
            }

            return resultMsg()
        }

        console.log(add(5,3))   // 8
______________________________________________________________________________________________
142) Function - methods chaining

        let c = 100

        let x = {
          a() {
            c = c + 10
            return this

          },
          b() {
            c = c - 10
            return this
          }
        }

        x.a().b().a().b().b()
        console.log(c)    // 110

______________________________________________________________________________________________
143) Function -  higher order functions

        Funkcje zwracające funkcje, albo pobierające je jako argumenty np: filter, map, reduce
        Albo wolnostojące - nie wbudowane, tylko stworzone z ręki:

        a) funkcja (przekazana) do funkcji

            var calc = function(a,b,fn) {
              return fn(a,b)
            }

            var add = function(a,b) {
              return a+b
            }

            console.log(calc(5,6,add))  // 11

        b) funkcja (przekazana) do metody

            var calc = {
              calculate: function(a,b,fn) {
                return fn(a,b)
              }
            }

            var add = function (a,b) {
              return a+b
            }

            console.log(calc.calculate(3,4,add))  // 7

         c) metoda (przekazana) do metody

              var calc = {
                calculate: function(a,b,fn) {
                  return fn(a,b)
                }
              }

              var zestaw = {
                add: function (a,b) {
                  return a+b
                }
              }

              console.log(calc.calculate(3,4, zestaw.add))  // 7
______________________________________________________________________________________________
144) Function - recursion (fibonacci)

      a) Suma n początkowych cyfr ciągu

          function fibo(n) {
            if (n < 2) return n
            return fibo(n-2) + fibo(n-1)
          }

          lub:

          function fibo(n) {
            return n < 2 ? n : fibo(n-2) + fibo(n-1)
          }

          console.log(fibo(6))

        ES6:
          const fibo = n => n < 2 ? n : fibo(n - 2) + fibo(n - 1)

      --------------------------------------------------------------------

      b) tablica n początkowych cyfr ciągu

         function fibo(n) {
           const arr = [1, 1]

           for (let i = 2; i < n; i++) {
             arr.push(arr[i-2] + arr[i-1])
           }
           return arr
         }

         console.log(fibo(5))

______________________________________________________________________________________________
147) OLOO - Object.keys, .values i .entries

        Metody te zwracają tablicę elementów obiektu  ( kluczy, wartości lub par )

        let ziutek =  {
          name: 'ziutek',
          age: 12
        }

        console.log (Object.keys(ziutek))    // [ 'name', 'age' ]
        console.log (Object.values(ziutek))  // [ 'ziutek', 12 ]
        console.log (Object.entries(ziutek)) // [ [ 'name', 'ziutek' ], [ 'age', 12 ] ]

______________________________________________________________________________________________
148) OLOO - forEach (Object.keys i Object.values)

        Służy do iteracji przez tablicę elementów,
        w tym również elementów obiektu, tzn:

          a) kluczy - Object.keys
          b) wartości - Object.values
          c) par - Object.entries

          let ziutek = {
            name: 'ziutek',
            age: 12
          }

          Object.keys(ziutek).forEach(key => console.log(key))   // name, age
          Object.values(ziutek).forEach(key => console.log(key)) // ziutek, 12
 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

        Dzięki temu, można skopiować pary key - value z jednego obiektu do drugiego:

          let ziutek = {
            name: 'ziutek',
            age: 12
          }

          let mietek = {}

          Object.keys(ziutek).forEach(key => {
            mietek[key] = ziutek[key]
          })

          console.log(JSON.stringify(mietek))  // {"name":"ziutek","age":12}

______________________________________________________________________________________________
149) OLOO - for in

        Iteracja przez klucze obiektu
        Robi to samo, co forEach w przypadku Object.keys

        let ziutek = {
          name: 'ziutek',
          age: 12
        }

        for (let key in ziutek) {
          console.log(ziutek[key])
        }
______________________________________________________________________________________________
 150) OLOO  - Object.create

        developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Global_Objects/Object/create

        Metoda tworzenia obiektu z prototypu i ew deskryptorów dostępu

            const myProto = {
              prop1: "value1",
              method1: function () { /* ... */ }
            }

            const myObj = Object.create ( myProto )
-----------------------------------------------------------------------------

      const juzek =  {    // obiekt, który zostanie użyty jako prototyp
        job: 'clerk',
        age: 12,
      }

      const adam = Object.create (juzek)   // adam dziedziczy po juzku
        console.log (adam.job)  // clerk
        console.log (adam.age)  // 12

      adam.color = 'yellow'
        console.log (adam.color)   // yellow
        console.log (juzek.color)   // undefined

      juzek.music = 'folk'
        console.log (adam.music)   // folk

      const piotr = Object.create (adam)   // piotr dziedziczy po adamie
        console.log (piotr.job)   // clerk
        console.log (piotr.age)   // 12
        console.log (piotr.color)   // yellow
        console.log (piotr.music)   // folk

-----------------------------------------------------------------------------
        b)  prototyp i deskryptory dostępu

            const myProto = {
              prop1: "value1",
              method1: function ( ) { /* ... */ }
            }

            const propDescriptors = {
              prop2: {
                writable:     false,
                enumerable:   false,
                configurable: false,
                value: 7
              }
            }

        const myObj = Object.create ( myProto, propDescriptors )
______________________________________________________________________________________________
151) OLOO: zarys

        medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3

        github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch6.md

        stackoverflow.com/questions/29788181/kyle-simpsons-oloo-pattern-vs-prototype-design-pattern

        Prototype delegation aka Object-Linked-To-Other-Objects (OLOO)

        Wady class-based OOP:
          a) tight coupling parent-child; opposite of reusable, modular code

          b) making small changes to a class creates rippling side-efects
              that break things that should be completely unrelated

          c) inheritance trees difficult to debug

        OLOO is much simpler to just express the objects and directly link them,
        than to indirectly link them through the constructor/new mechanisms.

        Prostsza obiektowość od klasycznego OOP ( z operatorem 'new' )
        Peer objects linked together via behavior delegation, instead of the parent-child

        JS doesn’t need constructor functions because any function
        can return a new object. With dynamic object extension, object literals
        and `Object.create()`, we have everything we need  —  with none of the
        mess. And `this` behaves just like it does in any other function. Hurray!

        Douglas Crockford doesn’t use `new` or `this` at all, instead opting
        for an entirely functional approach to code reuse.

        All his objects are just stateless bags of functions, or data-only objects
        like associative arrays with no methods.

        This works well unless you’re creating a hundreds of thousands of objects and you need your app to perform smoothly at or near realtime (think game engines, realtime signal processors, etc…)

        Kyle Simpson coined the term OLOO (Objects Linked to
        Other Objects) to clarify the distinction between prototype delegation
        and class inheritance.

        const Car = {
          init: function(marka, kolor) {
            this.marka = marka
            this.kolor = kolor
          },

          create: function(wiek) {
            let instance = Object.create(this)
            instance.wiek = wiek
            return instance
          }
        }

        const car1 = Object.create(Car)

        car1.init ( 'fiat', 'żólty' )

        console.log (car1.marka)   // fiat
        console.log (car1.kolor )   // żółty


        const car2 = car1.create (22)

        console.log (car2.marka)   // fiat
        console.log (car2.kolor)   // żólty
        console.log (car2.wiek)   // 22
______________________________________________________________________________________________
152) OLOO - pełne

      let user =  {
        init: function ( name, age) {
            this.name = name
            this.age = age
        },
        create: function ( args ) {
            let instance  = Object.create ( this )
            Object.keys ( args ).forEach ( function ( key ) {
                instance [ key ]  = args [ key ]
            } )
            return instance
        },
        gadaj: function  ( cos ) {
            return 'No to gadam: ' + cos
        },
        jakaNazwa: function  ( ) {
            return 'Moja nazwa to: ' + this.name
        },
        stan: 'używany',
        miasto: 'Wwa'
      }

      let user1 = Object.create ( user )
      user1.init ( 'jon', 32 )

      console.log ( user1.gadaj ( 'dupa' ) )
      console.log ( user1.jakaNazwa ( ) )
      console.log ( user1.stan )
      console.log ( user1.miasto )

      console.log( '___________________________________________' )

      let user2 = user1.create ( { name: 'ron', wzrost: 'niski', waga: 86 } )    // nadpisuje prppertkę 'name' prototypu
      console.log ( user2.gadaj ( 'trupa' ) )
      console.log ( user2.jakaNazwa ( ) )
      console.log ( user2.stan )
      console.log ( user2.miasto )
      console.log ( user2.wzrost )
      console.log ( user2.waga )

______________________________________________________________________________________________
153) OLOO - Object.assign

      developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
      CodeSchool - ES2015: 3.2 Object.assign
      aka Concatenative inheritance aka Mixins

      Metoda pozwalająca łączyć lub płytko klonować obiekty

      Object.assign ( target, ...sources ) - tzn dodanie do 1-go z obiektów, pozostałych
      (tych, przez które enumeracja nie została wyłączona):

          Object.assign(x, y)   // x = x + y

      Czyli pierwszy z nich ulegnie zmianie !!
      Tworząc nowy obiekt, by pierwszy z nich nie uległ zmianie, na początku umieść obiekt pusty:

        const z = Object.assign({ }, x, y)

      a) Łączenie obiektów (merging)

          const juzek =  {
            job: 'clerk',
            age: 12,
          }

          const home =  {
            city: 'Warsaw',
            street: 'Długa'
          }

          const kids =  {
            number: 2,
            names:  [ 'Ania', 'Ola' ]
          }

          const piotr = Object.assign ( {}, juzek, home, kids )

          console.log( piotr )   // { job: 'clerk',  age: 12, city: 'Warsaw', street: 'Długa', number: 2, names: [ 'Ania', 'Ola' ] }

      b) klonowanie - tylko płytkie

          i) płaski obiekt - ok

              const x  =  { name:  'jon' }

              const clone = Object.assign ( { }, x )

              clone.name  = 'hans'

              console.log(x)        // { name: 'jon' }
              console.log(clone)   //  { name: 'hans' }

          ii) obiekt zagnieżdżony - źle

              const x = { name: { first: 'jon' } }

              const clone = Object.assign ( { }, x )

              clone.name.first  = 'hans'

              console.log ( x )        // { name: 'hans' }
              console.log ( clone )   //  { name: 'hans' }

      c) łączenie tablicy obiektów ( array merging )

          var arr = [{ a: 1 }, { b: 2 }, { c: 3 }]

          var all = Object.assign( { }, ...arr)  // z użyciem rest ...arr parameter

          console.log( o1 )      // { a: 1 }
          console.log( o2 )     //  { b: 2 }
          console.log( o3 )    //   { c: 3 }
          console.log( all )   //   { a: 1, b: 2, c: 3 }

      d) zrobienie obiektu z tablicy

          var obj =  [ 1, 2 ]
          var copy = Object.assign ( { }, obj )

          console.log(copy)  // { '0': 1, '1': 2 }

______________________________________________________________________________________________
154) OLOO - computed object (ES6)

        Poniższe to kopia p. 106)

        a) computed value only

            const name = 'jan'
            const x = { ['name']: name }   // { name: 'jan' }
            -------------

            const a = 'miasto'
            const b = 'Warszawa'

            const x = { [ a ]: b }   // { miasto: 'Warszawa' }

        b) computed key and value

            const a =  [ 'imie', 'wiek', 'miasto' ]
            const b =  [ 'Wacek', 22, 'Wwa' ]
            const c =  { }

            a.map((item, index) {
              Object.assign(c, { [ item ]: b [ index ]})
            })

            console.log( c )   // { imie: 'Wacek', wiek: 22, miasto: 'Wwa' }

______________________________________________________________________________________________
155) OOP - intro 1

      sitepoint.com/JS-object-creation-patterns-best-practises/?utm_source=JSweekly&utm_medium=email
      developer.mozilla.org/pl/docs/Web/JavaScript/dziedziczenie_lancuch_prototypow
      medium.com/javascript-scene/3-different-kinds-of-prototypal-inheritance-es6-edition-32d777fa16c9

      JS nie zapewnia natywnej implementacji klasy (słowo kluczowe 'class', zostało wprawdzie
      wprowadzone w ES6, ale to tylko cukier syntaktyczny - wrapper nad prototypem.

      Jeżeli chodzi o dziedziczenie, posiada jedynie jedną konstrukcję: obiekty.

      Każdy obiekt posiada wewnętrzne połączenie do innego obiektu, zwanego jego prototypem.

      Obiekt prototype posiada swój własny prototyp, i tak dalej, aż obiekt osiągnie null
      jako swój prototyp.

      null nie ma prototypu i działa jak zakończenie łańcucha prototypów.

      JS nie ma takich metod, jak inne języki.
      W JS metodą może być każda funkcja dodana do obiektu jako propertka (właściwość)

      Dziedziczone metody działają tak samo jak własne

      I. Tworzenie obiektu

           5 metod:

            1) object literal: const Car = {}

            2) konstruktor new z funkcji prototypu

                function Car(color, price) {
                  this.color = color
                  this.price = price
                }

                const car1 = new Car('red', 500)

            3) Object.create z funkcji zwracajacej obiekt

                function Car() {}
                const car1 = Object.create(Car)  // Car = prototyp

            4) Object.create z literala

                const Car = {
                  name: 'honda',
                  age: 12,
                  say: function() { return 'Tu ' + this.name }
                }

                const toyka = Object.create(Car)

            5) class

      II. Dziedziczenie

            3 metody:

            2 prototypowe:
              a) konstruktorowa - new
              a) prototypowa    - Object.create(prototype)

            i 1 klasowa         - class extends

      III. Object.create()

            Może tworzyć obiekt z:
              a) object literala
              b) funkcji zwracającej obiekt (wzorzec factory)

      IV. Konstruktor new

            Może występować w:
              a) factory  (funkcja zwracająca obiekt)
              b) prototyp (funkcja z this'ami)

--------------------------------------------------------------

      1) object literal

          const car = {
            price: 1200,
            color: 'blue',
            sayHi: () => 'Hi'
          }

            const dog2 = dog1  // obiekt tworzony jest przez referencję, a nie wartość (jak prymitywy)

            dog2.name = 'Frux'
            console.log(dog1.name)  // Frux
            console.log(dog2.name)  // Frux

         Aby działało, trzeba użyć Object.create:

            const dog2 = Object.create(dog1)

            dog2.name = 'Frux'
            console.log(dog1.name)  // Azur
            console.log(dog2.name)  // Frux

--------------------------------------------------------------

      b) Object.create z funkcji zwracającej obiekt

          function Car(name, age) {
            return {
              name,
              age,
              sayHi: () => 'Hi !'
            }
          }

          //const car1 = new Car('fiat', 12)
          const car1 = Object.create(Car('fiat', 12))

          console.log(car1.name)
          console.log(car1.age)
          console.log(car1.sayHi())
          console.log('------------------')

          car1.sayHey = () => 'Hey !'
          console.log(car1.sayHey())
          console.log('------------------')

          const car2 = Object.create(car1)
          console.log(car2.name)
          console.log(car2.age)
          console.log(car2.sayHi())
          console.log(car2.sayHey())

--------------------------------------------------------------

      c) new z funkcji zwracającej obiekt

          function Car(price, color) {
            return {
              price,
              color,
              sayHi: () => 'Hi'
            }
          }

          const fiat = new Car(1200, 'blue')

          console.log(fiat.price)
          console.log(fiat.color)
          console.log(fiat.sayHi())

--------------------------------------------------------------

      d) new - konstruktor

          function Car(price, color) {  // funkcja konstruktora
            this.price = price
            this.color = color
          }

          Car.prototype.sayHi = function() { return 'Hi'}

          const fiat = new Car  // Car - jest tu prototypem

          fiat.price = 1200
          fiat.color = 'blue'
          console.log(fiat.price)
          console.log(fiat.color)
          console.log(fiat.sayHi())

--------------------------------------------------------------

      e) new - klasa

          class Car {
            constructor(price, color) {
              this.price = price
              this.color = color
            }

            sayHi() { return 'Hi !' }
          }

          const fiat = new Car(1200, 'blue')

          console.log(fiat.price)    // 1200
          console.log(fiat.color)    // blue
          console.log(fiat.sayHi())  // Hi !
          console.log('-----------------------')

          class Gokart extends Car {
            constructor(price, color, age) {
              super(price, color)
              this.age = age
            }
          }

          const gokart = new Gokart(5000, 'green', 12)

          console.log(gokart.price)   // 5000
          console.log(gokart.color)   // green
          console.log(gokart.sayHi()) // Hi !
          console.log(gokart.age)     // 12

______________________________________________________________________________________________
156)  OOP - intro 2

        Obiekt to nieuporządkowana kolekcja par key-value
        Wszystko jest obiektem, prócz prymitywów (liczby, buljony)
        Best practice tworzenia obiektów i arrajków jest object literal raczej niż przez new Object()

       Podstawowe metody wiązania keys z values:
          a) Dot
              i)  Set:  object.key = 'hello'
              ii) Get:  var x = object.key

          b) Square bracket
              i)  Set:  object [ key ] = 'hello'
              ii) Get:  var x = object [ key ]

         Składnie definiowania metod:

           a) sayHi: () => 'Hello'
           b) sayHi() { return 'Hi !'}

         Obie działają zarówno w object literalu, jak i w funkcji zwracającej obiekt:

           a) literal

                const Car = {
                  sayHi() { return 'Hi !'},
                  sayHey:() => 'Hey !'
                }

                console.log(Car.sayHi())  // Hi !
                console.log(Car.sayHey()) // Hey !

           b) funkcja

                function Animal() {
                  return {
                    sayHi() { return 'Hi !'},
                    sayHey:() => 'Hey !'
                  }
                }

                const dog = Object.create(Animal())
                console.log(dog.sayHi())  // Hi !
                console.log(dog.sayHey()) // Hey !

______________________________________________________________________________________________
157)  OOP - Konstruktory

        Przez dodanie 'new' przed nazwą funkcji definiującej obiekt,
        mówimy, że chcemy by była to funkcja konstruktora, tzn tworząca nowy obiekt

        Wewnątrz konstruktora, wskaźnik this odnosi się do właśnie tworzonego obiektu

          function Car( model, year ) {
            this.model = model
            this.year = year
            this.toString = () => this.model + " z roku " + this.year
          }

         a) object literal

            function makeUser(first, last, age)  {
              const fullName  =  first + ' ' + last

              return {
                fullName,
                age,
                "22":  "dwadziescia_dwa",
                sayHi: () => console.log( 'Hi '+ fullName
              }
            }

            let user = makeUser("John", "Smith", 30);

            user.sayHi()   // Hi John Smith
            console.log( 'user. first  = ',  user.first)  // undefined,  bo .first jest prywatna ( poza returnem)

            console.log('age in user  = ',  'age' in user)  // true

            for ( key in user ) {
              console.log( key + ': ' + user [ key ] )
            }

          ---------     lub: -----------------------------------------------

              function makeUser ( name, age )  {
                return {
                  name,
                  age,
                }
              }

              let user = makeUser ( 'Jon', 30 )
              console.log ( user )

          -----------------------------------------------------------------

        b) klasowy

              function MakeUser ( name, age )  {
                this.name = name
                this.age = age
              }

              let user = new MakeUser ( 'Jon', 30 )
              console.log ( user )

            -----------------------------------------------------------------

            Wady:
                i) utrudnione dziedziczenie
                ii) metoda toString tworzona jest dla każdego nowo tworzonego obiektu osobno

        c) prototypowy
              Car.prototype.toString = function () { return this.model + " jest z roku " + this.year }
                  i) metoda toString dzielona jest przez wszystkie nowo tworzone obiekty,
                     bo znajduje się poza główną definicją obiektu

______________________________________________________________________________________________
158) OOP - in

      Sprawdza czy w obiekcie występuje propertka

      let ziutek =  {
        name: 'ziutek',
        age: 12,
        sayName() {
          return this.name
        }
      }

      console.log('name' in ziutek)       // true
      console.log('sayName' in ziutek)   //  true
      console.log('dupa' in ziutek)      //  false

______________________________________________________________________________________________
159)  OOP - for..in

        var kloss = { imie: 'Hans', miasto: 'Wwa' }

        for (var i in kloss) {
          console.log(kloss [ i ] )
        }

        When looping over the object integer properties are sorted, others appear in creation order
______________________________________________________________________________________________
160)  OOP - usuwanie właściwości

        var kloss = { imie: 'Hans', miasto: 'Wwa' }
        delete kloss.imie

        console.log('imie' in kloss)

       UWAGA !

          Nie można usunąć właściwości odzidziczonej z prototypu:

          var Employee = {
            company: 'xyz'
          }

          var emp1 = Object.create(Employee)

          delete emp1.company
          console.log(emp1.company)

          emp1.color = 'red'
          console.log(emp1.color)
          delete emp1.color

          console.log(emp1.company)
          console.log(emp1.color)

______________________________________________________________________________________________
161) OOP - prototyp 1

      medium.com/@kevincennis/prototypal-inheritance-781bccc97edb
      blog.bitsrc.io/understanding-javascripts-prototypal-inheritance-354292253bcb
      hackernoon.com/understanding-javascript-prototype-and-inheritance-d55a9a23bde2

      Prototyp to referencja do obiektu-rodzica.

      Ma go każdy obiekt w JS, co tworzy hierarchię:
         null > dziadek (prototyp: null)> rodzic (prototyp: dziadek) > dziecko (prototyp: rodzic)

      Prototyp używany jest zawsze gdy wywoływana jest jakaś właściwość lub metoda obiektu
      i nie ma jej w tym obiekcie. Wtedy kierując się prototypem, idzie się do obiektu parenta
      i patrzy, czy tam jest. Jeśli nie - abarot, poprzez prototyp idzie się do obiektu wyżej

      Tak dochodzi się do null'a. Ponieważ nie ma on prototypu, to zwracany jest błąd
      i wykonywanie programu sie kończy

______________________________________________________________________________________________
162) OOP - prototyp 2

      javascript.info/prototype-inheritance

      Każdy obiekt ma prototyp z którego dziedziczy właściwości i metody

      Gdy woła się jakieś pole lub metodę obiektu, a takiego nie ma,
      runtime idzie szukać go do konstruktora prototypu

      Dlaczego więc, nie definiować pola od razu w prototypie ?

      Wtedy runtime nie idzie do konstruktora obiektu, bo go nie ma,
      tylko od razu do prototypu

      Z  Object.prototype dziedziczą obiekty tworzone przez:
         a) literał obiektowy
         b) new Object()
         c) obiekty wbudowane (Date, Array, RegExy, Function)

      Object.prototype jest na górze łańcucha prototypów

      Metody prototypów najczęsciej ujmowane są poza konstruktorem.
      Dzięki temu, gdyby stworzonych zostało 1,000 obiektów, metode getInfo dostałyby tylko
      wybrane, zamiast wszystkich, gdyby metoda była umieszczona w konstruktorze

      Pozwala to oszczędzić pamięć

      Dziedziczyć można łańcuchowo, są tylko 3 ograniczenia:
        a) nie można w kółko tzn leżący w łańcuchu wyżej nie może od leżacego niżej
        b) wartość __proto__ musi być = object lub null. Inne wartości są ignorowane
        c) dziedziczyć można tylko od 1 prototypu

      ---------------------------------------------------

      function Rectangle(width, height) {
        this.width = width
        this.height = height
      }

      Rectangle.prototype.area = function() {
        return this.width * this.height
      }

      function Square(length) {
        this.width = length
        this.height = length
      }

      Square.prototype = Object.create(Rectangle.prototype)

      const sq1 = new Square(10)

      console.log(sq1)

      console.log(sq1.area())

______________________________________________________________________________________________
163) OOP - isPrototypeOf i __prototype: sprawdzanie co jest prototypem obiektu

      var malpa = { owlosiona: true, je: 'banany', oddycha: 'powietrzem' }

      var jurek = Object.create(malpa)
      console.log(malpa.isPrototypeOf(jurek))  // true

      console.log( jurek.__prototype__ )  // malpa
______________________________________________________________________________________________
164) OOP - prototype: rozszerzanie obiektu wbudowanego (Array)

      Rozszerzanie obiektu wbudowanego, to zła praktyka,
      bo przyszła wersja JS, może nadpisać tak zmienioną metodę

      -----------------------------------------------------
      Sprawdzenie czy element istnieje w tablicy

      Array.prototype.inArray = function(needle) {
        return this.includes(needle)
      }

      console.log([ 'raz', 'dwa', 'piec' ].inArray('raz'))

     -------------------------------------------------------------
      Odwrócenie kolejności znaków w słowie

      String.prototype.reverse = function() {

        a) return Array.prototype.reverse.apply(this.split('')).join('')
              lub
        b) return this.split('').reverse().toString().replace(/,/g, '')
      }

      console.log('dupa'.reverse())  // apud
______________________________________________________________________________________________
165) OOP - klonowanie obiektu

      Płytka kopia  -  Object.assign
      Głęboka - lodashowym cloneDeep() lub JSON.parse(JSON.stringify(obj))

      Ponieważ obiekty tworzone są przez referencję (adres w pamięci),
      proste przypisanie obiektu do nowej zmiennej, nie stworzy nowego obiektu,
      a tylko referencję do niej
      (wystarczy zmienić coś w oryginale i od razu zmieni to kopię)

      let user = {
        name: "John",
        age: 30
      }

      let copy = user
      console.log( copy === user )  // true,  czyli ten sam obiekt

      Rozwiązaniem jest funkcja Object.assign, która kopiuje wartości
      z co najmniej jednego obiektu źródłowego, do obiektu docelowego:

      Object.assign ( target, ...sources )  - target i sources są wymagane

      let clone = Object.assign ( { }, user)  // { name: 'jon', age: 12 }
      console.log( clone === user )  // false,  czyli nowy obiekt

      Jeśli jednak obiekt zawiera w sobie inny obiekt, trzeba użyć algorytmu 'Structured cloning algorithm',
      zaimplementowanego np w lodashowym _.cloneDeep (  )
______________________________________________________________________________________________
166) OOP - mixiny - dziedziczenie wielokrotne

        Kopiowanie pól z kilku obiektów do jednego, nowego
        Analogicznie jak głeboka / płytka kopia (pętla w pętli w pętli - zagnieżdżone pętle )

        Mixin - to obiekt dostarczający istotnych właściwości, ale który nie powinien być dziedziczony ani rozszerzany
        Dziedziczenie wielokrotne to zastosowanie mixinów
        Przekazując mixiny do nowego obiektu, otrzymuje się nowy obiekt, ale bez wstawiania ich do drzewa dziedziczenia

        Problem z dziedziczeniem wielokrotnym polega na tym, że może dochodzić do konfliktów wartości
        Tzn zmienna o tej samej nazwie, może znajdować się w 2+ mixinach i ostatnia w łańcuchu, nadpisze poprzednią
            _.extend(jasiu, kasia, zosia) - przykład z underscora

        Rozwiązaniem, jest posłużenie się mixinowaniem selektywnym przy użyciu metody .bind:

          var kasia = {
            spiewaj: function() {
              console.log( 'piejo kasia pieeeje' )
            },
            wiek: 33
          }

          var jasiu = {
            gadaj: function() {
              console.log( 'sialalalala' )
            }
          }

          jasiu.spiewaj = kasia.spiewaj.bind(kasia)
          jasiu.wiek = kasia.wiek

          jasiu.spiewaj()              //  piejo kasia pieeeje
          console.log( jasiu.wiek )   //  33
______________________________________________________________________________________________
167) Object - ograniczanie modyfikacji obiektów

                                Update     Delete      Add
        preventExtensions       tak        tak         nie
        seal                    tak        nie         nie
        freeze                  nie        nie         nie

      ---------------------------------------------------------------------------------

        var obj = {
          a: 5,
          b: 7
        }

        // Object.freeze(obj)             // allowed: nothing  { a: 5, b: 7}
        // Object.seal(obj)               // allowed: update   { a: 9, b: 7 }
        // Object.preventExtensions(obj)  // allowed: all but adding  { a: 9 }

        obj.a = 9         // update
        delete obj.b      // delete
        obj.c = 22        // create

        console.log(obj)
__________________________________________________________________________________________
168) Object - preventExtensions() i isExtensible()

        Można zmieniać i usuwać  (nie można dodawać propsów)
        Sprawdzić czy jest rozszerzalny można przez Object.isExtensible(obj)

        'use strict'

        var obj = {
            a: 5,
            b: 7
        }

        // A   Object.preventExtensions(obj)

        console.log(obj.a)  // 5  // A 5

        obj.a = 3
        console.log(obj.a)  // 3  // A 3

        delete obj.b
        console.log(obj.b)  // undefined  // A undefined

        obj.c = 44
        console.log(obj.c)  // 44   // A Can't add property c, object is not extensible

        console.log(Object.isExtensible(obj)) // true // A false

__________________________________________________________________________________________
169) OOP - seal

        Pozwala TYLKO zmieniać  (nie pozwala usuwać, ani dodawać)
        Test - Object.isSealed(obj)

        var obj = {
            a: 5,
            b: 7
        }

        // A Object.seal(obj)

        obj.a = 9
        console.log(obj.a)  // 9  // A  9
        console.log(obj.b)  // 7
        delete obj.b           // A  Cannot delete property 'b' of #<Object>
        console.log(obj.b)  // undefined
        obj.c = 8
        console.log(obj.c)  // 8

__________________________________________________________________________________________
170) OOP - freeze

        Nie pozwala zmieniać, ani usuwać, ani dodawać
        Test - Object.isFrozen(obj)

        'use strict'

        var obj = {
            a: 5,
            b: 7
        }

        Object.freeze(obj)

        obj.a = 9                //  read-only
        delete obj.b           //  Cannot delete
        console.log(obj.c)  // Cannot add

__________________________________________________________________________________________
171) OOP - dynamic prototypes

      function Person() {
        this.imie = "Jasiu"
        this.wiek = 56
      }

      var person1 = new Person()

      Person.prototype.dajGlos = function() {
        console.log( 'tu metoda dajGlos')
      }

      console.log ( 'person1.imie = ',  person1.imie )   // Jasiu

      person1.dajGlos()  // tu metoda dajGlos
                         // metoda z proto działa nawet gdy obiekt
                         // stworzono przed nią

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

      Funkcje zagnieżdżone powinny być używane tylko tam gdzie muszą,
      bo mają negatywny wpływ na performance (cpu i RAM) - patrz ostatni przykład w tym punkcie

      Np gdy tworzone są nowe obiekty / klasy, metody powinny być podhaczane do prototypu
      a  nie definiowane w konstruktorze.

      Bo do prototypu są podhaczane tylko raz - przy tworzeniu pierwszego obiektu,
      a jeśli są w konstruktorze, wołane są dla każdego z obiektów

      https://developer.mozilla.org/en/docs/Web/JS/Closures

      ŹLE !

          function MyObject ( name, message ) {
                this.name = name.toString ( )
                this.message = message.toString ( )

                this.getName = function ( ) {
                  return this.name
                }

                this.getMessage = function ( ) {
                  return this.message
                }
          }

      DOBRZE !

        function MyObject(name, message) {
          this.name = name.toString()
          this.message = message.toString()
        }

        MyObject.prototype.getName = function() {
          return this.name
        }

        MyObject.prototype.getMessage = function() {
          return this.message
        }

______________________________________________________________________________________________
172a) OOP this - 1

    'this' - to obiekt wykonujący bieżącą funkcję

    Zależnie od tego skąd ta funkcja jest wołana, zachodzi 6 wariantów:

    1) W funkcji i w setTimeout - window / global
    2) W metodzie obiektu - ten obiekt
    3) Przy przekazywaniu obiektu call'em, apply'em lub bind'em - ten obiekt
    4) Przy tworzeniu obiektu kontruktorem new - nowo tworzony obiekt
    5) W DOM event handlerze - obiekt który odpalił eventa
    6) Wewnątrz IIFE przy użyciu "use strict" - undefined

    ref: Understand JavaScript 'this' in a crystal clear way
         youtube.com/watch?v=yuo8YqKDQ-M

    this (inaczej kontekst) użyty w metodzie funkcji mówi, że chodzi o propertkę tego samego obiektu
    Brak this, oznacza wzięcie jej spoza obiektu:

    -------------------------------------------------------------------------
    name = 'misiu'

    const person = {
      name: 'zuzia',
      sayName() {
        console.log(name)         // misiu
        console.log(this.name)   //  zuzia  -  propertka tego samego obiektu
      }
    }

    person.sayName()

______________________________________________________________________________________________
172b) OOP - this

    this.table = 'global table'

    const cleanTable = function(soap) {
      console.log(`cleaning ${this.table} using ${soap}`)
    }

    this.garage = {
      table: 'garage table'
    }

    const johnsRoom = {
      table: 'johns table'
    }

    cleanTable.call(this, 'some soap')          // this w funkcji = window / global
    cleanTable.call(this.garage, 'some soap')   // this w propertce obiektu = ten obiekt
    cleanTable.call(johnsRoom, 'some soap')     // jak wyżej


______________________________________________________________________________________________
172c) OOP - this


      --------------------------------------
      this.car = 'HONDA'

      function outer() {
        function inner() {
          console.log(this.car)   // nie widzi zewn thisa, a jego własny nie zna car'a
                                  // trzeba mu go jakoś podać ..
        }

        inner()
      }

      outer(this)

      --------------------------------------

      this.car = 'HONDA'

      function outer(context) {     // musi go odebrać pod inną nazwą, by nie gryzła się z jego własnym this'em
        function inner(context) {
          console.log(context.car)
        }

        inner(context)
      }

      outer(this)

______________________________________________________________________________________________
172d) OOP - this

      Szczególnym, często chodzącym przypadkiem problemu z this'em, jest funkcja zagnieżdżona.
      Poniższe nie działa. Są 4 rozwiązania:
        1) wewnętrzna arrow function
        2) that = this
        3) call
        4) bind


      ----------- Jak to naprawić ? ---------------------------------

      this.car = 'global HONDA'

      function outer() {
        function inner() {
          console.log(this.car)  // wewn funkcji robi mu się własny this,
                                 // nie widzący żadnych wcześniejszych this'ów
                                 // By zaczęło działać, trzeba mu podać właściwego,
                                 // zewnętrznego this'a
        }
        inner()
      }

      outer.call(this)

      ----------- Rozw 1: arrow function -------------------------------------------------

        this.table = 'HONDA'

        function outer() {
          const inner = () => {      // arrow function zamiast zwykłej
            console.log(this.car)
          }
          inner()
        }

        outer.call(this)

      ----------- Rozw 2: that = this ----------------------------------------------------

        this.table = 'HONDA'

        function outer() {
          that = this
          function inner() {
            console.log(that.table)
          }
          inner()
        }

        outer.call(this)

      ----------- Rozw 3: call -----------------------------------------------------------

        this.table = 'HONDA'

        function outer() {
          function inner() {
            console.log(this.car)
          }
          inner.call(this)     // call
        }

        outer.call(this, 'AZOR')

      ----------- Rozw 4: bind -----------------------------------------------------------

        this.table = 'HONDA'

        function outer() {
          function inner() {
            console.log(this.car)
          }
          inner.bind(this)()  // bind
        }

        outer.call(this)

______________________________________________________________________________________________
172e) OOP this - 1

      javascript.info/object-methods

      Przy wołaniu metody, this to obiekt ('sprzed kropki'), który ją woła, czyli user

      -----------------------------
      name =  'Zewn'

      user =  {
        name: 'Wewn',
        say: function ( ) {
          console.log( 'Hello ' + name )      // Hello Zewn
          console.log( 'Hello ' + this.name ) // Hello Wewn
          console.log( 'Hello ' + user.name ) // Hello Wewn
        }
      }

      user.say()

______________________________________________________________________________________________
173) OOP this - 3

        var kloss = {
          name: 'Hans',
          mowImie: function () {
            return this.name
          }
        }

        console.log(kloss.mowImie())    // Hans

        var ziutek = kloss.mowImie
        console.log(ziutek())          // undefined

        var ziutek = kloss.mowImie.bind(kloss)
        console.log(ziutek())                 // Hans

______________________________________________________________________________________________
174) OOP - delete

        Służy do usuwania propertki obiektu:

        var myObject = {
            price: 20.99,
            get_price : function() {
                return this.price
            }
        }

        delete myObject.price
        console.log ( 'myObject.price = ',  myObject.price )   // undefined

 -  -  -  -  - ... ale nie usuwa jej całkiem z childa   -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

        However, when you call the method getprice, first it looks for  this.price in the child since the customObject doesn't have
        price property , JS executor walks through the prototype chain towards the parent.

        var myObject = {
            price: 20.99,
            get_price : function() {
                return this.price
            }
        }

        var customObject = Object.create ( myObject )

        customObject.price = 19.99

        delete customObject.price

        console.log ( 'price in customObject = ',  'price'  in customObject )

        console.log ( customObject.get_price ( ) )

______________________________________________________________________________________________
175) OOP - typeof vs instanceof

        typeof  -  używaj do prymitywów, instanceof  -  do obiektów

       var person = {
          fname: "Travis",
          lname: "Tidwell"
       }

       console.log(typeof person ) // object = ok
-----------------------------------------------------

       var person = [{
          fname: "Travis",
          lname: "Tidwell"
       }]

       console.log ( typeof person )                   // object = źle, bo to array jest
       console.log ( typeof person instanceof Array ) // true = ok
______________________________________________________________________________________________
176) OOP - call vs apply

      Call i aplly - przekazywanie obiektu do metody innego obiektu
      Właściwości przekazywanego obiektu nadpisują tam obecne

--------------------------------------------------------------------------------------------
    function foo() {
      console.log(this)
    }

    // foo()             // global or window

    foo.call({ a: 1 })  // { a: 1 }

--------------------------------------------------------------------------------------------
    var person = {
      name: 'jan',
      sayName() {
        console.log('To ' + this.name)
        console.log('Wiek ' + this.age)
      }
    }

    person.sayName()  // To jan   Wiek undefined
    person.sayName.call({name: 'dupa', age: 123}) // To jan   Wiek 123

--------------------------------------------------------------------------------------------
    Przy metodzie call(), this to przekazywany do funkcji obiekt

    function welcome() {
      console.log(this  )
      console.log(`Hello ${this.name}`)
    }

    const users = [
      { name: 'Adam'},
      { name: 'Mike'},
    ]

    users.forEach(el => welcome.call(el))

--------------------------------------------------------------------------------------------
    Wartość this danej metody ustawiana jest na przekazywany obiekt

    Call i apply - to przekazanie obiektu-dziecka do obiektu-rodzica,
    by dzieciak mógł skorzystac z metody rodzica, ale pod swoim imieniem

    Innymi słowy - property dzieciaka (np imie: 'Kajtuś'), nadpisuje property rodzica (imie: 'Ludwik' )
    Wywołana metoda zamiast np wypisac 'Tu Ludwik', wypisze 'Tu Kajtuś'

    Różnica między .call() i .apply() polega tylko na sposobie podawania argumentów do metody obiektu
    Jeśli wywoływana metoda obiektu nie ma argumentów, call i apply się nie różnią

    call - kiedy argumenty są znane wtedy wymienia się je kolejno
    apply - kiedy nie są znane, używa się tablicy
----------------------------------------------------------------------------------
    var person = {
        name: 'Ziutek',
        sayName: function ( miasto, wiek ) {
            //console.log ( this.name + ' ' + this.miasto + ' ' + this.wiek )           // A przy odbieraniu całego obiektu, używaj this.property
            //console.log ( this.name + ' ' + miasto + ' ' + wiek )                        //  B   przy odbieraniu parametrów, użyj samo property
            console.log ( this.name + ' ' + arguments [ 0 ] + ' ' + arguments [ 1 ] )  //  C   przy odbieraniu parametrów, użyj arguments[]
        }
    }

      // var krzys = { name: 'krzys', miasto: 'wroclaw', wiek: 44 }   // A cały obiekt
      // person.sayName.call ( krzys )                                           //  A przekazanie całego obiektu

    var krzys = { name: 'krzys' }                                                  // B,C częściowy obiekt
    //person.sayName.call(krzys, 'krk', 12)                                //  B przekazanie częściowego obiektu i parametrow
    person.sayName.apply(krzys, ['krk', 12])                            //   C przekazanie częściowego obiektu i tablicy parametrow

______________________________________________________________________________________________
177) OOP - bind

        Tuba:  JavaScript Bind in 5 Minutes
                     FunFunFunction #43 bind and this

        Bind tworzy kopię funkcji i wiąże ją z obiektem
        Pozwala na reuse tej samej funkcji z co chwila nowym obiektem

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

        let ziutek =  {
            name: 'ziutek',
            age: 12,
            sayName (  )  {
                console.log ( this.name )
            }
        }

        ziutek.sayName (  )                    // ziutek
        const mietek = ziutek.sayName
        mietek (  )                               // undefined,  bo wołany jest nie z kontekstu samego obiektu,  ale spoza
                                                          //  Dlatego stracił wiązanie do obiektu  ( binding )
        mietek.bind ( ziutek ) (  )     // mietek     .bind ( ziutek )  -  przywraca mu to wiązanie

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

        const a = { name: 'jon' }
        const b = { name: 'robb' }

        function showName (  ) {
            return this.name
        }

        console.log ( showName.bind ( a ) (  ) )   // jon
        console.log ( showName.bind ( b ) (  ) )   // robb
        console.log ( showName (  ) )                      // undefined

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
        function getCash ( amount )  {
            console.log ( '\nSaldo = ',  this.balance )
            this.balance = this.balance - amount
            console.log ( `${this.name} wzięła ${amount} \nZostało: ${this.balance}` )
        }

        const client1 = { name: 'Kasia', balance: 500 }

        getCash.bind ( client1, 100 ) (  )   // Saldo =  500     Kasia wzięła 100   Zostało: 400
        getCash.bind ( client1, 200 ) (  )   // Saldo =  400     Kasia wzięła 200   Zostało: 200

        const client2 = { name: 'Basia', balance: 1500 }

        getCash.bind ( client2, 100 ) (  )   // !!! Saldo =  1500   Basia wzięła 100   Zostało: 1400

        getCash.bind ( client1, 200 ) (  )   // Saldo =  200      Kasia wzięła 200   Zostało: 0

______________________________________________________________________________________________
178) OOP - module pattern

        var Alert = ( function ( ) {
            var messages = [ ]
            return {
                add: function ( message ) {
                    messages.push ( message )
                },
                log: function() {
                    console.log ( messages )
                }
            }
        } ) ( )

        Alert.add('hello')
        Alert.add('there')
        Alert.log()             // [ 'hello', 'there' ]
______________________________________________________________________________________________
179) OOP - factory function

      Tworzy interfejs do robienia obiektów
      Nie wymaga konstruktora, wystarcza wywołanie funkcji
      Nie potrzeba new do zrobienia obiektu

      var Person = (fname, lname) => {
          return  {
            fname,                              // ES6 skrót, zamiast 'fname: fname'
            lname,
            getName: () => fname + ' ' + lname  // ES6 skrót zamiast: function() { return this.fname + '  ' + this.lname }
          }
      }

      var klosiak = Object.create(Person( 'Hans', 'Kloss'))

      console.log(klosiak.fname)          // Hans
      console.log(klosiak.getName())  // Hans Kloss
-------------------------------------------------------------------------

        Factory - dziedziczenie

        function Zwirze(nazwa, kolor) {
          return {
            nazwa: nazwa,
            kolor: kolor,
            gadaj: function() {
                console.log('Jestem ' + this.nazwa + '  ' +this.kolor )
            }
          }
        }

        function Krulik(imie) {
            var krulik = Zwirze('krulik', 'bialy')

            krulik.skakaj = function() {
                this.gadaj()
                console.log('Zwę się ' + imie + ' i skakam !')   // Jestem krulik  bialy   Zwę się kicaj i skakam !
            }

            return krulik
        }

        var kicaj = Krulik('kicaj')
        kicaj.skakaj()  // Jestem krulik  bialy   I skakam !

______________________________________________________________________________________________
180) OOP - factory i Object.create( )

      function Person(imie, wiek) {
        return {
          imie,
          wiek,
          gadaj: function() {
            return  this.imie  + ' ' + this.wiek
          }
        }
      }

      var czesiu = Object.create(Person('Czesiek', 12))
      console.log( czesiu.gadaj() )   // Czesiek 12
______________________________________________________________________________________________
182) OOP - Object.defineProperty

      Ogranicza modyfikowalność propertasa

      var x = {
          imie: 'Ziutek',
          miasto: 'Warszawa'
      }

      console.log( x.miasto )   // Warszawa

      Object.defineProperty(x, "miasto", {
          writable: true,    // jeśli false, to Warszawa   Gdynia   Gdynia
          value: 'Gdynia'
      })

      console.log( x.miasto )   //  Gdynia

      x.miasto = 'Poznań'
      console.log( x.miasto )   //  Poznań
______________________________________________________________________________________________
183) OOP - programowe tworzenie obiektu

        stackoverflow.com/questions/2241875/how-to-create-an-object-property-from-a-variable-value-in-JS

        a) z dwu zmiennych
                    var x =  {  }

                    var aKey = 'id'
                    var aValue = 1320

                    var bKey = 'name'
                    var bValue = 'Ziutek'

                ES5:
                    x [ aKey ]  = aValue
                    x [ bKey ]  = bValue

                    console.log( x )   // { id: 1320, name: 'Ziutek' }

                ES6:
                    var x = { [ aKey ]: aValue }

                     console.log ( x )  // { id: 1320 }

       b)  z tablicy

                var arr =  [ 'Ania', 'Kasia', 'Wojtek' ]
                var arr2 =  [  ]

                arr.map ( function( item ) {
                   console.log( item )
                   arr2.push (  {  [ 'name' ]: item  }  )
                } )

                console.log( arr2 )  // [ { name: 'Ania' }, { name: 'Kasia' }, { name: 'Wojtek' } ]

     c) ES6

            let myKey = 'variableKey'

            let obj = {
                key1: 'One',
                key2: 'Two',
                [ myKey ]: 'Three'
            }

            console.log ( JSON.stringify ( obj ) )  // {"key1":"One","key2":"Two","variableKey":"Three"}

______________________________________________________________________________________________
184) OOP - metody klonowanie obiektu  ( object cloning )

        stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-JS

        Object.assign               43%  (fastest !)
        lodash deepClone            49%
        angular copy                61%
        JSON.parse(JSON.stringify (obj)) 83%
        jQuery extend               100%

        Corban Brook odpowiedź, polecana przez Johna Resiga:
        'In my previous tests where speed was a main concern I found:

        JSON.parse ( JSON.stringify ( obj ) )

        to be the fastest way to deep clone an object (it beats out jQuery.extend with deep flag set true by 10-20%).

        jQuery.extend is pretty fast when the deep flag is set to false (shallow clone).
        It is a good option, because it includes some extra logic for type validation
        and doesn't copy over undefined properties, etc., but this will also slow you down a little.

        If you know the structure of the objects you are trying to clone or can avoid deep nested arrays
        you can write a simple for (var i in obj) loop to clone your object while checking hasOwnProperty
        and it will be much much faster than jQuery.

        Lastly if you are attempting to clone a known object structure in a hot loop you can get
        MUCH MUCH MORE PERFORMANCE by simply in-lining the clone procedure and manually constructing the object.

        JS trace engines suck at optimizing for..in loops and checking hasOwnProperty will slow you down as well.
        Manual clone when speed is an absolute must.

        var clonedObject = {
          knownProp: obj.knownProp,
          ..
        }

        Beware using the JSON.parse(JSON.stringify(obj)) method on Date objects -
        JSON.stringify(new Date()) returns a string representation of the date in ISO format,
        which JSON.parse() doesn't convert back to a Date object. See this answer for more details.
______________________________________________________________________________________________
185) OOP - ćwiczenia

        Effective 68 Ways to Harness the Power: #18. Difference between Function,  Method and Constructor

        a) metoda obiektu jako funkcja zewnętrzna

            function mow ( ) {
                console.log( this.cos )
            }

            const jasiu =  {
                gadaj: mow,
                cos: 123
            }

            jasiu.gadaj (  )  //  123

        b) korzystanie z metody innego obiektu

            const jasiu =  {
                gadaj: function  ( ) {
                    return this.miasto
                },
                miasto: 'Warszawa'
            }

            const ziutek =  {
                krzycz: jasiu.gadaj,
                miasto:  'Łódź'
            }

            console.log( ziutek.krzycz (  )  )    // Łódź
______________________________________________________________________________________________
190) Best practices - clean code JS

      github.com/ryanmcdermott/clean-code-JS

      1) Variables
          1.1) Use meaningful and pronounceable variable names:
            1.2) Use the same vocabulary for the same type of variable
            1.3) Use searchable names
            1.4) Use explanatory variables
            1.5) Avoid mental mapping
            1.6) Don't add unneeded context
            1.7) Short-circuiting is cleaner than conditionals

      2) Functions
          2.1) Function arguments (2 or fewer ideally)
            2.2) Functions should do one thing
            2.3) Function names should say what they do
            2.4) Functions should only be one level of abstraction
            2.5) Remove duplicate code
            2.6) Use default arguments instead of short circuiting
            2.7) Set default objects with Object.assign
            2.8) Don't use flags as function parameters
            2.9) Avoid Side Effects
            2.10) Don't write to global functions
            2.11) Favor functional programming over imperative programming
            2.12) Encapsulate conditionals
            2.13) Avoid negative conditionals
            2.14) Avoid conditionals (w klasach)
            2.15) Avoid type-checking (use TS if you must)
            2.16) Dont overoptimize
            2.17) Remove dead code

      3) Objects and data structures
              3.1) Use getters and setters  ( encapsulation )
              3.2) Make objects have private members  ( via closures )

      4) Classes
              4.1) Single Responsibility Principle
              4.2) Open/Closed Principle (OCP)
              4.3)  Liskov Substitution Principle (LSP)
              4.4) Dependency Inversion Principle (DIP)
              4.5) Use method chaining
              4.6) Prefer composition over inheritance

      5) Testing  -  Single concept per test

      6) Concurrency  - Use Promises, not callbacks. Async/Await are even cleaner than Promises

      7) Error Handling
              7.1) Dont ignore caught errors
              7.2) Dont ignore rejected promises

      8) Formatting - Function callers and callees should be close

      9) Commenting
              9.1) Don't leave commented out code in your codebase
              9.2) Comments
              9.3) Don't have journal comments
              9.4) Avoid positional markers



  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
1) Variables

    1.1) Use meaningful and pronounceable variable names:

            Bad:
              const yyyymmdstr = moment().format('YYYY/MM/DD')

            Good:
                const yearMonthDay = moment().format('YYYY/MM/DD')

     1.2) Use the same vocabulary for the same type of variable

             Bad:
                getUserInfo()
                getClientData()
                getCustomerRecord()

            Good:
                getUser()

     1.3) Use searchable names

                Bad:
                    // What the heck is 525600 for?
                    for (let i = 0 i < 525600 i++) {
                      runCronJob()
                    }

                Good:
                    // Declare them as capitalized `const` globals.
                    const MINUTES_IN_A_YEAR = 525600

                    for (let i = 0 i < MINUTES_IN_A_YEAR i++) {
                      runCronJob()
                    }

      1.4) Use explanatory variables

                Bad:
                    const cityStateRegex = /^(.+)[,\\s]+(.+?)\s*(\d{5})?$/
                    saveCityState(cityStateRegex.match(cityStateRegex)[1], cityStateRegex.match(cityStateRegex)[2])

                Good:
                    const cityStateRegex = /^(.+)[,\\s]+(.+?)\s*(\d{5})?$/
                    const match = cityStateRegex.match(cityStateRegex)
                    const city = match[1]
                    const state = match[2]
                    saveCityState(city, state)

       1.5) Avoid mental mapping

                Explicit is better than implicit.

                Bad:
                    const locations = ['Austin', 'New York', 'San Francisco']
                    locations.forEach((l) => {
                      doStuff()
                      doSomeOtherStuff()
                      // ...
                      // Wait, what is `l` for again?
                      dispatch(l)
                    })

                Good:
                    const locations = ['Austin', 'New York', 'San Francisco']
                    locations.forEach((location) => {
                      doStuff()
                      doSomeOtherStuff()
                      // ...
                      dispatch(location)
                    })

       1.6) Don't add unneeded context

               If your class/object name tells you something, don't repeat that in your variable name.

               Bad:
                   const Car = {
                     carMake: 'Honda',
                     carModel: 'Accord',
                     carColor: 'Blue'
                   }

                   function paintCar(car) {
                     car.carColor = 'Red'
                   }

               Good:
                   const Car = {
                     make: 'Honda',
                     model: 'Accord',
                     color: 'Blue'
                   }

                   function paintCar(car) {
                     car.color = 'Red'
                   }

       1.7) Short-circuiting is cleaner than conditionals

                   Bad:
                       function createMicrobrewery(name) {
                         let breweryName
                         if (name) {
                           breweryName = name
                         } else {
                           breweryName = 'Hipster Brew Co.'
                         }
                       }

                   Good:
                       function createMicrobrewery(name) {
                         const breweryName = name || 'Hipster Brew Co.'
                       }

2) Functions

       2.1) Function arguments (2 or fewer ideally)

            Bad:
                function createMenu(title, body, buttonText, cancellable)

            Good:
                const menuConfig = {
                  title: 'Foo',
                  body: 'Bar',
                  buttonText: 'Baz',
                  cancellable: true
                }

                function createMenu(config)

       2.2) Functions should do one thing

                Bad:
                    function emailClients(clients) {
                      clients.forEach(client => {
                        const clientRecord = database.lookup(client)
                        if (clientRecord.isActive()) {
                          email(client)
                        }
                      })
                    }

                Good:
                    function emailClients(clients) {
                      clients
                        .filter(isClientActive)
                        .forEach(email)
                    }

                    function isClientActive(client) {
                      const clientRecord = database.lookup(client)
                      return clientRecord.isActive()
                    }

       2.3) Function names should say what they do

                Bad:
                    function dateAdd(date, month) {  ... }

                    const date = new Date()

                    // It's hard to to tell from the function name what is added
                    dateAdd(date, 1)

                Good:
                    function dateAddMonth(date, month) {  ... }

                    const date = new Date()
                    dateAddMonth(date, 1)

       2.4) Functions should only be one level of abstraction

       2.5) Remove duplicate code

       2.6) Use default arguments instead of short circuiting

               Bad:
                   function writeForumComment(subject, body) {
                     subject = subject || 'No Subject'
                     body = body || 'No text'
                   }

               Good:
                   function writeForumComment(subject = 'No subject', body = 'No text')

       2.7) Set default objects with Object.assign

               Bad:
                   const menuConfig = {
                     title: null,
                     body: 'Bar',
                     buttonText: null,
                     cancellable: true
                   }

                   function createMenu(config) {
                     config.title = config.title || 'Foo'
                     config.body = config.body || 'Bar'
                     config.buttonText = config.buttonText || 'Baz'
                     config.cancellable = config.cancellable === undefined ? config.cancellable : true
                   }

                    createMenu(menuConfig)

               Good:
                   const menuConfig = {
                     title: 'Order',
                     // User did not include 'body' key
                     buttonText: 'Send',
                     cancellable: true
                   }

                   function createMenu(config) {
                     config = Object.assign({
                       title: 'Foo',
                       body: 'Bar',
                       buttonText: 'Baz',
                       cancellable: true
                     }, config)

                     // config now equals: {title: "Order", body: "Bar", buttonText: "Send", cancellable: true}
                   }

                   createMenu(menuConfig)

       2.8) Don't use flags as function parameters

                Flags tell your user that this function does more than one thing. Functions should do one thing. Split out your functions if they are following different code paths based on a boolean.

                Bad:
                    function createFile(name, temp) {
                      if (temp) {
                        fs.create('./temp/' + name)
                      } else {
                        fs.create(name)
                      }
                    }

                Good:
                    function createFile(name) {
                      fs.create(name)
                    }

                    function createTempFile(name) {
                      createFile('./temp/' + name)
                    }

       2.9) Avoid Side Effects

                A function produces a side effect if it does anything other than take a value in and return another value or values. A side effect could be writing to a file, modifying some global variable, or accidentally wiring all your money to a stranger.

                Now, you do need to have side effects in a program on occasion. Like the previous example, you might need to write to a file. What you want to do is to centralize where you are doing this. Don't have several functions and classes that write to a particular file. Have one service that does it. One and only one.

                The main point is to avoid common pitfalls like sharing state between objects without any structure, using mutable data types that can be written to by anything, and not centralizing where your side effects occur. If you can do this, you will be happier than the vast majority of other programmers.

                Bad:
                    // Global variable referenced by following function.
                    // If we had another function that used this name, now it'd be an array and it could break it.
                    let name = 'Ryan McDermott'

                    function splitIntoFirstAndLastName() {
                      name = name.split(' ')
                    }

                    splitIntoFirstAndLastName()

                    console.log(name)     // ['Ryan', 'McDermott']

                Good:
                    function splitIntoFirstAndLastName(name) {
                      return name.split(' ')
                    }

                    const name = 'Ryan McDermott'
                    const newName = splitIntoFirstAndLastName(name)

                    console.log(name)            // 'Ryan McDermott'
                    console.log(newName)     // ['Ryan', 'McDermott']

       2.10) Don't write to global functions

       2.11) Favor functional programming over imperative programming

                Functional languages are cleaner and easier to test. Favor this style of programming when you can.

                    Bad:
                        for (let i = 0 i < programmerOutput.length i++) {
                          totalOutput += programmerOutput[i].linesOfCode
                        }

                    Good:
                        const totalOutput = programmerOutput
                          .map((programmer) => programmer.linesOfCode)
                          .reduce((acc, linesOfCode) => acc + linesOfCode, 0)

       2.12) Encapsulate conditionals

                    Bad:
                        if (fsm.state === 'fetching' && isEmpty(listNode))

                    Good:
                        function shouldShowSpinner(fsm, listNode) {
                          return fsm.state === 'fetching' && isEmpty(listNode)
                        }

                        if (shouldShowSpinner(fsmInstance, listNodeInstance)) { }

        2.13) Avoid negative conditionals

                    Bad:
                        function isDOMNodeNotPresent(node) { ..   }
                        if (!isDOMNodeNotPresent(node)) { ..   }

                    Good:
                        function isDOMNodePresent(node) { ... }
                        if (isDOMNodePresent(node)) {  }

        2.14) Avoid conditionals  ( w klasach )

        2.15) Avoid type-checking  ( use TS if you must )

        2.16) Dont overoptimize

                    Modern browsers do a lot of optimization under-the-hood at runtime. A lot of times, if you are optimizing then you are just wasting your time. There are good resources for seeing where optimization is lacking. Target those in the meantime, until they are fixed if they can be.

                    Bad:
                        // On old browsers, each iteration with uncached `list.length` would be costly
                        // because of `list.length` recomputation. In modern browsers, this is optimized.
                        for (let i = 0, len = list.length i < len i++) {  ...   }

                    Good:
                        for (let i = 0 i < list.length i++) { ..  }

        2.17) Remove dead code

3) Objects and Data Structures

        3.1) Use getters and setters  ( encapsulation )
        3.2) Make objects have private members  ( via closures )

4) Classes

        4.1) Single Responsibility Principle

        4.2) Open/Closed Principle (OCP)
                    Classes, modules, functions, etc. should be open for extension, but closed for modification

        4.3)  Liskov Substitution Principle (LSP)
                    Można używać zamiennie parent i child klasy  ( OOP grubsza mątwa )

        4.4) Dependency Inversion Principle (DIP)
                    Podobny do Dependency Injection  ( DI  - patrz angular OOP grubsza mątwa )

        4.5) Use method chaining

        4.6) Prefer composition over inheritance

5) Testing
        Single concept per test

6) Concurrency
        Use Promises, not callbacks. Async/Await are even cleaner than Promises

 7) Error Handling

        7.1) Dont ignore caught errors

                Bad:
                    try {
                      functionThatMightThrow()
                    }
                    catch (error) {
                      console.log(error)
                    }

                Good:
                    try {
                      functionThatMightThrow()
                    }
                    catch (error) {
                      // One option (more noisy than console.log):
                      console.error(error)
                      // Another option:
                      notifyUserOfError(error)
                      // Another option:
                      reportErrorToService(error)
                      // OR do all three!
                    }

        7.2) Dont ignore rejected promises

              Bad:
                  getdata()
                  .then(data => {
                    functionThatMightThrow(data)
                  })
                  .catch(error => {
                    console.log(error)
                  })

              Good:
                  getdata()
                  .then(data => {
                    functionThatMightThrow(data)
                  })
                  .catch(error => {
                    // One option (more noisy than console.log):
                    console.error(error)
                    // Another option:
                    notifyUserOfError(error)
                    // Another option:
                    reportErrorToService(error)
                    // OR do all three!
                  })

 8) Formatting

      8.1) Function callers and callees should be close

          If a function calls another, keep those functions vertically close in the source file.
          Ideally, keep the caller right above the callee.
          We tend to read code from top-to-bottom, like a newspaper. Because of this, make your code read that way.

 9) Commenting

        9.1) Don't leave commented out code in your codebase
                    Version control exists for a reason. Leave old code in your history.

        9.2) Comments

            Only comment things that have business logic complexity.
            Comments are an apology, not a requirement. Good code mostly documents itself.

            Bad:
                function hashIt(data) {
                  // The hash
                  let hash = 0

                  // Length of string
                  const length = data.length

                  // Loop through every character in data
                  for (let i = 0 i < length i++) {
                    // Get character code.
                    const char = data.charCodeAt(i)
                    // Make the hash
                    hash = ((hash << 5) - hash) + char
                    // Convert to 32-bit integer
                    hash &= hash
                  }
                }

            Good:
                function hashIt(data) {
                  let hash = 0
                  const length = data.length

                  for (let i = 0 i < length i++) {
                    const char = data.charCodeAt(i)
                    hash = ((hash << 5) - hash) + char

                    // Convert to 32-bit integer
                    hash &= hash
                  }
                }

        9.3) Don't have journal comments

            Remember, use version control!
            There's no need for dead code, commented code, and especially journal comments.
            Use git log to get history!

            Bad:
                /**
                  * 2016-12-20: Removed monads, didn't understand them (RM)
                  * 2016-10-01: Improved using special monads (JP)
                  * 2016-02-03: Removed type-checking (LI)
                  * 2015-03-14: Added combine with type-checking (JR)
                  */
                function combine(a, b) {
                  return a + b
                }

            Good:
                function combine(a, b) {
                  return a + b
                }

        9.4) Avoid positional markers

                They usually just add noise.
                Let the functions and variable names along with the proper indentation and formatting,
                give the visual structure to your code.

                Bad:
                    ////////////////////////////////////////////////////////////////////////////////
                    // Scope Model Instantiation
                    ////////////////////////////////////////////////////////////////////////////////
                    $scope.model = {
                      menu: 'foo',
                      nav: 'bar'
                    }

                    ////////////////////////////////////////////////////////////////////////////////
                    // Action setup
                    ////////////////////////////////////////////////////////////////////////////////
                    const actions = function() { ..  }

                Good:

                    $scope.model = {
                      menu: 'foo',
                      nav: 'bar'
                    }

                    const actions = function() {  ... }
______________________________________________________________________________________________
191) Best practices - V8 optimization killers

      https://github.com/petkaantonov/bluebird/wiki/Optimization-killers

      V8 zawiera 2 kompilatory: ogólny i optymalizujący.
      Poniżej jest lista konstrukcji językowych JS przy których kompilatór optymalizujący się nie włącza:

      Currently not optimizable:
        Functions that contain:
          generator
          for-of
          try-catch
          try-finally
          compound let assignment ( foo = foo + 1  szybsze niż  foo++  szybsze niż  foo += 1 )
          compound const assignment
          object literals that contain __proto__, or get or set declarations
          using function arguments object ( except arguments.length and arguments [ i ] )
          for-in  ( często propertki obiektu )

        Likely never optimizable:
          Functions that contain:
              debugger
              eval()
              with

______________________________________________________________________________________________
200) Design Patterns - Module: Classical

        Tuba - LearnAcademy:  ModularJS - Classical Inheritance

         Poniżej jest instantiation  -  robienie obiektów
         Dziedziczenie woła tak paskudną funkcję prototypa, że nie tnę go nawet kijem od kibla

        const Person = function ( name ) {
            this.name = name
        }

        Person.prototype.sayName = function (  ) {
            return 'Tu ' + this.name
        }

        let john = new Person ( 'john' )
        let bobby = new Person ( 'bobby' )

        console.log( john.name )
        console.log ( 'john.sayName (  ) = ',  john.sayName (  ) )

______________________________________________________________________________________________
201) Design Patterns - Module:  Revealing Module Pattern  ( IIFE )

      Tuba - LearnAcademy:  ModularJS -  Revealing Module Pattern

      var Module = ( function ( ) {
          var x = 'prywatna, niewidoczna z zewnątrz'

          var priv_1 = function() {                         // niewidoczna z zewn
              console.log( 'Tu metoda priv_1' )
          }

          var priv_2 = function() {
              console.log( 'Tu metoda priv_2' )
          }

          return {
              priv_1: priv_1,     // teraz publiczna, bo zwracana returnem w obiekcie
          }

      } ) ( )

      Module.priv_1 ( )   // Tu metoda priv_1
      Module.priv_2 ( )  //  err
______________________________________________________________________________________________
202) Design Patterns - Module:  Object Literal

      Tuba - LearnAcademy:  ModularJS - Object Literal

      Wada: wszystkie propertki i metody są dostępne

      let ziutek =  {
          name: 'ziutek',
          age: 12,
          sayName (  )  {
              return 'Tu ' + this.name
          }
      }

      console.log( ziutek.sayName (  ) )   // Tu ziutek

      ziutek.name = 'czesiek'
      console.log( ziutek.sayName (  ) )   // Tu czesiek

      ziutek.sayName = function (  ) {
          return 'Tu adolf'
      }

      console.log( ziutek.sayName (  ) )   // Tu adolf
______________________________________________________________________________________________
203) Design Patterns - Prototypal Inheritance ( OLOO )

      Tuba - LearnAcademy:  ModularJS - Prototypal vs Classical OOP

      addyosmani.com/largescaleJS/     ( Module, Facade, Mediator, Observer ( Pub/Sub ), AER )
-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
          let human =  {
            species: 'human',
            saySpecies: function (  ) {
                console.log( this.species )
            },
            sayName: function (  ) {
                console.log( this.name )
            }
          }

          let musician = Object.create ( human )

          musician.playInstrument = function (  ) {
            console.log( 'plays ...' + this.instrument )
          }

          var will =Object.create ( musician )
          will.name = 'Will'
          will.instrument = 'Drums'

          console.log( will )   // { name: 'Will', instrument: 'Drums' }
          will.playInstrument (  )   // plays ...Drums
          will.saySpecies (  )   // human

          human.species = 'dog'   // zmieniam prototyp ( parent ) , a zmieni się child
          will.saySpecies (  )   // dog

______________________________________________________________________________________________
204) Design Patterns - Module:  Extension

        var Module = (function() {

            var priv_1 = function(tresc) {
                console.log( tresc )
            }

            return {  priv_1: priv_1 }

        })()

        Module.priv_1('Treść gadki')   // Tu metoda priv_1


        // Tu Module zostanie rozszerzony o metodę .extension

        var ModuleTwo = (function(Module) {

            Module.extension = function() {
                console.log( 'Tu Module.extension' )
            }

            return Module

        })(Module || {} )

        Module.extension()   // Tu Module.extension
______________________________________________________________________________________________
205) Design Patterns - Module:  Extension - 2 pliki

        Stworzenie modułu z podstawowymi funkcjami - base.js
        Rozszerzenie go przez import i dodanie nowej funkcji - ext.js

----------------------- ./base.js -----------------------------------------

        exports.Module = (function() {

            var priv_1 = function(tresc) {
                console.log( tresc )
            }

            return {  priv_1: priv_1 }

        })()

----------------------- ./ext.js -----------------------------------------

        var base = require('./base')

        var ModuleTwo = (function(Module) {

            base.Module.extension = function() {
                console.log( 'Tu Module.extension' )
            }

            return base.Module

        }) ( base.Module || {} )

        base.Module.priv_1('Tu Module.priv_1')   // Tu Module.priv_1
        base.Module.extension()                         //   Tu Module.extension

______________________________________________________________________________________________
206) Design Patterns - Module:  naming convention

        Private = prefix _

        var Module = (function () {

          var _privateMethod = function () {
            // private stuff
          }

          var publicMethod = function () {
            _privateMethod()
          }

          return {
            publicMethod: publicMethod
          }

        })()
______________________________________________________________________________________________
207) Design Patterns - Chaining

        Tajemnica czejningu tkwi w tym by każda metoda zwracała obiekt (return this)

------------- Wersja - Funkcja -----------------------------------------------------

        var x = function() {
            this.i = 0

            this.add = function( i ) {
                this.i += i
                return this
            }

            this.substract = function( i ) {
                this.i -= i
                return this
            }

            this.print = function() {
                console.log( this.i )
            }
        }

        var y = new x()
        y.add( 13 ).substract( 8 ).print()  //  5

------------- Wersja - Reveal Module -----------------------------------------------------

        var x = function() {
            var j = 0

            var add = function( i ) {
                j += i
                return this
            }
            substract = function( i ) {
                j -= i
                return this
            }
            print = function() {
                console.log( j )
            }
            return {
                add: add,
                substract: substract,
                print: print
            }
        }

        var y = new x()
        y.add( 13 ).substract( 8 ).print()  //  5

______________________________________________________________________________________________
220) FP  ( Functional programming ) - założenia

        youtube.com/watch?v=e-5obm1G_FY
        hackernoon.com/how-i-rediscovered-my-love-for-javascript-after-throwing-90-of-it-in-the-trash-f1baed075d1b
        hackernoon.com/rethinking-javascript-death-of-the-for-loop-c431564c84a8
        hackernoon.com/rethinking-javascript-the-if-statement-b158a61cd6cb
        hackernoon.com/rethinking-javascript-eliminate-the-switch-statement-for-better-code-5c81c044716d
        hackernoon.com/functional-javascript-decoupling-methods-from-their-objects-aa3ca13d7ae8
        hackernoon.com/rethinking-javascript-break-is-the-goto-of-loops-51b27b1c85f8

          1) Higher Order Functions (funkcje jako argumenty funkcji, funkcje zwracające przez inne funkcje)
          2) Pure functions (nie powodujące efektów ubocznych, a więc niezależne od działań na plikach, db, serwerze)
          3) Lambdas (funkcje anonimowe)
          4) Immutable data
          5) Stateless programs (no shared state)


          W FP, dane powinny być niezmienne. W praktyce oznacza to że zamiast zmieniać istniejące
          dane, trzeba tworzyć nowe, oryginalne pozostawiając nie zmienione

          FP apki powinny być bezstanowe, tzn za każdym razem wykonywać się jak za pierwszym.
          Innymi słowy powinny ignorować przeszłość

          Apka w FP to:
            a) kombinacja pure functions
            b) unikająca współdzielenia stanu (stateless), mutowania danych i efektów ubocznych
            c) przeważa styl deklaratywny niż imperatywny (mówi się co chcę dostać, raczej niż jak, np pętla filter vs for )

          Pure functions:
            1) używają wyłącznie danych przekazanych im jako argumenty (nie globali, ani argumentów z wyższych scope'ów)
            2) .. dlatego są deterministyczne tzn dają zawsze ten sam wynik, (bo nie zależą od żadnych zewn czynników (np db czy network calls)
            3) nie powodują żadnych efektów ubocznych tzn nie modyfikują przekazanych im argumentów, db, neta czy DOMu
                (ewentualnie, zwracają nową tablicę czy obiekt - patrz map, filter, reduce, slice  )

          Efekty uboczne to wszystko co nie jest mapowaniem wartości wejściowych na wyjściowe.
          Są one częstym źródłem błędów i bez pure functions, nie wiadomo gdzie ich szukać
          Z pure functions, od razu wiadomo, że nie w pure functions

          Korzyści z FP:
            1) pure functions łatwiej analizuje (bo nie gadają ze światem zew, nie mają hidden inputs)
            2) łatwiej się je testuje
            3) łatwiej się je debuguje (bo operują tylko na danych zawartych w argumentach funkcji)
            4) sygnatury funkcji są bardziej miarodajne (wiadomo co do niej wchodzi i podlega przetwarzaniu)
            5) są łatwiej skalowalne
            6) łatwiej się je zrównolegla
            7) kontakt ze światem zewn (pliki, db, serwer), ma tylko wąska grupa wydzielonych funkcji
            8) wymaga mniej boilerplejtu niż głębokie hierarchie klas

          Class Inheritance:
            instances inherit from classes and create sub-class relationships: tight coupling
            Instances are typically instantiated via constructor functions with the `new` keyword.
            Class inheritance may or may not use the `class` keyword from ES6.

          Prototypal Inheritance:
            Instances inherit directly from other objects.
            Instances are typically instantiated via factory functions or `Object.create()`.
            Instances may be composed from many different objects, allowing for easy selective inheritance.
            Concatenative inheritance (Object.assign) , prototype delegation, functional inheritance, object composition

            Dziedziczenie prototypowe jest prostsze i bardziej eleastyczne od klasowego

            Highly OOP codebase can be extremely resistant to change and very brittle compared
            to an equivalent FP codebase

______________________________________________________________________________________________
221) FP - funkcje wyższego rzędu  ( HOF )

      Funkcja może przyjmować inną funkcję jako argument:
        function calc(fn, x, y)  { .. } - patrz poniższy przykład

      Może też zwracać funkcję:
        return fn (x, y) - patrz poniższy przykład

      -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

      function calc ( fn, x, y )  {
        return fn ( x, y )
      }

      const adding10 = a => a + 10
      let y = calc (adding10, 4)
      console.log(y)   //  14
______________________________________________________________________________________________

222) FP - przekazanie funkcji do funkcji  ( HOF )

        var a = [ 1, 2, 3, 4 ]
        var b = []

        function x( arr, fn ) {
            for ( var i = 0 i < arr.length i++ ) {
                b.push( fn( arr[ i ] ) )
            }
        }

        x( a, function( i ) { return i * 2 } )

        console.log( a )   //  [ 1, 2, 3, 4 ]
        console.log( b )  //   [ 2, 4, 6, 8 ]

        x( a, function( i ) {  return i > 2 ? i : false } )

        console.log( b )   // [ false, false, 3, 4 ]
_____________________________________________________________________________________________
223) FP - map-filter-reduce

        var arr = ['1', '1', 'foo', '2', '3', '5', 'bar', '8', '13' ]

        var result = arr
            .map ( x => parseInt ( x ) )    // [ 1, 1, NaN, 2, 3, 5, NaN, 8, 13 ]
            .filter ( x => !isNaN ( x ) )      //  [ 1, 1, 2, 3, 5, 8, 13 ]
            .reduce ( ( x, y ) => x + y )       //  33

        console.log( result )
______________________________________________________________________________________________
224) FP - zestaw funkcji pure i immutable

        gist.github.com/bendc/9b05735dfa6966859025#file-functional-utils-js-L4

        wecodetheweb.com/2016/02/12/immutable-JS-using-es6-and-beyond/
______________________________________________________________________________________________
225) FP - ES6: klonowanie obiektu

        wecodetheweb.com/2016/02/12/immutable-JS-using-es6-and-beyond/

        Problem:
            Obiekty  ( czyli i tablice przekazywane są przez referencję )

            const person =  {
                name: 'John',
                age: 22
            }

            const newPerson = person
            newPerson.age = 66

            console.log ( person )                              // { name: 'John', age: 66 }
            console.log ( newPerson )                      //  { name: 'John', age: 66 }
            console.log( newPerson === person )  //   true
 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
        Rozwiązanie 1:
            Zamiast:  const newPerson = person
            Użuj: const newPerson = Object.assign ({ }, person)

            const person =  {
              name: 'John',
              age: 22
            }

            const newPerson = Object.assign({ }, person)
            newPerson.age = 66

            // lub  let age = 66
            // const newPerson = Object.assign({ }, person, { age })

            console.log(person)                 // { name: 'John', age: 22 }
            console.log(newPerson)              //  { name: 'John', age: 66 }
            console.log(newPerson === person )  //  false

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

       Rozwiązanie 2:
           Zamiast:  const newPerson = person
           Użuj:       const newPerson = Object.assign (  {  }, person  )

           const person =  {
               name: 'John',
               age: 22
           }

           const newPerson =  {
                ...person,       // object spread  - stage 2 use Babel
                age: 30
           }

           console.log ( person )                              // { name: 'John', age: 22 }
           console.log ( newPerson )                      //  { name: 'John', age: 30 }
           console.log( newPerson === person )  //  false
______________________________________________________________________________________________
226) FP - ES6: usuwanie elementu obiektu

        wecodetheweb.com/2016/02/12/immutable-JS-using-es6-and-beyond/

        Ponieważ object spread jest dopiero w stage2, poniższe działa tylko w Bablu

        const person = {
          name: 'John',
          password: '123',
          age: 28
        }

        const newPerson = Object.keys ( person ).reduce ( ( obj, key ) => {

              if ( key !== property ) {
                return { ...obj, [ key ]: person [ key ] }
              }

              return obj
        }, { } )
______________________________________________________________________________________________
227) FP - ES6: tablice  ( CRUD )

        wecodetheweb.com/2016/02/12/immutable-JS-using-es6-and-beyond/

        Problem:
            const x =  [ 'Jan', 'Adam' ]
            const y =  x                 //  [ 'Jan', 'Adam' ]

            console.log ( y === x  )   //   true, wiec zmiana w y, zmieni też x

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
         Create  ( spread ) :

            const x =  [ 'Jan', 'Adam' ]
            const y =  [ ...x  ]                 //  [ 'Jan', 'Adam' ]

            console.log ( y === x  )   //   false

            y.push ( 'Zocha' )

            console.log( x )                // [ 'Jan', 'Adam ]
            console.log( y )                //  [ 'Jan', 'Adam', 'Zocha' ]

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
        Delete  ( filter ):

            const x =  [ 'Jan', 'Adam' ]
            const y =  x.filter ( item  => item !== 'Adam')

            console.log( x )                // [ 'Jan', 'Adam' ]
            console.log( y )                //  [ 'Jan' ]

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
        Update ( map ):

            const x =  [ 'Jan', 'Adam' ]
            const y =  x.map ( item  => item  === 'Adam' ? 'Ziutek' : item )

            console.log( x )                // [ 'Jan', 'Adam' ]
            console.log( y )                //  [ 'Jan', 'Ziutek' ]

            const y =  x.map ( item  => item.toUpperCase ( ) )  // [ 'JAN', 'ADAM' ]

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
        Merge ( spread ):

            const x =  [ 'Jan', 'Adam' ]
            const y =   [ 'Zocha', 'Krzys' ]
            const z =  [ ...x, ...y ]

            console.log( x )     // [ 'Jan', 'Adam' ]
            console.log( y )    //  [ 'Zocha', 'Krzys' ]
            console.log( z  )   //  [ 'Jan', 'Adam', 'Zocha', 'Krzys' ]
-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
       Sort ( slice ):

            const x =  [ 'Jan', 'Adam', 'Bartek' ]
            const y =  x.slice (  ).sort (  )   // bez slice'a, będzie to ta sama tablica

            console.log( x )     // [ 'Jan', 'Adam', 'Bartek' ]
            console.log( y )    //  [ 'Adam', 'Bartek', 'Jan' ]
______________________________________________________________________________________________

230) FP - curry

          'use strict'
          let curry = require('curry')

          /* Currying w zwykłym js'ie
          let plus = function (a) {
              return function (b) {
                  return a+b
              }
          }
          */

          //  Aletrnatywnie, currying w wersji z modułem curry node'a
          let plus = curry( function(a,b) { return a+b } )

          let plus4 = plus(4)
          console.log( plus4(8) )
______________________________________________________________________________________________
231) FP - RxJS

      reactivex.io/learnrx/

      The key to learning Rx is training yourself to use functional programming to manipulate collections.

      FP provides developers with the tools to abstract common collection operations into reusable,
      composable building blocks.

      You'll be surprised to learn that most of the operations you perform on collections
      can be accomplished with 5 simple functions (some native to JS and some included in RxJS library):

      map
      filter
      concatAll
      reduce
      zip
______________________________________________________________________________________________
232) FP - Ramda

        ramdajs.com/0.19.1/docs

        'use strict'
        var R = require('ramda')

        var cosTam = function(a,b) {
          return a * 2 + b
        }

        var f1 = R.pipe(Math.pow, R.negate, R.inc)
        var f2 = R.pipe(cosTam, R.negate, R.inc)

        console.log( f1(2, 3) )    // 2 ^ 3 = 8  * (-1) + 1 = -7
        console.log( f2(2, 3) )    // -6
______________________________________________________________________________________________
233) FP - Ramda: pipe - user functions

          'use strict'
          var R = require('ramda')

          function podwoj( a ) {  return a * 2 }

          function odejmij2( a ) { return a-2 }

          function dopiszSlowo(a) { return a+'slowo' }

          var f2 = R.pipe(podwoj, odejmij2, dopiszSlowo)

          console.log( f2(3) )    // 4slowo
______________________________________________________________________________________________
234) FP - deepFreeze (slice)

        npm i -s deep-freeze-strict
-----------------------------------------------------------------
        var deepFreeze = require('deep-freeze-strict')

        var a = [ 1, 2, 4, 5 ]
        deepFreeze(a)           // zamrożenie tablicy a

        var change = function(index) {

            return  a.slice(0, index)
                        .concat([3])
                        .concat(a.slice( index, a.length) )
        }

        console.log(change(2))
______________________________________________________________________________________________
240) Regex - links

      Najlepszy:
          lynda.com/Regular-Expressions-tutorials/Using-Regular-Expressions/85870-2.html
          i zawarty w nim ..\Exercise Files\regexpal\index.html

      Nauka:
          regexone.com  -  interaktywne lekcje
          tryregex.com
          codecademy.com/courses/JS-intermediate-en-NJ7Lr/0/1
          rexegg.com

      Gra
          regexcrossword.com/howtoplay

        Video:
          lynda.com/Regular-Expressions-tutorials/Using-Regular-Expressions/85870-2.html
          codeschool.com/courses/breaking-the-ice-with-regular-expressions

      Testery z cheatsheetami:
          regex101.com
          egexr.com
          regextester.com
          regexpal.com
          debuggex.com/#cheatsheet
          debuggex.com/cheatsheet/regex/JS

______________________________________________________________________________________________
241) Regex - cheatsheet

      https://regexone.com/lesson/repeating_characters?

      UWAGA !
          Uważaj na nadwyżkowe albo i brakujące spacje
          Nadwyżkowe często chodzą na końcu linii w Sublimie


      abc…    Letters
      123…    Digits
      \d      Any Digit
      \D      Any Non-digit character
      .       Any Character
      \.      Period
      [abc]   Only a, b, or c
      [^abc]  Not a, b, nor c
      [a-z]   Characters a to z
      [0-9]   Numbers 0 to 9
      \w      Any Alphanumeric character
      \W      Any Non-alphanumeric character
      {m} m   Repetitions
      {m,n}   m to n Repetitions
      *       Zero or more repetitions
      +       One or more repetitions
      ?       Optional character
      \s      Any Whitespace  ( \t,  \n,  \r lub puste )
      \S      Any Non-whitespace character
      ^…$     Starts and ends
      (…)     Capture Group
      (a(bc)) Capture Sub-group
      (.*)    Capture all
      (abc|def)  Matches abc or def
______________________________________________________________________________________________
242) Regex  -  Sublime

        a) ctrl + f
        b) włącz RegEx  ( ikona gwiazdki: 1-sza z lewej )
        c) włącz Wrap'a  ( 4ty z lewej) )
        d) wyłacz InSelection  ( 5ty z lewej )
______________________________________________________________________________________________
243) Regex - ^ i $

        Wymagają odpowiednio, by linia tekstu:
        ^  -  zaczynała się od określonego wzorca  ( regexa )
        $  -  kończyła się określonym wzorcem  ( regexem )
        Nawet spacja się liczy tzn wpływa na zgodność ze wzorcem

        Tekst: _dupa
        RegEx: ^dupa
        Wynik:  ( nic )   // bo na początku linii jest _ a miało być d(upa)

        Tekst: 123 dupa
        RegEx: dupa$
        Wynik:  dupa   // bo na początku linii może być cokolwiek, ważne by po dupie już nic nie było

        Tekst:  dupa
        RegEx: ^dupa$
        Wynik: (nic)    // bo na początku linii jest tabulacja a linia mogła składać się wyłącznie z: dupa

        Tekst:  dupa
                dupa
                dupa

        RegEx: ^dupa$
        Wynik: dupa      // przy multiline anchors włączonym, bo wtedy wzorzec stosuje się do każdej linii z osobna
                    ( nic )    //  przy multiline anchors wYłączonym, bo wtedy wzorzec stosuje się do wszystkich linii  ( uznaje się je za jedną )

______________________________________________________________________________________________
244) Regex - greedy vs lazy

        Lynda Regex course  ( see above ): 4.3 i 4.4

        Silnik regexowy parsuje litera po literze tekstu i za każdą literą
        porównuje ze wzorcem  ( regexem )

        Domyślnie, silnik regexowy pracuje w trybie greedy - zmatchuj ile się da,
        czyli do ostatniego wystąpienia.

        Ale można go przestawić w tryb lazy - zmatchuj tak mało jak się da
        czyli do 1-go wystąpienia

        Czyni się to dodając znak zapytania przed wyrażeniem powtarzającym ( *  +  ? )
        Innymi słowy, znak zapytania czyni poprzedzającą go gwiadkę lub plusa  - leniwym

        Tekst:  123333333333456
        RegEx: .*3
        Wynik:  123333333333             // bo domyślnie jest greedy

        Tekst:  123333333333456
        RegEx: .*?3
        Wynik:  123                            // czyli do pierwszego wystąpienia 3-ki  (  ) lazy

        Tekst: applesssssss
        RegEx: apples?
        Wynik:  apples

        Tekst: applesssssss
        RegEx: apples??
        Wynik: apple

        Tekst: "Milton", "Waddams", "Initech"
        Regex: ".+",
        Wynik: "Milton", "Waddams",

        Tekst: "Milton", "Waddams", "Initech"
        Regex: ".+?",
        Wynik: "Milton",

        Tekst: peanutbutter
        Regex: peanut(butter)?
        Wynik: peanutbutter    // bo jest greedy - chce pokazać więcej

        Nie da się powiedzieć,  że greedy jest szybszy czy wolniejszy od lazy

______________________________________________________________________________________________
245) Regex - in JS 'match' command

      var x = 'Page 266'
      var y = x.match ( /.*[0-9]/ )   // greedy - wyłapuje każdego matcha
      console.log( y )               //  [ 'Page 266', index: 0, input: 'Page 266' ]

      var y = x.match ( /.*?[0-9]/ )  // lazy - wyłapuje tylko pierwszego matcha
      console.log( y )               //  [ 'Page 2', index: 0, input: 'Page 266' ]
______________________________________________________________________________________________
246) Regex - grouping

       Lynda Regex course  ( see above ): 5.1

        Nawiasy okrągłe umożliwiają wyłapanie powtórek lub zwiększenie czytelnosci

        Tekst:  independent dependent
        Regex:  (in)?dependent
        Wynik:  independent dependent

        Tekst:  abc abcabcabc
        Regex:  (abc)+
        Wynik:  abc abcabcabc

        Tekst:  A1B2C3D4E5F6G7H8I9J0
        Regex1:   [A-Z][0-9]
        Wynik:  zaznacza każdy znak pojedyńczo  ( przy czekniętym boksie Global )

        Tekst:  A1B2C3D4E5F6G7H8I9J0
        Regex2:   ([A-Z][0-9])
        Wynik:  jak wyżej. dodanie nawiasu nic nie zmieniło

        Tekst:  A1B2C3D4E5F6G7H8I9J0
        Regex3:   ([A-Z][0-9])+
        Wynik:  A1B2C3D4E5F6G7H8I9J0   // zaznaczyło całego stringa

        run(s)?    da to samo, co   runs?  , ale jest czytelniejsze
______________________________________________________________________________________________
247) Regex - OR

       Lynda Regex course  ( see above ): 5.2, 5.3

       Tekst:  weird wierd
       Regex:   w(ei|ie)rd
       Wynik:  jak wyżej. dodanie nawiasu nic nie zmieniło

       Tekst:  peanutbutter
       Regex: (peanut|peanutbutter)
       Wynik:  peanut      // priorytet ma match położony wcześniej  ( od lewej )

       Tekst:  abcdefghi    // wyłącz czekboksa Global
       Regex: abc|def|ghi
       Wynik:  abc

       Tekst:  abcdefghi     // wyłącz czekboksa Global
       Regex: ghi|abc|def
       Wynik: abc               // kolejność elementów OR'a nie ma znaczenia
                                       // bo silnik parsuje po kolejnych literach i porównuje je
                                       // z regexem, a nie odwrotnie

       Performance tip:  umieszczaj bardziej szczegółowe regexy na początku.
       Np:  dupa|\w+   zamiast w+|dupa
______________________________________________________________________________________________
248) Regex - word boundaries

       Lynda Regex course  ( see above ): 6.3

       \b  -  wykrywa granicę worda  ( \w ) czyli coś spoza  [a-zA-z0-9_]
       tzn coś innego niż litera,  albo cyfra albo underscore

       Tekst: This is a text
       Regex: \b\w+\b
       Wynik: Thisisatext    // 4 elementy z których składa się ten tekst ale bez spacji

       Tekst: This is a text
       Regex: \b\w\b
       Wynik: a    // bo tylko 'a' ma na końcu i początku granicę słowa a w środku 1 słowo

       Tekst: top-notch
       Regex: \b\w+\b
       Wynik: top   // bo średnik to nie słowo,  a więc granica ( słowa )

       Tekst: apples and oranges
       Regex: apples \band \boranges
       Wynik: apples and oranges

       Tekst: apples and oranges
       Regex: apples\band\boranges
       Wynik:     // nic, bo spacja nie jest w samym regeksie word boundary
                      // \b oznacza tylko miejsce przełączeniea z word'a na non-worda  ( word boundary )
______________________________________________________________________________________________
249) Regex - backreferences

        Lynda Regex course ( see above ): 7.1 do 7.4

        Po wzięciu regexa w nawias, można się nim w dalszej jego części posłużyć

        Tekst: apples to apples
        Regex:  (apples) to \1
        Wynik: apples to apples

        \1 mówi: weź to co znajdziesz w 1-szym nawiasie i podstaw za mnie
        Zwykle dostępnych jest 9 back referensów:  od \1 do \9

        Tekst:   apples to grapes and grapes
        Regex: (apples) to (grapes) and \2
        Wynik: apples to grapes and grapes

        Tekst:   abcdefefcdab
        Regex: (ab)(cd)(ef)\3\2\1
        Wynik: abcdefefcdab

        Tekst:   <i>Hello</i>
        Regex: <(i|em)>.+</\1>
        Wynik: <i>Hello</i>        // zmeczuje rtównież <em>Hello</em>

        Tekst:   <i>Hello</i> <em>Hello</em>  // spacja w środku
        Regex: <(i|em)>.+?</\1>                         // dzięki ?  (  = lazy )  ..
        Wynik: <i>Hello</i><em>Hello</em>  // .. zmeczuje bez spacji w środku

        Tekst: Steve Smith, John Johnson, Eric Erikson, Evan Evanson
        Regex: ([A-Z][a-z]+)\s\1son
        Wynik: John JohnsonEvan Evanson

        Tekst:   Paris in the
                    the spring
        Regex: (\w+)\s+\1
        Wynik: the the                   // zwraca zdublowane (jedno po drugim) słowa
______________________________________________________________________________________________
250) Regex - positive lookehead

      Lynda Regex course ( see above ): 8.1

      Wyraża się przez: ?=
      W regeksie, umieszcza się go w nawiasie, a tuż za nim, właściwego regeksa
      Positive lookeahead polega na sprawdzeniu, czy wyrażenie następujace zaraz za nim jest spełnione
      i dopiero sprawdza wyrażenie właściwe  ( taki 'if' )

      a)
      Tekst:  seashore seaside
      Regex:  (?=seashore)sea   // patrzy czy wyraz to seashore i dopiero jeśli tak, szuka w nim sea
      Wynik: seashore

      b)
      Tekst:  seashore seaside
      Regex: sea(?=shore)    // nie meczuj 'shore', sprawdź tylko czy jest  ( its captured, not matched )
      Wynik: sea                   // ten od seashore

      W a) silnik sprawdza cały wyraz litera po literze i jeśli znajdzie 'seashore', wraca na początek i szuka 'sea'
      W b) silnik szuka 'sea' i jak znajdzie sprawdza pozostałe litery czy tworzą 'shore'
      Czyli w 1-szym przypadku silnik robi 2 przebiegi, a w drugim 1
      Ma to wpływ na wydajność  ( czas ) wykonania, ale też a) daje możliwość potokowania regeksów ( patrz 352 )

      Tekst:  Commands all light, all influence, all fate
      Regex: \w+'?(?=,)         // sprawdź czy jest przecinek, ale go nie uwzględniaj
      Wynik: lightinfluence
______________________________________________________________________________________________
251) Regex - positive lookehead: double testing

      Lynda Regex course ( see above ): 8.2

      Tekst:  555-302-4321  555-781-6978
      Regex: \d{3}-\d{3}-\d{4}                      // format nrów tel w Stanach
      Wynik: 555-302-4321555-781-6978


      Tekst:  555-302-4321
      Regex: ^[0-5\-]+$
      Wynik: 555-302-4321   // ale jeśli będzie na początku coś spoza 0-5 i myślnika, mecza nie będzie

      A teraz chcemy sprawdzić czy zachodzą oba warunki naraz  ( iloczyn )

      Robimy positive lookahead'a z pierwszym:
          (?=\d{3}-\d{3}-\d{4})
      .. a po nim dostawiamy drugi:
          [0-5/-]+

      Tekst: 555-302-4321
      Regex: (?=\d{3}-\d{3}-\d{4})[0-5/-]+
      Wynik: 555-302-4321

      Kolejność warunków nie ma znaczenia. Odwrotny też chodzi:
      (?=[0-5/-]+)\d{3}-\d{3}-\d{4}

______________________________________________________________________________________________
252) Regex - negative lookehead

      Lynda Regex course ( see above ): 8.3

      Wyraża się przez: ?!
      W regeksie, umieszcza się go w nawiasie, a tuż za nim, właściwego regeksa
      Jest odwrotnością  ( negacją ) positive lookeahead'a  ( patrz 352)
      Positive lookeahead polega na sprawdzeniu, czy wyrażenie następujace zaraz za nim jest NIE spełnione
      i dopiero sprawdza wyrażenie właściwe  ( taki 'if' )

      Tekst:  seashore seaside
      Regex: (?!seashore)sea
      Wynik: sea     // z seaside

      Tekst:  online training online courses
      Regex: online (?! training )
      Wynik: online     // to od courses,  bo poprzednie ma potem ' training'

      Tekst:  The black dog followed the black car into the black night
      Regex: black(?! dog )
      Wynik: black     // to od car i night, bo poprzednie ma potem ' car'

______________________________________________________________________________________________
245) JS Regex - summary

      Są 3 komendy: exec, match i test. Najprzydatniejsza jest match

      ---------------------------------------------------------

      const str = 'abc to ciąg liter abc'
      const re = /abc/g
      const regex = new RegExp(re)

      const res1 = regex.exec('abc to ciąg liter abc')

      console.log(res1)  //! [ 'abc',
                         //!    index: 0,
                         //!    input: 'abc to ciąg liter abc',
                         //!    groups: undefined ]

      const res2 = str.match(re)
      // console.log(res2)  //! [ 'abc', 'abc' ]

      const res3 = re.test(str)
      // console.log(res3)  //! true; słabsze indexOf

      const res4 = str.replace(re, 'CBA')
      console.log(res4)   //! CBA to ciąg liter CBA


______________________________________________________________________________________________
246) JS RegEx - {n}

      const str1 = 'googogo'
      const regex = /go{2}/gm

      console.log(str1.match(regex))  // [ 'goo' ]
______________________________________________________________________________________________
247) JS RegEx - (..)

      const regex = /(go){2}/gm
      const str1 = 'googogo'

      console.log(str1.match(regex))  // [ 'gogo' ]

______________________________________________________________________________________________
248) JS RegEx - | (lub)

      const str1 = 'xxjsxxcssjavascript'
      const regex = /css|js|cpp|java(script)?/gm

      console.log(str1.match(regex))  // [ 'js', 'css', 'javascript' ]

______________________________________________________________________________________________
249) JS RegEx - \w \W \d \D \s

      \w = matches any word character z zakresów: [a-zA-Z0-9_]

      const regex = /\w/g
      const str1 = 'JAVA_123 js !!!' // [ 'J', 'A', 'V', 'A', '_', '1', '2', '3', 'j', 's' ]

      console.log(str1.match(regex))

      \W - to odwrotność \w czyli wszystko tylko nie alfanumeryczne i _

      const regex = /\W/g  //  [ ' ', ' ', '!', '!', '!' ]

      \d = [0-9]
      \D = negacja \d - czyli wszystko prócz cyfr

      \s spacje
      \S wszystko prócz spacji
______________________________________________________________________________________________
250) JS - Regex - escapowanie znaków specjalnych

      Trzeba escapować pytajnik i kropkę
      Escapuje się przez poprzedzenie znaku backslashem

      const str1 = 'excl! ques? dot. hasz# maupa@' //! [ '!', '?', '.', '#', '@' ]
      const regex = /[!#@\?\.]/g

      console.log(str1.match(regex))

______________________________________________________________________________________________
251) JS Regex - grupy () $1,2.. - łatwe

      $n oznacza kolejny numer grupy (base 1) i stosuje się tylko w replace

      const str1 = '1-23-456-7890'
      const regex = /(\d{1})-(\d{2})-(\d{3})-(\d{4})/gm

      console.log(str1.replace(regex, 'kier:$2, miasto:$1 parafia:$4 chata:$2')) // ier:23, miasto:1 parafia:7890 chata:23
______________________________________________________________________________________________
252) JS Regex - grupy () $1,2.. - trudne


      const str1 = `Adam Adacki
                    Badam Babacki
                    Cadam Cadacki`

      const regex = /(\w+)\s(\w+)/gm

      console.log(str1.match(regex))

      console.log(str1.replace(regex, '$2 $1'))
      // Adacki Adam  Babacki Badam  Cadacki Cadam

______________________________________________________________________________________________
253) JS Regex - greedy / lazy

      Domyślnie, regex szuka najdłuższego ciągu spełniającego wzorzec
      Tzn jak znajdzie jakiś, to nie przestaje, tylko szuka dalej w nadziei na dłuższy

      By zadowolił się pierwszym znalezionym, trzeba mu we wzrocu dać pytajnik
      Trzeba go postawić za kwantyfikatorem, czyli: +, *, ?, {n}, {n, m}

      const str1 = `[Google] https://google.com [test]
                    [Costam] http://costam.com
                    [Sejs] http://sejs.com`

     a) greedy (bez pytajnika)
          const regex = /\[.*\]/gm  //  [ '[Google] https://google.com [test]', '[Costam]', '[Sejs]' ]

     b) lazy (z pytajnikiem)
          const regex = /\[.*?\]/gm  //  [ '[Google]', '[test]', '[Costam]', '[Sejs]' ]

      console.log(str1.match(regex))

______________________________________________________________________________________________
254) JS Regex - capture groups \cyfra

      Pozwala na użycie w asercji, stringa który już wystąpił. Np:

      znajdź ciągi złożone z powtarzających się 2+ wyrazów w poniższym zdaniu
      \1 oznacza zawartość pierwszego z nawiasów okrągłych, np (dupa)\1 = dupadupa

      const str1 = 'This is is some text eith double double words. Why why is it so so ?'

      const regex = /(\w+\s)\1/gm

      console.log(str1.match(regex))  // [ 'is is ', 'double double ', 'so so ' ]
______________________________________________________________________________________________
255) JS Regex - lookaheads

     a) positive:
          Meczuj string x, jeśli za nim jest string y
            x(?=y)

              const str1 = 'Zaiste ich retoryka była aż nadto parciana'
              const regex = /ich(?= retoryka)/gm   // [ 'ich' ]

              console.log(str1.match(regex))

     b) negative:
          Meczuj string x, jeśli za nim nie stoi string y
            x(?=y)

              const str1 = 'Zaiste ich retoryka była aż nadto parciana'
              const regex = /była(?! nadto)/gm  // [ 'była' ]

              console.log(str1.match(regex))
______________________________________________________________________________________________
256) JS Regex - lookbehind: positive

      Znajdź ciąg samych cyfr, które poprzedza 'koza'

      const str1 = 'koza42'

      const regex = /(?<=koza)\d+/ugm

      console.log(str1.match(regex))  // [ '42' ]

______________________________________________________________________________________________
257) JS Regex - lookbehind: negative

      Znajdź ciąg samych cyfr, których nie poprzedza 'koza'

        const str1 = 'koza42'
        const regex = /(?<!koza)\d+/gm

        console.log(str1.match(regex))  // [ '2' ]
______________________________________________________________________________________________
258) JS Regex - named groups

      By łatwiej było się połapać do czego służą poszczególne części regeksa

      const str = "2019-04-30";
      const regex = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;

      let groups = str.match(dateRegexp).groups

      console.log(groups.year) // 2019
      console.log(groups.month) // 04
      console.log(groups.day) // 30

______________________________________________________________________________________________
271) JS RegEx

        Składnia: /pattern/modifiers

        Np:
          /wwa/ig   - to wyrażenie regularne
          wwa      - to szukany wzorzec
          i        - to modyfikatór case-insensitive

        Modyfikatory:
          i - case-insensitive
          g - global match  ( znajdź wszystkie, a nie tylko 1-szy )
          m - multiline matching  ( ignoruj znak końca linii )

        Metody:
          match - zwraca matche jako ich tablicę
          exec  - zwraca 1-go matcha
          test  - zwraca true / false

______________________________________________________________________________________________
272) JS RegEx - match

      The match() method searches a string for a match against
      a regular expression and returns the matches, as an Array object.

        Returns null if no match is found

      Wzięcie stringa w slasze oznacza że jest on regexem\

      ^  -  oznacza że string zaczyna się od określonego znaku
      /i  - igonorowanie case'a
      /g - globalnie, czyli wszystkie wystąpienia, a nie tylko pierwsze

      console.log( "AaBaBa".match ( /B/ ) )      //  [ 'B', index: 2, input: 'AaBaBa' ]
      console.log( "AaBaBa".match ( /B/g ) )     //  [ 'B', 'B' ]
      console.log( "AaBaBaba".match ( /B/ig ) ) //   [ 'B', 'B', 'b' ]

__________________________________________________________________________________________
273) JS RegEx - exec

          var pattern = /B/i

          console.log(pattern.exec("AaBaBa"))  // [ 'B', index: 2, input: 'AaBaBa' ]
__________________________________________________________________________________________
274) JS RegEx - test

          Szuka patterna i zwraca true / false

          var pattern = /B/
          console.log( pattern.test("Abcdefg") )  // false

          var pattern = /B/i
          console.log( pattern.test("ABcdefg") )  // true

_____________________________________________________________
275) JS RegEx - string.replace

        Format jest taki:  / coś do replacka /
        To co ma replacnąć: [
        Trzeba poprzedzić: \  bo to znak specjalny
        Żeby wykosić wszytkie wystąpienia, trzeba dodać 'g' na końcu

        var napis =  '[ kicha ]'

        var czysty = napis.replace(/\[/g, "").replace(/\]/g, "")   // zamiast nawiasów kwadratowych robi spacje
_____________________________________________________________
276) JS RegEx - string.replace kodu pocztowego

          var regexKoduPocztowego = /[0-9]{2}-[0-9]{3}/
          formatted_address = formatted_address.replace(regexKoduPocztowego, "")

_____________________________________________________________

277) JS RegEx - walidacja daty

        Jeśli string ma 2 slasze, 8 cyfr i długość = 10 znaków,  to jest to data

        var a = "03/25/2015"

        console.log ( a.split ( '/' ).length  - 1 )                  // 2
        console.log ( a.replace(/[^0-9]/g,"" ).length )    // 8
        console.log( a.length )                                       // 10
______________________________________________________________________________________________
280) ESlint - instalacja w VS Code

        eslint.org/docs/rules/
        github.com/airbnb/javascript

        a) zainstaluj plugin Eslint i LintLens

        b) yarn global add eslint

        c) eslint --init  // wybierz AirBnB i JSON

        d) w głównym katalogu projektu, do utworzonego pliku .eslintrc, wklej poniższe

            {
              "extends": ["airbnb-base"],
              "parserOptions": {
                "ecmaVersion": 2018
              },
              "env": {
                "node": true,
                "browser": true,
                "es6": true
              },

              "rules": {
                "array-bracket-spacing": 0,
                "arrow-parens": 0,
                "brace-style": ["error", "stroustrup"],
                "computed-property-spacing": 0,
                "func-call-spacing": 0,
                "indent": ["error", 2],
                "linebreak-style": 0,
                "max-len": [1, 120, 2],
                "no-console": 0,
                "no-multiple-empty-lines": [1, { "max": 1 }],
                "no-plusplus": 0,
                "no-spaced-func": 0,
                "no-whitespace-before-property": 0,
                "semi": ["error", "never"],
                "space-in-parens": 0,
                "space-before-function-paren": 0,
                "spaced-comment": 0,
                "no-trailing-spaces": 2
              }
            }

        e) w głównym katalogu jakiegoś projektu, stwórz plik test.js a w nim tylko:
            a=5

        f) vs code powinien w dolnym pasku pokazać, że są 2 błędy
            jeśli nie pokazał, to odpal komende:
              eslint plik.js

        g) jak wywali 2 błedy, tzn ze jest ok (undefined variable i unused variable)

______________________________________________________________________________________________
281) ESlint  -  konfigurowanie

      eslint.org/docs/user-guide/configuring
      eslint.org/docs/user-guide/command-line-interface

      0) Tworzenie
          Z reki lub komendą:
            eslint --init

      1) Nazwa pliku konfiguracyjnego

          W formacie js:   .eslintrc.js
          W formacie JSON: .eslintrc.json  // Nie działa w eslint 3.12.2 !!

      2) Bebechy pliku konfiguracyjnego

          Plik jsonowy pozwala na używanie js-owych komentarzy

          By eslint ignorował określony katalog, w katalogu głównym projektu stwórz plik .eslintignore:
              **/*.js      -  zignorowane zostaną wszystkie pliki *.js
              **/*.spec.js - wszystkie *.spec.js

          #  ( hasz )  jest komentarzem w pliku .eslingignore
          !  ( wykrzyknik ) neguje linie, np:

              # Ignore built files except build/index.js
              build/*
              !build/index.js
______________________________________________________________________________________________
282) ESlint - konfiguracja: plik .eslintrc.js

      !! UWAGA
          Działa tylko .eslintrc.js  .json - nie   ( w eslint 3.12.2 )

       blog.JSing.com/2015/09/07/fine-tuning-airbnbs-eslint-config/

       Plik stworzony przez komende:
            eslint --init
        i wybraniu style guide'a AirBnB, używanie Reacta - yes i format pliku: JS

          module.exports = {
            "extends": "airbnb",
            "plugins": [
                "react",
                "jsx-a11y",
                "import"
            ]
          }

        Ww reguły AirBnB można zmodyfikować, dodając obiekt "rules", poniżej obiektu "extends"
         ( poniżej chodzący konfig z pliku  .eslintrc.js ):

            module.exports = {
              "extends": "airbnb-base",
              "installedESLint": true,
                  "rules": {
                    "max-len": [1, 120, 2, {ignoreComments: true}],
                    "semi": 0,
                    "no-console": 0,
                    "space-in-parens": 0,
                    "no-multiple-empty-lines": 0,
                    "space-before-function-paren": 0,
                    "no-whitespace-before-property": 0,
                    "computed-property-spacing": 0,
                    "func-call-spacing": 0,
                    "no-spaced-func": 0,
                    "array-bracket-spacing": 0,
                    "spaced-comment": 0
                  },
                  "plugins": [
                      "import"
                  ]
              }
______________________________________________________________________________________________
283) ESlint -  reguły

        eslint.org/docs/user-guide/configuring
        nodesource.com/blog/streamline-JS-development-with-eslint/

        a) wyłączenie eslinta w całym pliku

            Umieść u góry:
                /* eslint-disable */

        b) wyłączenie eslinta w bloku kodu

            /* eslint-disable no-alert, no-console */
                .. kod ..
            /* eslint-enable no-alert, no-console */

        c) wyłączenie wszystkich reguł eslinta w linii kodu

            alert('foo') // eslint-disable-line

            // eslint-disable-next-line
            alert('foo')

        d) wyłączenie danej reguły eslinta w linii kodu

            alert('foo') // eslint-disable-line no-alert, quotes, semi

            // eslint-disable-next-line no-alert, quotes, semi
            alert('foo')

        e) wartości reguł

            "rules": {
                "camelcase": 2

                   0 - rule is off
                   1 - warning
                   2 - error

        f) ignorowanie błedu

            Ignore warnings about global variables named var1 and var2
            /* global var1, var2 */

            /* eslint quotes: ["error", "single"] */

            var str = 'he said "I love node.js"' // Uses single quotes - error free!
            var str = "he said 'I love node.js'" // Uses double quotes - throws an error!

______________________________________________________________________________________________
284) ESlint  -  rozszerzanie i nadpisywanie reguł

      Change an inherited rule’s severity without changing its options:

        Base config: "eqeqeq": ["error", "allow-null"]
        Derived config: "eqeqeq": "warning"
        Resulting actual config: "eqeqeq": ["warning", "allow-null"]

      Override options for rules from base configurations:

        Base config: "quotes": ["error", "single", "avoid-escape"]
        Derived config: "quotes": ["error", "single"]
        Resulting actual config: "quotes": ["error", "single"]

______________________________________________________________________________________________
285) ESlint  - online validator i narzedzia

        eslint.org/demo/

        github.com/dustinspecker/awesome-eslint
______________________________________________________________________________________________
286) ESlint - autofixing

        W package.json umieść:
          {
            "scripts" : {
              "lint": "eslint **/*.js",
              "lint-fix": "eslint --fix **/*.js"
            }
          }

      ..  i odpal npm run lint-fix
______________________________________________________________________________________________
287) ESlint - ESLint-Formatter  ( Sublime plugin )

        a) upewnij się, że node chodzi z cmd line'a

        b) Preferences > Package Settings > ESLint Formatter > Settings - User:  wklej poniższe :

          {
            "node_path": {
              "windows": "node",
            },

            "local_eslint_path": {
              "windows": "./node_modules/eslint/bin/eslint.js",
            },

            "eslint_path": {
              "windows": "%APPDATA%/npm/node_modules/eslint/bin/eslint",
            },

            "config_path": "./",

            "format_on_save": false,

            "format_on_save_extensions": [
              "js",
              "jsx",
              "es",
              "es6",
              "babel"
            ],

            // logs eslint output messages to console when set to true
            "debug": true
          }

        c)  zdecyduj, czy chcesz, by formatowanie odbywało się przy każdym sejwie:
                "format_on_save": true,
             czy kiedy je odpalisz skrótem klawiatury  ( tak jest lepiej, bo format zabiera 2 - 3s )
                "format_on_save": false,

              UWAGA !!
                Przy odpalaniu skrótem, plik musi być wcześniej zasejwowany
______________________________________________________________________________________________
288) ESlint - troubleshooting

      1) W nowoutworzonym katalogu,  ESLint nie działa

          a) mkdir test1 && cd test1 && npm init -y

          b) eslint --init
                  > AirBnB > no React > JSON

          c) utwórz touch test.js

          d) wpisz doń tylko:
                  a = 5

          e) otwórz konsole Sublime'a  ( ctrl + `   lub View > Show Console )

          f) odpal ESLinta  ( Tools > ESLint  )

          g) zobacz errora:
                  Cannot find module 'eslint-plugin-import'

          h) zainstaluj inkryminowanego globalnie
                  npm i -g eslint-plugin-import

      2) .eslintrc.js działa z eslint 3.12.2, z .eslintrc.json - nie

      3)  Zbędny przecinek na końcu obiektu "rules" w .eslintrc.js

            Error:
              C:\Users\makn.MOBICAPL\AppData\Roaming\Sublime Text 3\Packages\ESLint\linter.js:54
                      numberWang((error.line + error.column.toString()).length),
                                                       ^
              TypeError: Cannot read property 'toString' of undefined

             Powód:
                "rules": {
                  "no-multiple-empy-lines": 0,
                },

      4)  Zbędna pusta linia na końcu obiektu "rules" w .eslintrc.js

            Powód:
               "rules": {
                 "no-multiple-empy-lines": 0

               },
______________________________________________________________________________________________
289) ESlint - prettier-eslint

      github.com/prettier/prettier-eslint

      Poprawia poprawki zrobione przez prettiera eslint -fix'em

      yarn prettier-eslint

      The problem
      The fix feature of eslint is pretty great and can auto-format/fix much of your code according to your ESLint config.
      prettier is a more powerful automatic formatter. One of the nice things about prettier is how opinionated it is.

      Unfortunately it's not opinionated enough and/or some opinions differ from my own.
      So after prettier formats the code, I start getting linting errors.

      This solution
      This formats your code via prettier, and then passes the result of that to eslint --fix.
      This way you can get the benefits of prettier's superior formatting capabilities,
      but also benefit from the configuration capabilities of eslint.

      For files with an extension of .css, .less, .scss, or .json this only runs prettier since eslint cannot process those.
______________________________________________________________________________________________
290) ESLint i Prettier w Vue

      a) yarn global add eslint

      b) yarn add eslint-plugin-vue eslint-config-prettier eslint-plugin-prettier

      c) vs code > zainstaluj pakiet ESlint

      d) vs code > zainstaluj pakiet Prettier - Code formatter

      e) vs code > Settings > wpisz: "editor.formatOnSave": true

      g) do package.json, dopisz:

          "eslint-check": "eslint --print-config .eslintrc.json | eslint-config-prettier-check"

      h) stwórz plik .prettier.json

          {
            "trailingComma": "es5",
            "tabWidth": 2,
            "printWidth": 200,
            "semi": false,
            "singleQuote": true,
            "trailingComma": "all",
            "bracketSpacing:": true,
            "arrowParens": "avoid",
            "htmlWhitespaceSensitivity": "strict",
            "endOfLine": "lf"
          }

      i) stwórz plik .eslintrc.js

          /* eslint-disable  */
          module.exports = {
            env: { node: true },
            extends: ['plugin:vue/recommended', '@vue/airbnb', 'prettier', 'plugin:prettier/recommended'],
            plugins: ['prettier'],
            root: true,
            rules: {
              'no-console': 0,
              'no-debugger': 'off',
              'array-bracket-spacing': 0,
              'array-callback-return': 'warn',
              'arrow-parens': 0,
              // 'brace-style': ['error', 'stroustrup', { allowSingleLine: true }],
              'computed-property-spacing': 0,
              // 'comma-dangle': ['error', 'only-multiline'],
              'consistent-return': 'off',
              'func-call-spacing': 0,
              'import/prefer-default-export': 'warn',
              // indent: ['error', 2],
              'linebreak-style': ['error', 'unix'],
              //'max-len': [1, 200, 1, { ignoreUrls: true, ignoreTrailingComments: true, ignoreTemplateLiterals: true }],
              'no-alert': 'off',
              // 'no-multiple-empty-lines': [1, { max: 1 }],
              'no-param-reassign': 'off',
              'no-plusplus': 0,
              'no-spaced-func': 0,
              'no-warning-comments': 'warn',
              'no-whitespace-before-property': 0,
              // 'no-trailing-spaces': 2,
              'prefer-destructuring': 'warn',
              'prefer-template': 'warn',
              'prettier/prettier': ['error'],
              // semi: ['error', 'never'],
              'space-in-parens': 0,
              'space-before-function-paren': 0,
              'spaced-comment': 0,
              //'vue/html-self-closing': 'never',
            },

            parserOptions: {
              parser: 'babel-eslint',
            },
          }

      j) odpal: eslint-check
           Wyświetli: 'The following rules are unnecessary or might conflict with Prettier'
           Zakomentuj konfliktujące się reguły

           Te, które rozpoczynają się od 'vue/' pochodzą od eslint-plugin-vue:
             vue/singleline-html-element-content-newline

            Zostaw je

______________________________________________________________________________________________
299) jest - tips

      1) assertion i matcher

          expect(2 + 2)  .   toMatch(/^Welcome/)
          - assertion -      ---- matcher ------

      2) matchery
          a) liczby:  toBe, toBeGreaterThan, toBeGreaterThanOrEqual, toBeLessThan, toBeLessThanOrEqual
          b) stringi: toMatch
          c) boolean: toBeTruthy, toBeFalsy, toBeDefined, toBeUndefined, toBeNull, toBeNaN
          d) tablice: toContain, arrayContaining
          e) obiekty: toEqual, toMatchObject, toHaveProperty
          f) async:   expectAssertions(number), resolves, rejects
          g) inne:    toThrow, toHaveBeenCalled, toHaveBeenCalledWith, toHaveBeenCalledTimes

______________________________________________________________________________________________
300) jest - config

      https://jestjs.io/docs/en/api

      Unit testy są do testowania funkcji nie korzystajacych z pliku, db czy serwera,
      bo do takich stosuje się testy integracyjne

      a) wersja jest@22.4.4 robi 1 pusty test w 0.5s, a 23.x.x w 9s

      b) do package.jsona, dopisz:

          "scripts": {
            "test": "jest --watchAll"
          },
          "jest": {
            "testEnvironment": "node"
          }

      c) w katalogu głównym stwórz plik jest.config.js:

          module.exports = {
            verbose: true,
            roots: ["__tests__/"],
            testURL: 'http://localhost'
          }

      d) stwórz katalog /__tests__
          bo w takim właśnie katalogu jest domyślnie szuka testów

      e) do pliku nazwaTestu.test.js, wbij:

          it('Our first test', () => {
            expect(2+2).toEqual(4)
          })

      f) yarn test nazwaTestu.test.js

_________________________________________________________________________________________________________
301) jest - numbers: toBe

      Zrób plik /tests/lib.test.js - tzn o tej samej nazwie, co plik który testujesz,
      tylko z 'test' w środku

      describe - grupuje testy dot tej samej fukcjonalnosci

      Potrzeba CONAJMNIEJ tyle testów, ile jest ścieżek wykonania
      Poniżej są 3 ścieżki, więc potrzeba 3 testów:

      function absolute(number) {
        if (number > 0) return number
        if (number < 0) return -number
        return 0
      }

      describe('absolute', () => {

        it('should return positive number if input is positive', () => {
          const result = absolute(1)
          expect(result).toBe(1)
        })

        test('should return positive number if input is negative', () => {
          const result = absolute(-1)
          expect(result).toBe(1)
        })

        it('should return 0 if input is 0', () => {
          const result = absolute(0)
          expect(result).toBe(0)
        })
      })

_________________________________________________________________________________________________________
302) jest - refaktorowanie implementacji

      Zmień implementację na poniższe dwie i sprawdź czy wpłynie to na wynik testu

      ---------------------------------------------------------
      module.exports.absolute = function(number) {

        /*
        if (number > 0) return number;
        if (number < 0) return -number;
        return 0
        */

        // return (number >= 0) ? number : -number  // refaktor 1

       // if(number >= 0) return number             // refaktor 2
       // return -number
    }

_________________________________________________________________________________________________________
303) jest - stringi: toMatch()

      Udemy - Node Complete Guide to Build RESTful APIs: 10/18

      Testując stringi, dobrze jest używać toMatch, by testy nie były zbyt specyficzne,
      tzn by drobna zmiana implementacji, nie powodowała ich wywalenia

     const greet = name => 'Welcome ' + name

    describe('greet', () => {
      it('should return greeting message', () => {
        const result = greet('Mosiek')
        expect(result).toMatch(/^Welcome/)
        expect(result).toMatch(/Mosiek$/)
        expect(result).toMatch(/^Wel.*siek$/)
      })
    })

_________________________________________________________________________________________________________
304) jest - array: toContain, arrayContaining, toBeDefined, toBeNull

    Udemy - Node Complete Guide to Build RESTful APIs: 11/18

    const arr = () => ['USD', 'AUD', 'EUR']

    describe('greet', () => {
      it('should return supported currencies', () => {
        const result = arr()

        // ok
        expect(result).toContain('USD')
        expect(result).toContain('AUD')
        expect(result).toContain('EUR')

        // ideal
        expect(result).toEqual(expect.arrayContaining(['EUR', 'AUD', 'USD']))

        // too specific
        expect(result).toEqual(['USD', 'AUD', 'EUR'])
        expect(result[0]).toBe('USD')
        expect(result[1]).toBe('AUD')

        // too general
        expect(result).toBeDefined()
        expect(result).not.toBeNull()
      })
    })

_________________________________________________________________________________________________________
305) jest - objects: toEqual, toMatchObject, toHaveProperty

    Udemy - Node Complete Guide to Build RESTful APIs: 12/18

      const getObject = () => {
        return { name: 'jan', age: 12 }
      }

      describe('getObject', () => {
        it('should return supported currencies', () => {
          const result = getObject()
          expect(result).toEqual({ id: 1, price: 10 })
          expect(result).toMatchObject({ id: 1 })
          expect(result).toHaveProperty('id', 1)
        })
      })

_________________________________________________________________________________________________________
306) jest - toThrow, toBeGreaterThan

    Przy testowaniu wyjątków, zamiast expect(result), trzeba użyć składni
    expect(funkcja zwracająca result), czyli:
      expect(() => { doSth() })

    function doSth (name) {
      if (!name) throw new Error('Name required')
      return { name }
    }

    console.log(doSth('Nick'))

    describe('doSth', () => {
      it('should ', () => {
        expect(() => doSth()).toThrow()
        expect(() => doSth('')).toThrow()
        expect(() => doSth(0)).toThrow()
        expect(() => doSth(false)).toThrow()
        expect(() => doSth(null)).toThrow()
        expect(() => doSth(NaN)).toThrow()
      })
    })

_________________________________________________________________________________________________________
307) jest - mockowanie

    Udemy - Node Complete Guide to Build RESTful APIs: 18/18

    Zamiast tworzyć złożone funkcje mokujace, które coś w końcu zwracają,
    można użyć wbudowanych w jesta funkcji mockujących, w tym mockujących wynik promisa

    test('1. mockReturnValue', () => {
      const mock = jest.fn().mockReturnValue('bar')
      //  LUB: const mock = jest.fn(() => 'bar')

      expect(mock()).toBe('bar')
      expect(mock('foo')).toBe('bar')
      expect(mock).toHaveBeenCalled()
      expect(mock).toHaveBeenCalledWith('foo')
    })

    test('2. mockImplementationOnce', () => {
      const mock = jest.fn().mockImplementationOnce(() => 'bar')
      expect(mock('foo')).toBe('bar')
      expect(mock).toHaveBeenCalled()
      expect(mock).toHaveBeenCalledWith('foo')
      expect(mock('baz')).toBe(undefined)  // woła go 2gi raz, więc undefined (bo ..Once)
      expect(mock).toHaveBeenCalledWith('baz')
    })

    it('3. mockResolvedValue', () => {
      const mock = jest.fn().mockResolvedValue('bar')
      expect(mock('foo')).resolves.toBe('bar')
      expect(mock()).resolves.toBe('bar')
      expect(mock).toHaveBeenCalled()
      expect(mock).toHaveBeenCalledWith('foo')
    })

    it('4', () => {
      const mock = jest.fn().mockResolvedValue(3)
      expect(mock(4)).toBe(3)
      //expect(mock).toHaveBeenCalledWith(3)
    })
_________________________________________________________________________________________________________
308) jest - unit test tokena

     Udemy - Node Complete Guide to Build RESTful APIs: 12/20

      Warto zrobić osobne katalogi na unit testy i integracyjne

      -------- /models/user.test.js -------------------------
      (..)

      userSchema.methods.generateAuthToken = function() {
        const token = jwt.sign({ _id: this._id, isAdmin: this.isAdmin }, config.get('jwtKey'))
        return token
      }

      const User = mongoose.model('User', userSchema, 'users')

      (..)

      -------- /tests/unit/models/user.test.js ---------------

      const { User } = require('../../../models/user')
      const jwt = require('jsonwebtoken')
      const config = require('config')
      const mongoose = require('mongoose')

      describe('user.generateAuthToken', () => {

        it('should return JWT token', () => {
          const payload = {
            _id: new mongoose.Types.ObjectId().toHexString(),
            isAdmin: true
          }

          const user = User(payload)
          const token = user.generateAuthToken()
          const decoded = jwt.verify(token, config.get('jwtKey'))
          expect(decoded).toMatchObject(payload)
        })
      })

_________________________________________________________________________________________________________
309) jest - integracyjny: get i post

      npmjs.com/package/supertest

      Supertest - to narzędzie do testów integracyjnych

      Express serwuje strone, a supertest automatycznie ją ściąga
      i sprawdza czy spełnia ona warunki w nim umieszczone

      Typowo, testuje się route'y. Dlatego, by wypaliło polecenie:

        const result = await request(server).get('/users')

      .. wcześniej, musi zdefiniowana być route'a .get('/users):

          router.get('/', async (req, res) => {
            try {
              const users = await userModel.find()
              res.send(users)
            }
            catch(err) { console.error(err) }
          })

      Ponieważ każde odpalenie testu zawiera odpalenie serwera,
      każdy test powinien się kończyć jego zamknięciem

      Inaczej, będzie wywalany błąd EADDRINFO


      ------  instrukcja uruchomienia --------

      W bazie może nie być żadnych rekordów
      W trakcie testu będą one zapisywane a potem kasowane

      Odpal tylko komendę: yarn test (nie odpalaj: node app.js)

    ---------- app.js ----------------------------------------

      const { router } = require('./users')
      const express = require('express')
      const app = express()

      app.use(express.json())
      app.use('/users', router)

      const server = app.listen(3000, () => console.log('Serwer na 3000 ..'))

      module.exports = server

    ---------- users.js ----------------------------------------

      const express = require('express')
      const router = express.Router()
      const mongoose = require('mongoose')

      const userSchema = mongoose.Schema({ name: String, age: Number })
      const userModel = mongoose.model('userModel', userSchema, 'users')

      mongoose.connect('mongodb://localhost/users')
        .then(() => console.log('DB connected !'))
        .catch((err) => console.log('DB failed: ', err))

      router.get('/', async (req, res) => {
        const users = await userModel.find().select({ _id: 0 })
        console.log('users', users)

        res.send(users)
      })

      module.exports.router = router
      module.exports.userModel = userModel

    ---------- users.test.js ----------------------------------------

      const { userModel } = require('./users')
      const request = require('supertest')
      let server

      describe('/users', () => {
        beforeEach( async () => {
          server = require('./app')

          await userModel.insertMany([
            { name: 'xoxo', age: 33 },
            { name: 'yoyo', age: 66 }
          ])
        })

        afterEach( async () => {
          server.close()
          await userModel.remove({})
        })

        it('', async () => {
          const res = await request(server).get('/users')

          console.log('res.body = ', res.body)

          expect(res.status).toBe(200)
          expect(res.body.length).toBe(2)
          expect(res.body.some(el => el.name === 'yoyo')).toBe(true)
        })
      })
_________________________________________________________________________________________________________
91) jest - integracyjny: get

      Potrzeba wyeksportować app, a ponieważ nie przejdzie
      bezpośrednie module.exports app, trzeba użyć:

        const server = app.listen(3000, () => console.log('Serwer na 3000 ..'))
        module.exports = server

      Linia ściągająca zawartość route'y:
        const result = await request(server).get('/users')

    ---------- app.js ----------------------------------------------

      const users = require('./users')
      const express = require('express')
      const app = express()

      app.use(express.json())
      app.use('/users', users)

      const server = app.listen(3000, () => console.log('Serwer na 3000 ..'))

      module.exports = server

    ---------- users.js ----------------------------------------------

      const express = require('express')
      const router = express.Router()

      router.get('/', async (req, res) => {
        const users = [
          { id: 0, name: 'jan', age: 11, city: 'wwa'},
          { id: 1, name: 'adam', age: 22, city: 'gda'}
        ]

        res.send(users)
      })

      module.exports = router

    ---------- users.test.js ---------------------------------------

      const request = require('supertest')
      let server

      describe('should ', () => {
        beforeEach( async () => {
          server = require('./app')
        })

        afterEach( async () => {
          server.close()
        })

        it('should return 200 if data is saved', async () => {
          const result = await request(server).get('/users')

          console.log('result.body = ', result.body)

          expect(result.status).toBe(200)
          expect(result.body.some(el => el.name === 'adam')).toBe(true)
          expect(result.body.length).toBe(2)
          expect(result.body[1]).toHaveProperty('name', 'adam')
        })
      })

_________________________________________________________________________________________________________
311) jest - istanbul (coverage)

    jest --coverage

    Wyświetla statsy pokrycia kodu testami w postaci tabelki w ascii
    i pliku /coverage/lcov-report/index.html

    Wklikaj się w kolejne linki, aż w końcu zobaczysz plik źródłowy
    z zaznaczonymi na czerwono liniami które nie pokrył żaden test

    Stwórz właściwy test i odświerz stronę
_________________________________________________________________________________________________________
312) jest - axios

      const axios = require('axios')

      it('should ', () => {
        axios
          .get('https://jsonplaceholder.typicode.com/users')
          .then(res => {
            const user = res.data[0]
            console.log(res.data[0])
            expect(user).toMatchObject({ username: 'Bret' })
            expect(user).toMatchObject({
              name: expect.any(String),
              username: expect.any(String)
            })

          })
          .catch(err => console.log('Eror: ', err))
      })
_________________________________________________________________________________________________________
313) jest - mocking

      Tuba - Mocking Axios in Jest

      yarn add axios

      Umieszczenie pliku o tej samej nazwie co pakiet, w katalogu __mocks__
      sprawia, że odpalony zostanie on, a nie plik pakietu

      Dzięki temu, można przetestować symulację ściągania danych z neta
      w ciągu 0.3 sekundy zamiast kilku sekund. Co przy dziesiątkach testów
      robi dużą różnicę

      Po skasowaniu pliku __mocks__/axios.js lub przeniesieniu go
      poza ten katalog, test uzyje pliku axios z pakietu npm'owego

      ----- instrukcja uruchamiania --------------

      yarn test
      zmień nazwę pliku axios.js na dowolną inną, bo wtedy odpalony będzie pakiet axios


------- app.js -------------------------------------------

    const axios = require('axios')

    const user = async () => {
      const res = await axios.get('https://jsonplaceholder.typicode.com/users/')
      return res.data
    }

    module.exports.user = user

------- /__mocks__/axios.js ------------------------------

    const axios = {
      get: jest.fn(() => Promise.resolve(
        { data: [
          { id: 1, username: 'dupa' },
          { id: 2, username: 'zupa' },
        ]})
        )
      }

    module.exports = axios


------- app.test.js ---------------------------------------

    const user = require('./app').user

    describe('', () => {
      it('should ', async () => {
        const result = await user()
        console.log('result = ', result)

        expect(result.length).toBeGreaterThan(1)
        expect(result.length).toBeLessThan(3)
        expect(result.length).toBe(2)
        expect(result[0].username).toBe('dupa')

      })
    })

_________________________________________________________________________________________________________
314) jest - tablica obiektów

      Np: [
        { "text": "Dzień", "value": null },
        { "text": "Wt 19 Luty", "value": 1550534400000, "dayString": "Wt 19 Luty" },
        { "text": "Śr 20 Luty", "value": 1550620800000, "dayString": "Śr 20 Luty" }
      ]

    ------ my.test.js -----------------------------------

    it('should return array with object "text: Czw 14 Luty"', () => {
      const result = days()
      expect(result).toBeDefined()
      expect(result).not.toBeNull()

      expect(result).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            text: 'Czw 14 Luty'
          })
        ])
      )
    })

_________________________________________________________________________________________________________
315) jest - crash course

      Tuba - Traversy: Jest Crash Course

      yarn add jest axios

    ----------- functions.js -----------------------------------------

      const axios = require('axios')
      const url = 'https://jsonplaceholder.typicode.com/users/1'

      const functions = {
        add: (num1, num2) => num1 + num2,
        subtract: (num1, num2) => num1 - num2,
        isNull: () => null,
        checkValue: x => x,
        createUser: () => {
          return { first: 'joe', age: 12 }
        },
        load: () => 10,
        regexes: () => 'warsaw',
        arr: () => ['joe', 'jane', 'jon'],
        fetch: () => axios.get(url)
          .then(res => res.data)
          .catch(err => err),

        revString: str => str.split('').reverse().join(''),

      }

      module.exports = functions


    ----------- functions.test.js -----------------------------------


      const { add, subtract, isNull, checkValue,
        createUser, load, regexes, arr, fetch,
        revString, anagram } = require('./functions')

      // beforeEach(() => console.log('Db initialized ..'))
      // afterEach(() => console.log('Db closed ..'))

      beforeAll(() => console.log('Db initialized ..'))
      afterAll(() => console.log('Db closed ..'))

      test('1.', () => expect(add(2,2)).toBe(4))
      test('2.', () => expect(subtract(3, 2)).not.toBe(2))
      test('3.', () => expect(isNull()).toBeNull())
      test('4.', () => expect(checkValue(2)).toBe(2))
      test('5.', () => expect(checkValue()).toBeFalsy())
      test('6.', () => expect(checkValue(1)).toBeTruthy())
      test('7.', () => expect(createUser()).toEqual({ first: 'joe', age: 12 }))
      test('8.', () => expect(createUser()).toStrictEqual({ first: 'joe', age: 12 }))
      test('9.', () => expect(load()).toBeLessThan(20))
      test('10.', () => expect(load()).toBeGreaterThanOrEqual(10))

      test('11.', () => expect(regexes()).toMatch(/^w/))
      test('12.', () => expect(regexes()).toMatch(/aw$/))
      test('13.', () => expect(regexes()).toMatch(/^w.+aw/))
      test('14.', () => expect(arr()).toContain('jane'))

      test('15. Promise', () => {
        expect.assertions(1)
        return fetch()
        .then(data => {
          expect(data.name).toEqual('Leanne Graham')
        })
      })

      test('16. Async / Await', async () => {
        expect.assertions(1)
        const data = await fetch()
        expect(data.name).toEqual('Leanne Graham')
      })

      test('17.', () => expect(revString).toBeDefined())
      test('18.', () => expect(revString('hello')).toBe('olleh'))

______________________________________________________________________________________________
326) CDN failure fallback dla plików .css

        Skrypt śle do CDN'a ajaxa i jak dostanie OK  ( 200 ) to ładuje np bootstrapa.css
        Jak dostanie błąd, to ładuje plik lokalnie
        Wadą jest dokładanie ok 0.7s na round - tripa ajaxowego ( http )

        Umieścić w bloku <head> index.html
        Chrom wywala warninga:
            Synchronous XMLHttpRequest on the main thread is deprecated because of its detrimental effects to the end user's experience.
            For more help, check https://xhr.spec.whatwg.org/.

       <script>
           console.log ( '1'  )
           let nazwaPliku  = 'bootstrap.min.css'
           let url = 'https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.6/css/bootstrap.min.css'

           let httpLink = '<link rel="stylesheet" type="text/css" href=" ' + url + ' ">'
           let plikLink = '<link rel="stylesheet" type="text/css" href=" ' + nazwaPliku + ' ">'

           console.log( 'link  = '  + httpLink )
           console.log( 'plikLink  = '  + plikLink )

           console.log ( '2'  )
           var http = new XMLHttpRequest()
           http.open('HEAD', url, false)
           console.log ( '3'  )

           try  {
               http.send()
               console.log ( 'OK. http.status = ' + http.status  )
               console.log ( 'Ładuję plik z CDN'  )
               document.write( httpLink )
           }
           catch ( err  )  {
               console.log ( 'Url sie wyflaczył: '  + err )
               console.log ( 'Ładuję plik lokalny'  )
               document.write( plikLink )
           }

    </script>

______________________________________________________________________________________________
327) SEO - Fetch as Google  ( bot )

        andrewhfarmer.com/react-seo/
        https://support.google.com/webmasters/answer/6066468?hl=en
        searchengineland.com/tested-googlebot-crawls-JS-heres-learned-220157
        chrisarasin.com/react-seo/

        Weryfikacja,  czy renderowana strona wygląda tak jak powinna w oczach google bota  ( crawlera )

        Udziały wyszukiwarek w rynku - Niemcy
            www.statista.com/statistics/445002/market-shares-leading-search-engines-germany/

        Googlebot is limited in how long it will allow your page to render.

        There's no concrete documentation on this, but generally, asyncronous calls like AJAX and setTimeout won't be allowed to finish.

        The only way to know for sure if it's working is to use Fetch as Google.

        Wniosek:  w pliku reacta,  najprzód powinien być rendering strony,
                          a dopiero jakakolwiek funkcja anynchroniczna ( ajax,  timeout itd )

          To co widzi crawler google'a można zobaczyć przez:
            a) Sign up for Search Console.
            b) Use Search Console's Fetch aand Render button in Fetch as Google feature

    W przypadku PHP i konieczności server - side renderingu, trzeba na serwerze umieścić i skonfigurować rozszerzenie:  V8js
______________________________________________________________________________________________
330) Ikonki unicode w HTML

        www.w3schools.com/charsets/ref_utf_misc_symbols.asp

        a) znaleźć w tabeli unicodów, przedział: Decimal 9728-9983. Hex 2600-26FF  interesującą ikonkę

        b) osadzić w HTMLu, poprzedzając kod znakami &#x:
              <button> &#8593; &#8595; </button>
______________________________________________________________________________________________
331) Tablica obiektów - sortowanie

      stackoverflow.com/questions/1129216/sort-array-of-objects-by-string-property-value-in-javascript

      UWAGA !
        Ma być localECompare a nie localCompare - 'locale' ma być z 'e' na końcu

      const arr = [
        { name: 'bob', age: 1 },
        { name: 'adam', age: 3 },
        { name: 'dama', age: 2 }
      ]
      console.log ('arr PRZED =', arr)

      const arrByAge = arr.sort ((a, b) => a.age - b.age ) // liczby

      console.log ('\narrByAge = ', arrByAge)

      const arrByName = arr.sort((a, b) => a.name.localeCompare(b.name)) // stringif

      console.log ('\narrByName = ', arrByName)

______________________________________________________________________________________________
332) Tablica obiektów - wyszukiwanie po Object.keys

        Obiekt złożony, bo jako ma property obiekt,
        więc prosta iteracja nie działa

         var a =  [
            { 'id2': { imie: 'Tomek', miasto: 'Wwa', bool: 'true' } },
            { 'id3': { imie: 'Ola',   miasto: 'Ldz', bool: 'false' } },
            { 'id1': { imie: 'Robert', miasto: 'Krk', bool: 'true' } }
         ]

        var x  = ( a [ 0 ]  )
        var y = Object.keys ( a )
        var z1 = Object.keys ( a [ 0 ]  )
        var z2 = Object.keys ( a [ 1 ]  )
        var z3 = Object.keys ( a [ 2 ]  )

        console.log( x )                  // { id2: { imie: 'Tomek', miasto: 'Wwa', bool: 'true' } }
        console.log( y )                 //  [ '0', '1', '2' ]
        console.log( z1, z2, z3 )    //  [ 'id2' ] [ 'id3' ] [ 'id1' ]
______________________________________________________________________________________________
333) Zagnieżdżony obiekt - trawersowanie  ( traversing nested objects )

     var callbackObject = {
       "filters": {
         "filtersV1": {
           "V1": {
             "msu": "MBL",
              "ps": "Hans Kloss",
              "sortCol": "msu",
              "sortAsc": true
           }
         }
       },
       "setup": {
         "method": "GET",
         "segment": "projects"
       }
     }

     var y1 = Object.keys ( callbackObject ) [ 0 ]
     var y2 = callbackObject  [ y1 ]
     var y3 = Object.keys ( y2 ) [ 0 ]
     var y4 = callbackObject  [ y1 ] [ y3 ]
     var y5 = Object.keys ( y4 )  [ 0 ]
     var y6 = callbackObject [ y1 ]  [ y3 ]  [ y5 ]


     console.log( y1 )   //  filters
     console.log( y2 )   //  { filtersV1: { V1: { msu: 'MBL', ps: 'Hans Kloss', sortCol: 'msu', sortAsc: true } } }
     console.log( y3 )   //  filtersV1
     console.log( y4 )   //  { V1: { msu: 'MBL', ps: 'Hans Kloss', sortCol: 'msu', sortAsc: true } }
     console.log( y5 )   //  V1
     console.log( y6 )   //  { msu: 'MBL', ps: 'Hans Kloss', sortCol: 'msu', sortAsc: true }

______________________________________________________________________________________________
334) Włączanie / wyłaczanie wyświetlania console.logów

        W każdego pliku .js osobno:
            a) zamień 'console.log' na 'showLogs && console.log'
            b) u góry pliku wbij: 'var showLogs = true'

        Można wbić tylko w 1 pliku odpalanym na starcie apki,  globala:
            showLogs = true
        .. ale wtedy będą się pokazywały lub nie logi z wszystkich plików
        A tak jak jest - tylko z wybranego pliku

        Przydaje się też console.clear (  ) które czyści konsolę
______________________________________________________________________________________________
335) eval

        nczonline.net/blog/2013/06/25/eval-isnt-evil-just-misunderstood/    ( 2013 )

        Interpretowanie stringa jako kodu JS
        String ten może zawierać zmienne i propertki obiektów

        Sure, it would be unwise to eval the value of an input box, but running eval over a response generated by your own server code should present no special risk.

        Both Prototype’s evalJSON and JQuery’s parseJSON use eval  ( before ES5 with JSON.parse )

        If the data is comming from your server and its something that you, the developer has generated, there is no harm in using eval()

        The mere presence of eval() in your code means that it is unpredictable and therefore will run in the interpreter – making it run at “old browser” speed instead of “new browser” speed (once again, a 10x difference).  ( Zakas, 2013 )

        Nie w chromie 54.
        Różnica między 3,000 powtórzeń:
           console.log ( 'dupa' )
              a
           var a = 'console.log'
           var b = '( "dupa" )'
           eval ( a + b )

        eval (  ) był 3 razy wolniejszy

        Ale w drugim teście, było 3k powtórzeń console.log ( 'dupa' )
        Po czym pojedyńczy eval  ( jak wyżej ) i czasy wykonania nie różniły się  ( wiecej niż kilka % na 3 próbach )

        var rules =  [  ]
        rules.push (  {  name: 'Rule 1', category: 'error',  field: 'budget', rule: '>', val: 40000 } )

        console.log ( eval ( 'projects [ 0 ]'  +  '.' + rules [ 0 ].field + rules [ 0 ].rule + rules [ 0 ].val ) )

        to samo, co:

        console.log ( projects [ 0 ].budget>40000 )

______________________________________________________________________________________________
336) console.log - tips & gotchas

        Domyślnie używaj przecinka zamiast plusa, bo plusem, b rzadko będziesz chciał dodać liczby czy połączyć stringi

          console.log('obj = ', obj) // obj =  { a: 1, b: 'zoo' }
          console.log('obj = ' + obj) // obj = [object Object]

          console.log('arr = ', arr )   // arr =  [ 1, 2, 3, 4 ]
          console.log('arr = ' + arr )  // arr = 1,2,3,4

        Jeśli logi mają iść na devtoolsy, korzystaj z kolorów

        Jeśli logów jest zbyt dużo, poprzedzaj istotne jakimś prefixem np  '**'
        a potem filtruj je w devtoolsach, wpisująć '**' do okna filtra

        Jeśli któryś z ww grupy jest super istotny, dorzuć kilka gwiazdek, by się rzucał w oczy, np:
            console.log ( '*********** setCopyToHDButton  = ', setCopyToHDButton )

        Jeśli te same logi odświeżają się zbyt szybko, zlewając się w całość poprzedź je 'console.clear()'
        Dzięki temu, tylko ostatnia seria logów będzie wyświetlana

        Jeśli nazwa zmiennej jest zbyt długa, wyświetlaj tylko ostatni jej człon, np:
            console.log ( '** isApple = ',  $scope.currentMedia.isApple );

        Jeśli grupę iluś logów, chcesz podzielić na mniejsze rozdzielając ją pustą linią, użyj:
            console.log ( '' );
          .. albowiem pusta console.log (  ) - zostanie zignorowana


______________________________________________________________________________________________
337) console.log - color

      Z ikonkami:
        console.info("info");
        console.warn("warn");
        console.error("error");

      Bez:
        console.log('%c Hello World', 'color: #f00')
        console.log('%c Hello World','color: blue')

______________________________________________________________________________________________
338) console.time

    coderwall.com/p/h8hoiw/how-to-measure-your-JS-to-the-nanosecond-level

    Pomiar czasu wykonania kodu pętli opóźniającej

      const a = 'start'
      console.time(a)

      for (let i = 3 * 1e9; i > 0; i--)  { }

      console.timeEnd(a)  // start: 3613.810ms
______________________________________________________________________________________________
339) console.trace

    Pokazuje stack trace'a do chwili wywołania napisu w konsoli

    <button onclick="myFunction()">Start Trace</button>

    function myFunction() {
      myOtherFunction()
    }

    function myOtherFunction() {
      console.trace()
    }

    myFunction()

______________________________________________________________________________________________
340) console.clear i console.assert

        console.log( 'Śmieć 1' )
        console.log( 'Śmieć 2' )
        console.log( 'Śmieć 3' )

        console.clear(  )                  // czyści konsolę; można też z ręki ctrl + l  ( małe el )
                                          // ustawiaj go na początku

       console.assert( x.length > 7,' za mała tablica !' )  // Assertion failed:  za mała tablica !
______________________________________________________________________________________________
342) console.table

      Wyświetla obiekty w zgrabnej i sortowalnej tabelce, zamiast w drzewie

        var languages = [
            { name: "JS", fileExtension: ".js", paradigm: "object-oriented" },
            { name: "TS", fileExtension: ".ts", paradigm: "object-oriented" },
            { name: "CoffeeScript", fileExtension: ".coffee", paradigm: "functional" }
        ]

        console.table(languages)                                        // wszystko
        console.table(languages, "name")                         //  tylko 1 kolumna
        console.table(languages, ["name", "paradigm"])  //   2 kolumny
______________________________________________________________________________________________
342) JS style - feross: standard JS

        https://github.com/feross/standard

        npm install standard

        9 rules:

        1) 2 spaces – for indentation
        2) Single quotes for strings – except to avoid escaping
        3) No unused variables – this one catches tons of bugs!
        4) No semicolons  ( never start a line with (, [, or ` )
        5) Space after keywords if (condition) { ... }
        6) Space after function name function name (arg) { ... }
        7) Always  ===  (  but obj == null is allowed to check null || undefined )
        8) Always handle the node.js err function parameter
        9) Always prefix browser globals with window – except document and navigator are okay
            ( prevents accidental use of poorly-named browser globals,
              like open, length, event, and name )
______________________________________________________________________________________________
343) High performance

      Na podstawie książki - Zakas: 'High Performance JS' - 4. Algorithms and Flow Control

      a) pętle

          szybkie - to te w których znana jest ilość elementów
            (for, while, do - małe różnice między nimi)

          wolne - nieznana ilość elementów
            ( for..in, forEach, for..of  - 8 razy wolniejsze @ 2013 )

          Najszybsza jest malejąca pętla for, ze skaszowaną wcześniej liczbą elementów
            let length = arr.length                  //  25% szybsza  ( @ 2013 )
            for (let i = length i > 0 i--)  { .. }  // kolejne 20-30% szybsza, razem 50-60% (@ 2013 )

          Przy 1,000 + elementów, warto użyć Duff's Device czyli zastosować 2 pętle, np:
          100 obrotów po 10 działań w każdym.

          Przy 500k elementach, wydajność jej jest 70% lepsza od zwykłej pętli (@ 2013)

        b) conditionals (if-else vs switch)

            Najważniejsze, by najczęściej chodzące wartości ustawiać najwyżej w bloku (if-else czy switch)

            Przy więcej niż kilku elementach, dziel zakresy, stosując zagnieżdżenia.
            Np dla wartości 1 do 100:

                if (x > 50)
                    if (x > 75)
                        if (x > 92)
                else if  ( >  )

            Dla kilku elementów różnica szybkości jest marginalna, a if-else czytelniejsze

            Przy 3-4 czytelniejszy jest switch

            Przy 5+ elementach znacznie szybsza jest lookup table, tzn umieść wartości w tabeli i wołaj ją z parametrem:

                var results = [result0, result1, result2, result3, result4, result5, .. resultn]

                return results[value]

        c) rekurencja

            Łatwo o stack overflowa
            Nawet jeśli mozna użyć try-catcha, nie warto pisać kodu grożącego stack overflowem
            Stack chroma = 16k,  FF = 3k
            Każdy algo rekurencyjny można zastąpić skończoną ilością pętli zagnieżdżonych

______________________________________________________________________________________________
344) Skrótowce testów logicznych: && i ||

    a)  bool && zupa (  )

            let bool  = true      // potem sprawdź dla false

            function zupa( ) {
                console.log( 'zupa' )
            }

            bool && zupa (  )     // zamiast if ( bool ) { zupa (  )  }

    b)  undefined || 'domyślniak'

            let x
            console.log( x )                           // undefined
            console.log( x || 'domyślniak' )   // domyślniak

_______________________________________________________________________
_______________________
346) Chrome debugger - zakładki VMxx

        stackoverflow.com/questions/17367560/chrome-development-tool-vm-file-from-JS

        W trakcie debugowania w chromie, gdy ładuje on ajaksem HTML'a,
        w którym są tagi <script>, zawartość każdego będzie przetworzona
        z użyciem eval (  ) i potraktowana jako nowy plik o nazwie zaczynającej się od 'VM'

        Możesz pójść do zakładki Network, znaleźć zapytanie ajaksa i obejrzeć w całości
        odpowiedź, włącznie z Twoim skryptem

        Currently blackboxing doesn't work with anonymous script ( Sep 27 2016 )
            bugs.chromium.org/p/chromium/issues/detail?id=526239

            Nie rozwiązane @ 24 sie 2017:
                This issue is really frustrating, has it been resolved??!
______________________________________________________________________________________________
347)  Formatowanie liczb  ( tysiące i dziesiętne )

       jakasLiczba.toLocaleString('en-US', { minimumFractionDigits: 2 } )

       console.log(   (  123456.789 ).toLocaleString('en-US', { minimumFractionDigits: 1 } ) )   // 123,456.789
       console.log(   (  123456.789 ).toLocaleString('en-US', { maximumFractionDigits: 1 } ) )  // 123,456.8

______________________________________________________________________________________________
_____________________________________________________________
348) sleep - samoróbka

      var now = new Date()
      var delay = 1200

      function sleep(time) {

          var start = new Date().getTime()
          console.log('Start = ' + start + ' ms' )

          while( new Date().getTime() < (start + time) ) {  }
          var stop = new Date().getTime()

          console.log('Stop = ' + stop + ' ms' )
          console.log('Mineło ' + (stop-start) + ' ms' )
      }

      sleep(delay)
______________________________________________________________________________________________
349) Haversine - dystans między punktami na Ziemi

      function distance(lat1, lon1, lat2, lon2) {

        function toRad(x) { return x * Math.PI / 180 }

        var R = 6371 // km

        var x1 = lat2 - lat1
        var dLat = toRad(x1)
        var x2 = lon2 - lon1
        var dLon = toRad(x2)
        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
          Math.sin(dLon / 2) * Math.sin(dLon / 2)
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
        var distance = R * c

        return distance
      }

      console.log(distance(52.2011, 21.0323, 52.5271, 21.1599))   // Dolna - Popowo = 37.270557460577145 km
      console.log(distance(52.2011, 21.0323, 52.1704, 21.0332))   // Dolna - Bacha      =  3.41 km
_____________________________________________________________
350) Strzelanie bąblami GPS do serwera node.js

    Uruchamianie:  node nazwaPlikuPoniższego

    var syncRequest = require('sync-request'),
          fs = require('fs'),
          array = fs.readFileSync('./krk-wwa.txt').toString().split('\r\n')

    var kodKursu = "krk-wwa-03"
    //var serverPath = 'vps194685.ovh.net:4000/rejestracja'
    var serverPath = 'localhost:3000/gps'

    var ileBombli = 3
          delay = 1,  // ms
          speed = 0,
          battery = 100,
          timestamp = 1445590800000,          // 23 paź = 1 paź 11:00:00
          licznik = 0

    kodKursu, lat, lon, speed, battery, timestamp, time

    var paka = function(token, lat, lon, speed, battery, timestamp, time) {
        return {
            token: token,
            deviceId: "abc123",
            latitude: lat,
            longitude: lon,
            accuracy: 25,
            speed: speed,
            battery: battery,
            adres:"Piaseczyńska 57, Warsaw, null, Poland, null 1",
            time: time,
            timestamp: timestamp,
        }
    }

    function sleep(time, callback) {
        var now = new Date().getTime()
       // console.log('Zasypiam na ' + (time/1000) + ' s' )
        while( new Date().getTime() < (now + time) ) { }
        //console.log('Budze sie. Spalem ' + ( ( new Date().getTime() - now ) / 1000 ) + ' s')
        callback()
    }

    for ( var i = 0 i < ileBombli i++ ) {

         var lat = array[ i ].split( "," )[ 0 ],
               lon = array[ i ].split( "," )[ 1 ],
               t = new Date(timestamp),
               time = t.getDate() + "-" + ( t.getMonth() + 1 ) + "-" + ( t.getYear() + 1900 ) + "  " + t.toLocaleTimeString().substring(0, t.toLocaleTimeString().length - 3)

         console.log(licznik + ' Wysyłam paczkę na serwer ...' )
         console.log('json = ' + JSON.stringify(paka(kodKursu, lat, lon, speed, battery, timestamp, time)) )

         sleep(delay, function() { syncRequest('POST', 'localhost:3000/gps', { json: paka(kodKursu, lat, lon, speed, battery, timestamp, time) } ) })

         console.log('Wysłałem\n' )

         speed += 0.2
         battery -= 1
         timestamp += 3 * 60 * 1000  // 3 minutes
         licznik++
    }
______________________________________________________________________________________________
351) parseInt i toString

        developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Obiekty/parseInt
        stackoverflow.com/questions/57803/how-to-convert-decimal-to-hexadecimal-in-javascript

        W przypadku konwersji systemów liczbowych, parseInt i toString są swymi odwrotnościami
        Tzn parseInt tłumaczy binarki i heksy na dziesiętne, a toString - dziesiętne na heksy i binarki

        I. parseInt

          parseInt ma 2 funkcje:
            a) castuje stringi na liczby,
            b) floatom ucina część dziesiętną
            b) konwertuje na dziesiętny inne systemy liczb (binarny, octalny, hex)

            a) parseInt('2')      + 3 =  5
               parseInt('02')     + 3 =  5
               parseInt(' 02 ')   + 3 =  5
               parseInt(' 02r ')  + 3 =  5
               parseInt(' 0 2 ')  + 3 =  3

            b)
               parseInt('2.9') + 3 = 5
               parseInt(2.1)   + 3 = 5

            c) parseInt(string, radix = system liczbowy)

                parseInt('A', 16) = 10  // 16 -> hex
                parseInt('a', 16) = 10
                parseInt(0x15)          // 0x - hex

                parseInt(101, 2) = 5  // 2 - binarny

        II. parseInt

                parseFloat('23.8birthday')    // 23.8
                parseFloat('a23.8birthday')   // NaN

        III. toString

            UWAGA !
              Składnia 5.toString(2) nie przejdzie, więc jako pośrednika, trzeba użyć zmiennej

            const a = 1
            console.log (a.toString(2))   // 1    - binarny

            const b = 4
            console.log (b.toString(2))   // 100

            const c = 5
            console.log (c.toString(2))   // 101

            const d = 10
            console.log (d.toString(16))   // 10 - hex

            const e = 255
            console.log (e.toString(16))   // ff

______________________________________________________________________________________________
352) setTimeout

    let x = 5

    const dupa = setTimeout(() => {
      x > 5 ? clearTimeout(dupa) : console.log('kupa')
    }, 1000);

______________________________________________________________________________________________
353) setInterval

    let x = 1

    const dupa = setInterval(() => {
      console.log(x);
      x++;
      if(x>5) clearInterval(dupa)
    }, 1000);
______________________________________________________________________________________________

400) Continuous Intergation

            www.yegor256.com/2014/10/08/continuous-integration-is-dead.html

            'Crucially, if the build fails, the development team stops whatever they are doing and fixes the problem immediately'

            This is what doesn't work and can't work. Who likes this continuous integration and who needs it? Nobody.

            OK, What Is The Solution?

            I wrote about it before it is called "read-only master branch."
            It is simple: prohibit anyone from merging anything into master and create a script that anyone can call.

            The script will merge, test, and commit. The script will not make any exceptions.
            If any branch breaks at even one unit test, the entire branch will be rejected.

            In other words: raise the red flag before the code gets into master. This solves all problems.
            First, the build is always clean. We simply can't break it because nobody can commit unless his code keeps the build clean.

            Second, there is no fear of breaking anything. Simply because you technically can't do it.
            All you can do is get a negative response from a merging script.
            Then you fix your errors and tell the script to try again.
            Nobody sees these attempts, and you don't need to apologize. Fear factor is gone.

______________________________________________________________________________________________
420) Licenses: AGPL

        https://news.ycombinator.com/item?id=13421608

        GPL alone is toxic to much of the enterprise world -- and the GPL is a buttoned-down corporate stooge compared to the virulent, ill-defined, never-tested AGPL.

        The AGPL is a complete non-starter for any purpose, and while I appreciate why the AGPL was selected by RethinkDB (and very much appreciate the explicit riders that RethinkDB put on it to make clear what it did and didn't apply to), the reality is that no one -- absolutely no one -- has built a business on AGPL software and it seems vanishingly unlikely that anyone ever will.


______________________________________________________________________________________________
421) RethinkDB postmortem blog post

        www.defstartup.org/2017/01/18/why-rethinkdb-failed.html

        To see how this plays out for other companies consider their valuations:
        MongoDB   ~$1.6 B  ~700 employees
        and Docker ~$1B      ~300 employees

        Both companies completely dominate in their respective markets.

        Two very rough valuation rules of thumb for private growth stage technology companies:
            a)  P/E = 10  ( Price /  ( yearly ) Earnings ratio )
            b)  revenue per employee  = $200K/year

        Which means that their annual revenue is:
            MongoDB   $140 - $160 M
            Docker        $60   - $100 M
______________________________________________________________________________________________
422) Refactoring 30k codebase with types

        www.reaktor.com/blog/refactoring-30000-lines-js-types/?utm_source=JSweekly&utm_medium=email

        30k lines of client-side JavaScript. No tests.
        Two difficult TV deployment platforms with poor tooling.
        Strong dependencies on poorly documented external APIs.

        The task: add support for a third TV platform to the two supported platforms and switch to a new backend with a different API.
        How can we do this without breaking things?

        One approach is to add tests incrementally- end to end tests to avoid breaking functionality and unit tests to aid with refactoring.
        But this was mostly user interface code on TV platforms with poor and varied tooling.
        Automated user interface testing on each platform would be challenging if possible at all.
        Manual testing on each platform was time consuming due to slow and inconsistent deployment tools.

        Some parts of the application could be tested and this was a part of how we made this change.
        But the more interesting idea we tried was to refactor with types.

        The approach: refactoring with types
        The idea: introduce minimal typing to the code base. Add strong typing around a specific area to be changed.
        Make the changes, leaning on the compiler as an aid. Move on to the next area, incrementally adding types as we go.

        This seemed like a nice fit for the project:

        No run-time dependencies. Some of the platforms had strict dependency requirements (read: ancient JS versions),
        but types are used only at compile-time.
        Shortens feedback loop.
        Deploying in this project was slow and flaky and tests were nonexistent,
        but compiler errors would come immediately and tell you how you broke things.

        Documents external APIs.
        The platform APIs used in the project were sometimes poorly documented, and types tell the story more clearly.
        Low typing overhead.
        The project was mostly vanilla JavaScript, so there was little time-consuming typing of libraries to worry about.
        To experiment with the idea, I added strong types to a full path of code from UI to server calls and made breaking changes to see if the process and feedback felt useful.
        I tried this with both Facebook Flow and TypeScript.


        Where TS worked
        Refactoring

        Adding types and in particular using TS in Intellij IDEA was a godsend for refactoring.
        It removed a huge amount of manual checking that would have been needed for even basic changes.

        The compiler would tell things like:

        Is my function called with the correct number of parameters?
        Is this variable being used?
        Does the value I am using exist?
        Does the field I am using on this value exist?
        Understanding the code base

        Question: what data is being used from the backend APIs in your JS application?

        JS answer: find the code that calls an API and receives data as an opaque object.
        See where the data is passed. Follow that data and see where it gets passed next.
        Track how the object is modified along the way.

        Grep to the eventual places where the object is used and write down in your notes each field that is used.
        The process requires careful, focused navigation through the entire code base, good notes,
        and significant amounts of grepping.

        TS answer: add types to the API call, initially giving it your best guess of the correct type
        e.g. an empty object type.

        Add type annotations to every place this function is being called. The compiler will tell you if your type is wrong.
        In Intellij you get a red squiggly line under your incorrect assumptions.

        Continue adding type annotations everywhere the data is used and updating your types until the types match reality.
        This still requires much of the same navigation as above, but you offload a large portion of manual grepping
        and note taking to the compiler.

        Making tools better

        TS makes Intellij IDEA amazingly better.
        My tooling experience has started good and improved during the time I’ve used TS.
        Inline errors point directly to code issues, short-circuiting the write-debug cycle.

        Tools like navigating to functions, renaming variables, inlining functions, autocompletion,
        and finding variable usages work immensely better than with vanilla JS.

        Much as I appreciate minimalist editors, combining Vim keybindings with refactoring
        and navigation tools makes me an absurdly more effective developer.
        It would almost be worth it to ignore types and use TS for this reason alone.

        Documenting external APIs

        Some of the external APIs we used had poor documentation or were entirely undocumented.
        Adding type annotations to these APIs documents our own knowledge about those APIs
        and helps later when using the APIs.

        It’s also a convenient place to put comments about the sources of documentation,
        implicit assumptions and so forth.

        Making code dependencies explicit

        Types document the flow of data throughout your app. In our case the UI and data were not clearly separated.
        It was a mess to trace the source of data down to the leaves of the app where the data was being used.
        Types made these dependencies explicit and much easier to follow.

        Finding bugs

        In some places adding types revealed bugs.
        For example, incorrect titles for images were being displayed in some cases
        because they relied on the old API data which no longer existed.
        Adding types caught this immediately because the new API data types did not contain this information.

        In another example an image was fetched by passing in a string to a function and receiving the image URL.
        It turned out that the string contained a typo, which we found after making the function take a string literal type.

        In a number of places we could safely remove dead code only because we knew that the data did not exist on the new types.

        New tools, old environment

        Introducing TS brought most of the ES6 benefits to a legacy JS project
        without introducing runtime dependencies. It also did not require another heavy tool like Babel,
        although we did need Browserify to get proper modules.

        Where TS failed
        You can’t always trust the compiler

        TS is explicitly unsound, which could lead to some surprising errors.
        In practice we did not run into these.
        There are other cases, however, where TS works exactly as intended, but it might not be how you expect.

        TS requires many type annotations

        In the above example the two cases are semantically equivalent.
        The problem is that the compiler is able to infer the correct type of the callback parameter in one but not the other.

        In the second case the compiler infers the any type.
        To make it easier to trust the compiler, it’s useful to disable implicit any types (via tsconfig)
        and/or explicit any types (via TSLint).
        The compiler would then complain about the second example because of the inferred any type.

        TS doesn’t give you much support for free. If you add type annotations,
        your editors get better and the compiler will aid you in finding errors.
        If you don’t add type annotations or if you use many any annotations,  TS won’t help much.
        In practice this means you will be writing a lot of type annotations.

        Types are still your assumptions

        When receiving data from external sources, the type embodifies your assumptions about the data.
        You are expecting to receiving an object, with a field name foo, with an array of bar, and so forth.
        These assumptions are not checked by the compiler. You still need to validate input data if you want to be sure.
        The types are only as good as your assumptions.

        Typing can’t always be incremental

        In most cases we were able to add typing in small chunks, but not always.

        A large portion of the UI code in this project used a hierarchy of view objects.
        This hierarchy would map well to TS classes, but typing it as classes is difficult to do piecemeal.

        If you add types only to a parent class, the compiler complains when the child class uses its own fields
        that do not exist on the parent class (and are not yet typed on the child). If you add types only to a child class,
        the compiler complains when you use fields from the child that are only defined on the parent class.
         In practice it means that the typing of this whole hierarchy must be done in one go.

        Circular dependencies

        TS doesn’t allow circular dependencies. Sort of.
        TS was happily compiling our code, circular dependencies and all, for months until one day it broke.
        Maybe it was just serendipitous that the dependencies were loaded in the correct order before, but it stopped working.
        We painfully refactored the circular dependencies all away.
        Lesson learned: no circular dependencies in your TS code.

        Was it worth it?

        Adding TS to this project was an experiment to see if adding incremental types to our code
        would make it easier to do large refactorings without introducing large breaking changes.
        The experiment was a success.

        Converting the project to TS and adding the initial types took a few days.
        This was the only additional work that was required solely due to adding TS.

        After this types were available as another development tool and were expanded incrementally
        to the rest of the code as a part of normal development.
        Refactoring was much easier with type checking and it removed a huge number of manual checks
        and careful grepping that was previously needed to change code.

        A few items made this project a particularly good fit for TS:

        Few dependencies meant little time typing out external libraries.
        The environment was difficult to deploy to, so compile time checks gave dramatically faster feedback.
        Tests were difficult to write, so types added a much needed safety net.

        TS support for older versions of JS allowed us to use new JS features at compile time and remove at run time.
        The biggest drawbacks were the typing overhead of adding annotations nearly everywhere
        and the uncertainty about type guarantees in certain cases such as those discussed above.

        It’s not PureScript, but types were useful and they were easy to add incrementally.
        In this case it would have been more risky to continue with vanilla JS than to introduce types.

        4/5 stars. Would use it again
______________________________________________________________________________________________
423) Keyboard events

      Do wykrycia który klawisz został klikniety użyj zdarzenia: onKeyPress
      a jego wartość odczytaj event.which  ( nie event.keycode )

        if ( e.which  === 13 )  { ..  }

        <input onKeyPress = ..   />


______________________________________________________________________________________________
424) Filtrowanie obiektem tablicy obiektów

        Na przykładzie apki Skill Bill, gdzie określa się 3 skille poszukiwanego juzka, np:
            Java: 3
            C: 2
            JS: 1

        .. i szuka w bazie juzków je spełniających, np:
            Java: 4
            C: 3
            JS: 1
            Python: 4

         Oczywiście juzek musi mieć skill rank  >= od wymaganego

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

 const needle = { Java: 5, C: 3 }                          // szukany skillset

 const haystack =  [                                          // w takiej bazie skillsetów
     { Python: 2, Java: 5, C: 5 },
     { Python: 5 },
     { Python: 5, Java: 5, C: 2 },
     { Python: 5, Java: 5, C: 4 },
 ]

 function isArrayInArray ( needle, haystack, arr ) {
     const needleKeys =  Object.keys ( needle )            // [ 'Java', 'C' ]
     console.log ( '6. needleKeys = ',  needleKeys )

     for  ( let i = 0; i < haystack.length; i++  )  {

         const haystackKeys =  Object.keys ( haystack [ i ]  )   // [ 'Python', 'Java',  'C'  ]
         console.log (  'i = ', i )
         console.log (  '19. haystackKeys = ', haystackKeys )

         if ( haystackKeys.length < needleKeys.length )  {
             console.log (  '13. needle > haystack' )
             console.log (  '_____________________________________________________________________'  )
             continue
         }

         for ( let i = 0; i < needleKeys.length; i++) {
             if  ( haystackKeys.indexOf ( needleKeys [ i ]  )  ===  - 1 )  {
                 console.log (  '19. Brak elementu: ' + needleKeys [ i ] +  ' w haystacku'    )
                 return
             }
         }

         const user = filterObjectsByValues ( needle, haystack [ i ], i  )
         if ( user ) arr.push ( user )
     }

     return arr
 }

 function  filterObjectsByValues ( needle, haystack, i )  {

     console.log ( '31. needle = ',  needle )
     console.log ( '32. haystack = ',  haystack )

     for ( let needleKey in needle ) {
            for ( let haystackKey in haystack ) {
                if ( needleKey === haystackKey && needle [ needleKey ]  > haystack [ haystackKey ] )  {
                    console.log (  '37. Niespełniony warunek: ' + needleKey + ': ' + needle [ needleKey ] )
                    console.log (  '_____________________________________________________________________'  )
                    return
                }
            }
     }

     console.log (  '_____________________________________________________________________'  )
     return haystack
 }

 console.log ( isArrayInArray ( needle, haystack,  [  ] ) )


______________________________________________________________________________________________
424) Filtrowanie obiektem tablicy obiektów + ustawianie kolejności

            Skrypt przyjmujący zapytanie i zwracający spełniającego je resultseta

            Po dopieszczeniu, można go umieścić na webtask.io i odpalać jako
            mockup jsonowej bazy danych ( read-only )

            Gdy przychodzi zapytanie, zwracane rekordy muszą:
               a) zawierać wszystkie wymagane języki
               b) wymagane języki muszą być na wymaganym poziomie
               c) zawierać języki w tej samej kolejności, co w zapytaniu  ( query: Java,  C    resp:  Java, C,  pozostały )

            W poniższym przykładzie, komentuj i odkomentuj kolejne 'let needle'

            haystack - to baza rekordów o programistach
            needle - wymaganiami co do znajomości języków

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

var haystack =  [
{ "id":1,"arr": { "Java": "4", "Go": "2" , "C":"5" } },
{ "id":2,"arr": { "C":"2","Go":"1", "Java":"5" } },
{ "id":3,"arr": { "Java":"4","C":"4","C++":"2" }  }
]

let needle = {  }
//let needle = { "C": "1" }
//let needle = { "C": "1", "Java": "1" }
//let needle = { "C": "2", "Java": "4", "Go": "2" }
//let needle = { "C": "1", "Java": "1", "Go": "1" }

var needleKeys =   Object.keys ( needle )
var needleKeysLen = needleKeys.length

var resultSet = haystack.filter ( function ( haystackRow ) {

        if  (  needleKeysLen  === 0 )  {
            return haystackRow
        }
        else if  (  needleKeysLen  === 1 && haystackRow.arr [ needleKeys [ 0 ]  ]  >=  needle [ needleKeys [ 0 ]  ] )  {
            haystackRow.skill_A = needleKeys [ 0 ]
            haystackRow.rank_A = haystackRow.arr [ needleKeys [ 0 ] ]

            var haystackKeys =   Object.keys ( haystackRow.arr )

            haystackKeysSkill_A = haystackKeys.indexOf ( needleKeys [ 0 ]  )
            haystackKeys.splice ( haystackKeysSkill_A, 1 )

            haystackRow.skill_B = haystackKeys [ 0 ]
            haystackRow.rank_B = haystackRow.arr [ haystackKeys [ 0 ] ]

            haystackRow.skill_C = haystackKeys [ 1 ]
            haystackRow.rank_C = haystackRow.arr [ haystackKeys [ 1 ] ]

            //console.log ( 'haystackKeys = ',  haystackKeys )
            return haystackRow
        }
        else if  (  needleKeysLen  === 2 &&
               haystackRow.arr [ needleKeys [ 0 ]  ]  >=  needle [ needleKeys [ 0 ]  ] &&
               haystackRow.arr [ needleKeys [ 1 ]  ]  >=  needle [ needleKeys [ 1 ]  ]
        )  {
            haystackRow.skill_A = needleKeys [ 0 ]
            haystackRow.rank_A = haystackRow.arr [ needleKeys [ 0 ] ]

            haystackRow.skill_B = needleKeys [ 1 ]
            haystackRow.rank_B = haystackRow.arr [ needleKeys [ 1 ] ]

            var haystackKeys =   Object.keys ( haystackRow.arr )

            haystackKeysSkill_A = haystackKeys.indexOf ( needleKeys [ 0 ]  )
            haystackKeys.splice ( haystackKeysSkill_A, 1 )

            haystackKeysSkill_B = haystackKeys.indexOf ( needleKeys [ 1 ]  )
            haystackKeys.splice ( haystackKeysSkill_B, 1 )


            haystackRow.skill_C = haystackKeys [ 0 ]
            haystackRow.rank_C = haystackRow.arr [ haystackKeys [ 0 ] ]

            return haystackRow
        }
        else if  (  needleKeysLen  === 3 &&
               haystackRow.arr [ needleKeys [ 0 ]  ]  >=  needle [ needleKeys [ 0 ]  ] &&
               haystackRow.arr [ needleKeys [ 1 ]  ]  >=  needle [ needleKeys [ 1 ]  ] &&
               haystackRow.arr [ needleKeys [ 2 ]  ]  >=  needle [ needleKeys [ 2 ]  ]
        )  {

            haystackRow.skill_A = needleKeys [ 0 ]
            haystackRow.rank_A = haystackRow.arr [ needleKeys [ 0 ] ]

            haystackRow.skill_B = needleKeys [ 1 ]
            haystackRow.rank_B = haystackRow.arr [ needleKeys [ 1 ] ]

            haystackRow.skill_C = needleKeys [ 2 ]
            haystackRow.rank_C = haystackRow.arr [ needleKeys [ 2 ] ]

            return haystackRow
        }
} )
.map ( function ( item ) {

    console.log( item )
} )


// console.log( resultSet )

______________________________________________________________________________________________
426) commonjs vs requirejs vs amd

      stackoverflow.com/questions/16521471/relation-between-commonjs-amd-and-requirejs

      Both CommonJS and AMD are just two different techniques how to overcome
      the JS "defect" to load modules  ( aka modules specifications  ( CommonJS - more ( I/O,  filesystem, promises )  )

      AMD      ---> implementation: RequireJS  ( async ) = more used on the client-side  ( but server is posible)
      CommonJS ---> implementation: Node       ( sync )  = more on the server  ( but client is possible )

      The short answer would be:
      CommonJS and AMD are specifications (or formats) on how modules and their dependencies
      should be declared in javascript applications.
      RequireJS is a script loader library that is AMD compliant

      CommonJS is a project to define a common API and ecosystem for JavaScript.

      One part of CommonJS is the Module specification.
      Node.js and RingoJS are server-side JavaScript runtimes, and they implement modules based on the CommonJS module spec.

      AMD (Asynchronous Module Definition) is another specification for modules.
      RequireJS is probably the most popular implementation of AMD.
      One major difference from CommonJS is that AMD specifies that modules are loaded asynchronously

      That means modules are loaded in parallel, as opposed to blocking the execution by waiting for a load to finish.

      AMD is generally more used in client-side (in-browser) due to this,
      and CommonJS Modules are generally used server-side.

      However, you can use either module spec in either environment

      For example, RequireJS offers directions for running in Node.js,
      and browserify is a CommonJS Module implementation that can run in the browser.

      AMD:
          Asynchronous , so browser-first approach
          It doesn't have any concept of File I/O.
          It supports objects, functions, constructors, strings, JSON and many other types of modules.

      CommonJS:
          Synchronous,  so server-first approach
          Cover a broader set of concerns such as I/O, File system, Promises and more.
          Supports unwrapped modules, it can feel a little more close to the ES6 specifications,
              freeing you of the define() wrapper that AMD enforces.
          Only support objects as modules.


 -  -  -  -  -  -  -  common.js  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

 var lib = require( "package/lib" )

 function foo(){
     lib.log( "hello world!" );
 }

 exports.foobar = foo

 -  -  -  -  -  -  -  amd compliant  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

 define ( [ "package/lib" ], function ( lib ) {

     function foo() {
         lib.log( "hello world!" );
     }

     // export (expose) foo to other modules as foobar

     return {
         foobar: foo
     }
 })


// Somewhere else the module can be used with:

 require ( [ "package/myModule"], function ( myModule ) {
     myModule.foobar ( )
 } )
______________________________________________________________________________________________
427) Mocha

      Test framework for node & browser

        a) yarn add mocha
        b) mkdir test && cd test
        c) touch test.js

        d) package.json  -  dopisz:

              "scripts": {
                  "test": "mocha"
                }

        e) wbij:

              var assert = require ( 'assert' )
              describe ( 'Array', function( ) {
                describe ( '#indexOf ( )', function ( ) {
                  it('should return -1 when the value is not present', function ( ) {
                    assert.equal ( -1, [ 1, 2, 3 ].indexOf ( 4 ) )
                  } )
                } )
              } )

          f) yarn test
______________________________________________________________________________________________
428) Chai

        Assertion library for node and browser

        yarn add chai

        Pozwala na używanie różnych stylów assertów:
            a) assert - classic
            b) expect - BDD
            c) should - podobny do expect

        var assert = chai.assert

        assert.typeOf ( foo, 'string' )
        assert.equal ( foo, 'bar' )
        assert.lengthOf ( foo, 3 )
        assert.property ( tea, 'flavors' )
        assert.lengthOf ( tea.flavors, 3 )

______________________________________________________________________________________________
429) modules in node  ( require )

        medium.freecodecamp.org/requiring-modules-in-node-js-everything-you-need-to-know-e7fbd119be8

        Bez użycia bundlera  ( np webpack, gulp ), w nodzie moduły importuje się przez require

        Require will assume your files are .js so it's optional to include the extension. You will still need to provide the path though if it's a local file and not a node package

-------- helpers.js --------------------------------------------------------------------

exports.sayHi = function (  ) {
    console.log ( 'Hi !' )
}

exports.kolory =  {
    piki: 'wina',
    kiery: 'czerwienie',
    kara: 'dzwonki',
    trefle: 'żołędzie'
}


-------- main.js --------------------------------------------------------------------

const helpers = require ( './helpers' )

console.log ( helpers.kolory )
console.log ( helpers.kolory.piki )
helpers.sayHi (  )

______________________________________________________________________________________________
430) encoding URI

      https://stackoverflow.com/questions/332872/encode-url-in-javascript

    Masz 3 możliwości:
      a) escape() will not encode: @*/+                   - deprecated; converts non-ASCII chars into Unicode escape sequences, like %uxxx
      b) encodeURI() will not encode: ~!@#$&*()=:/,;?+'   - use UTF-8; nie koduje "#", "?", and "&"
      c) encodeURIComponent() will not encode: ~!*()'     - use UTF-8 - najlepsze

    If you want to pass a URL into a GET parameter of other page, use escape or encodeURIComponent,
    but not encodeURI

    Use encodeURIComponent for the values in the query string (not fields/value names and not entire URL
    If you do it any other way it won't encode characters like =, ?, &

    Many APIs want to replace " " with "+" so I use the following:
      encodeURIComponent(value).replace(/%20/g,'+');

---------------------------------------------------------------------------
440) Webpack 4

      yarn add webpack webpack-cli webpack-dev-server

      a) stwórz katalog src a w nim plik index.js

      b) stwórz katalog index.html a w nim linijkę
          <script src='index.js></script>

      c) do package.json dodaj
          script: dev-server: webpack-dev-server

      d) odpal komendę
          yarn dev-server

---------------------------------------------------------------------------
441) moment

      yarn add moment

    --------------------------------------------
      const moment = require('moment')

      const x = moment().format('DD-MM-YYYY')    // 08-05-2019
      const y = moment().format('DD-MMM-YYYY')   // 08-May-2019
      const z  = moment().format('D-M-YY')       // 8-5-19

      const a = moment('2005-12-13').format('MMMM Do YYYY, h:mm:ss a') // December 13th 2005, 12:00:00 am
      const b = moment().format('d')  // 3 = środa
      const c = moment().format('[The year is] YYYY')  // The year is 2019
      const d = moment('20111031', 'YYYYMMDD').fromNow()  // 8 years ago
      const e = moment().startOf('day').fromNow()  // 18 hours ago
      const f = moment().startOf('month').fromNow()  // 8 days ago
      const g = moment().endOf('month').fromNow()  // in 23 days
      const h = moment().subtract(10, 'days').calendar()  // 04/28/2019
      const i = moment('2019-05-07').subtract(10, 'weeks').calendar() // 02/26/2019
      const j = moment().add(10, 'years').calendar() //05/08/2029

----------------------------------------------------------------------------
442) snyk

      Szuka bugów w bibliotekach i sugeruje ich zdrowe wersje

      a) yarn global add snyk
      b) snyk test lub snyk wizard

___________________________________________________________________________________________
443) parcel

      Tuba (Mead) - Parcel a zero config Webpack Alternative (dodawanie pluginów babel'a)
      Tuba - Quick Start Guide to Parcel
            (ustawienie prefixera poprzez PostCSS; poprawka w stosunku do wersji dokumentacji)

      parceljs.org/getting_started.html

      Zero-config bundler z live reloadem (HMR)

      yarn global add parcel-bundler

      Stwórz poniższe pliki, kliknij w ikonkę 'Watch Sass' w dolnej belce vs coda, odpal:
        parcel index.html

      .. i obejrzyj wynik na localhost:1234

      Jeśli odkomentujesz w index.js linię:
        // import './style.scss'

      .. będziesz mógł wyrzucić z index.html, linię:
          <link rel="stylesheet" href="style.css">
      .. bo yarn ściągnie z npm paczkę 'sass'. Dzięki temu, możesz nie używać ikony 'Watch Sass',
      bo Parcel będzie swym HMRem kompilował ściągniętą bibliotekę sass

      Build:
        "start": "parcel build index.js"   // wklej do package.json / scripts, lub ..
        "build": "parcel build index.html --no-cache --out-dir=build --no-source-maps"  // odpal z głównego katalogu projektu
        "build": "parcel build index.html --no-cache --out-dir=public --no-source-maps"  // odpal z głównego katalogu projektu

         yarn build
         cd build
         klik w vscode 'Go Live' batona w dolnej belce

      ----------- index.html ------------------------------------

          <link rel="stylesheet" href="style.css">
          <script src="./index.js"></script>
        </head>

        <body>
          <h1>Parcel 1</h1>
        </body>

      ----------- index.js ------------------------------------

        // import './style.scss'

        console.log('Parcel !')

      ----------- style.scss ------------------------------------

        $col1: brown;

        body {
          color: $col1;
          background: url('https://unsplash.it/id/1/300/400');
        }
___________________________________________________________________________________________
444) sanitizing

      const sanitizeString = str => str.replace(/[^a-z0-9áéíóúñü \.,_-]/gim,"").trim()

      const str = "  <script>  alert  ( '  dupa  ' )  </script>  "
      console.log(sanitizeString(str))  // script  alert     dupa     script
___________________________________________________________________________________________
445) axios w browserze

      Axios nie zadziała w skrypcie js na stronie index.html
      jeśli zaimportujemy go przez import ani require

      W tym celu, trzeba zaimportować go w index.html, przez:
        <script src="https://unpkg.com/axios/dist/axios.min.js"></script>

     Tylko, że wtedy dostaje się bład CORSa ..

     Request has been blocked by CORS policy:
     Response to preflight request doesn't pass access control check:

     No 'Access-Control-Allow-Origin' header is present on the requested resource.

     Pomogło:
      klik w ikonkę chroma > tab Shortcut > Target:

      "C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"

      .. i dodanie na końcu:

       --disable-web-security --user-data-dir=""
___________________________________________________________________________________________
446) email validation

      const isValid = str => !!str.match(/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/gim)

      console.log(isValid('dupa@gmail.com'))  // true
      console.log(isValid('dupagmail.com'))  // false

___________________________________________________________________________________________
447) lazysizes (lazy loading images)

      Wczytywanie początkowe tylko obrazków które widać
      Kolejne są wczytywane w miarę przewijania
      Im więcej obrazków ogółem, tym wieksza oszczędność czasu początkowego ładowania strony
      Paczka lazysizes = 3kB minimized


      a) zrób ileś linii z tagami <img>
      b) w tagu <img> ma być class="lazyload"
      c) .. i zamiast 'src' - 'data-src'
      d) na końcu dołącz import pakietu:
          <script src="https://unpkg.com/lazysizes@5.1.1/lazysizes.min.js"></script>


    -------- index.html -----------------------------------------------------

      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Lazy loading images</title>
        <style>
          body {
            max-width: 900px;
            margin: auto;
            padding: 100px;
          }

          img {
            max-width: 100%;
            margin-bottom: 100px;
          }

        </style>
      </head>
      <body>

        <div><img class="lazyload" data-src="https://picsum.photos/id/1/1600/900"></div>
        <div><img class="lazyload" data-src="https://picsum.photos/id/2/1600/900"></div>
        <div><img class="lazyload" data-src="https://picsum.photos/id/3/1600/900"></div>
        <div><img class="lazyload" data-src="https://picsum.photos/id/4/1600/900"></div>
        <div><img class="lazyload" data-src="https://picsum.photos/id/5/1600/900"></div>
        <div><img class="lazyload" data-src="https://picsum.photos/id/6/1600/900"></div>
        <div><img class="lazyload" data-src="https://picsum.photos/id/7/1600/900"></div>
        <div><img class="lazyload" data-src="https://picsum.photos/id/8/1600/900"></div>
        <div><img class="lazyload" data-src="https://picsum.photos/id/9/1600/900"></div>
        <div><img class="lazyload" data-src="https://picsum.photos/id/10/1600/900"></div>
        <div><img class="lazyload" data-src="https://picsum.photos/id/11/1600/900"></div>
        <div><img class="lazyload" data-src="https://picsum.photos/id/12/1600/900"></div>
        <div><img class="lazyload" data-src="https://picsum.photos/id/13/1600/900"></div>

        <script src="https://unpkg.com/lazysizes@5.1.1/lazysizes.min.js"></script>
      </body>
      </html>

___________________________________________________________________________________________
448) picsum.photos

      Przykładowe obrazki do mockowania na stronie

        https://picsum.photos/200/300         // losowy obrazek 200 na 300
        https://picsum.photos/200             // losowy obrazek 200 na 200 (kwadrat)
        https://picsum.photos/id/237/200/300  // obrazek id=237, 200 na 300

        https://picsum.photos/200/300?random=1  // losowy obrazek, ale za kazdym razem inny (nie keszowany)
        https://picsum.photos/200/300?random=2
___________________________________________________________________________________________
449) masonry / macy

      Galeria obrazków wypełniająca cały ekran
      Minimized = 3 kB

    -------- index.html -----------------------------------------------------

      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <script src="https://cdn.jsdelivr.net/npm/macy@2.5.0/dist/macy.min.js"></script>
        <title>Lazy loading images</title>
        <style>
          .container {
            width: 80%;
            margin: 120px auto;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <img src="https://picsum.photos/602/660?random=1">
          <img src="https://picsum.photos/660/646?random=2">
          <img src="https://picsum.photos/741/375?random=3">
          <img src="https://picsum.photos/813/455?random=4">
          <img src="https://picsum.photos/470/896?random=5">
          <img src="https://picsum.photos/664/653?random=6">
          <img src="https://picsum.photos/708/313?random=7">
          <img src="https://picsum.photos/738/578?random=8">
          <img src="https://picsum.photos/458/482?random=9">
          <img src="https://picsum.photos/439/856?random=10">
          <img src="https://picsum.photos/549/315?random=11">
          <img src="https://picsum.photos/877/693?random=12">
        </div>

        <script>
          const masonry = new Macy({
            container: '.container',
            mobileFirst: true,
            columns: 1,
            breakAt: {
              400: 2,
              700: 3,
              1000: 4
            },
            margin: {
              x: 10,
              y: 10
            }
          })
        </script>

      </body>
      </html>

___________________________________________________________________________________________
450) cookies

      Chrome > devtools > Application > Cookies
      Są one tamn w formacie: key - value
      Poniższa funkcja 

      function getCookie(key) {
        var name = key + "=";
        var decodedCookie = decodeURIComponent(document.cookie);
        var ca = decodedCookie.split(';');
        for(var i = 0; i <ca.length; i++) {
          var c = ca[i];
          while (c.charAt(0) == ' ') {
            c = c.substring(1);
          }
          if (c.indexOf(name) == 0) {
            return c.substring(name.length, c.length);
          }
        }
        return "";
      }

      console.log(getCookie('_pk_id.136.9242')) // d59025a1ae5e65e4.1570087472.1.1570087472.1570087472.



___________________________________________________________________________________________
500) Algo - primes

    Znajdź wszystkie liczby pierwsze począwszy od 1 do podanej liczby

    const arr = [1]

    function isPrime(number) {
      if(number < 2) return
      number = Math.round(number)
      for (let i = number - 1; i > 1; i--) {
        if(number % i === 0) return false
      }
      return true
    }

    function primes(number) {
      for (let i = 2; i < number + 1; i++) {
        if(isPrime(i)) arr.push(i)
      }
      return arr
    }

    console.log(primes(13))

------------------------------------------------------------------------------
501) Algo - highAndLow

     Znajdź największą i najmniejszą liczbę z podanego stringa:

    highAndLow("4 5 29 54 4 0 -214 542 -64 1 -3 6 -6")

    function highAndLow(numbers){
      const arr = numbers.split(' ').map(Number)
      console.log(arr)
      const max = Math.max(...arr)
      const min = Math.min(...arr)

      return hi + ' ' + lo
    }

------------------------------------------------------------------------------
502) Algo - jedyna parzysta

  Znajdź jedyną liczbę nieparzystą wśród parzystych i vice versa

    console.log(findOutlier([3, 5, 11, 100, 9, 33 ]))  // 100
    console.log(findOutlier([2, 6, 9, 100 ]))  // 11

function findOutlier(array) {
  const even = array.filter(el => el % 2 === 0)
  const odd = array.filter(el => el % 2 !== 0)
  return even.length === 1 ? even[0] : odd [0]
}
------------------------------------------------------------------------------
503) Algo - kill vowels

    function killVowels(str) {
      const word = str.split('')
      const vowels = ['a','e', 'i', 'o', 'u']

      let newWord = word.filter(el => {
        if(!vowels.includes(el) && !vowels.includes(el.toLowerCase()) ) return el
      })

      return newWord.join('')
    }

    console.log(killVowels('This website is for losers LOL!'))

        albo:

        function killVowels(str) {
          return str.replace(/[aeiou]/gi, '');
        }

------------------------------------------------------------------------------
504) Algo - Exes and Ohs

    Czy taka sama jest ilość 'x' i 'o' niezaleznie duże czy małe

    function XO(str) {
      const arr = str.split('')
      const oLength = arr.filter(el => (el === 'o' || el === 'O')).length
      const xLength = arr.filter(el => (el === 'x' || el === 'X')).length

      return oLength === xLength
    }

    console.log(XO("ooxx"))
    console.log(XO("xooxx"))
    console.log(XO("xxOo"))
    console.log(XO("ooom"))

        albo:

          function XO(str) {
            let x = str.match(/x/gi)
            let o = str.match(/o/gi)
            return (x && x.length) === (o && o.length)
          }

------------------------------------------------------------------------------
505) Algo - find the divisors

  function divisors(num) {
    const divisors = []
    for(let i = 2; i < parseInt(num/2) + 1; i++) {
      if(num % i === 0) divisors.push(i)
  }

    return divisors.length === 0 ? num + ' is prime' : divisors
  }

  console.log(divisors(13)) // 12 should return [2,3,4,6]
------------------------------------------------------------------------------
506) Algo - Printer Errors

    Kody 'a' do 'm' są ok, od 'o' są kody błędów

  function error_printer(str) {
    const totalCount = str.length
    const errorsCount = str.split('').filter(el => el > 'm').length

    return errorsCount + ' / ' + totalCount
  }

  const s="aaaxbbbbyyhwawiwjjjwwm"
  console.log(error_printer(s))

  /*
  s="aaabbbbhaijjjm"
  error_printer(s) => "0/14"

  s="aaaxbbbbyyhwawiwjjjwwm"
  error_printer(s) => "8/22"
  */

------------------------------------------------------------------------------
507) Algo - scramblies

    function scramble(str1, str2) {
      for(let i = 0; i < str2.length; i++) {

        if(str1.includes(str2[i])) {
          str1 = str1.replace(str2[i],'')
        }
        else {
          return false
        }
      }

      return true
    }

    console.log(scramble('wrkqodlw', 'wworld'))  // True

------------------------------------------------------------------------------
508) Algo - Pete, the baker

    Pierwszy obiekt zawiera przepis, drugi - składniki. Policz ile ciast wyjdzie

    function cakes(x, y) {

      const arr = []
      const ingredients = Object.keys(x)

      ingredients.filter(el => {
        arr.push(y[el] / x[el])
      })

      return parseInt(Math.min(...arr)) || 0
    }

    console.log(cakes({flour: 500, sugar: 200, eggs: 1}, {flour: 1200, sugar: 1200, eggs: 5, milk: 200}))
    //console.log(cakes({apples: 3, flour: 300, sugar: 150, milk: 100, oil: 100}, {sugar: 500, flour: 2000, milk: 2000}))

------------------------------------------------------------------------------
509) Algo - count sheeps

    function countSheeps(arr) {
      return arr.reduce((sum, item) => {
        if(item === undefined) item = 0
        return sum + item
      })

    }

    const arr = [
      true,  true,  true,  false,
      true,  true,  true,  true ,
      true,  false, true,  false,
      true,  false, false, true ,
      true,  true,  true,  true ,
      false, false, true,  true, null, null, undefined, undefined
    ]

    console.log(countSheeps(arr))

------------------------------------------------------------------------------
510) Algo - fibo

    function fibo(n) {
      const arr = [ 0, 1 ]
      for (let i = 2; i < n; i++) {
        arr.push(arr[i - 2] + arr[i - 1])
      }

      return arr
    }


    console.log(fibo(6))

------------------------------------------------------------------------------
511) Algo - primes

    function prime(n) {
      for (let i = parseInt(n / 2); i > 1; i--) {
        if(n % i === 0) return false
      }

      return true
    }

    function allPrimes(num) {
      for (let i = 1; i < num + 1; i++) {
        if(prime(i)) console.log(i)
      }
    }

    console.log(allPrimes(12))
______________________________________________________________________________
512) Algo - silnia (factorial)

      function factor(num) {
        if (num <= 0 ) throw new Error('Liczba musi być > 0')
        if (!Number.isInteger(num)) throw new Error('Musi to być liczba całkowita')

        let sum = 1

        for (let i = 1; i < num + 1; i++) {
          sum = sum * i
        }

        return sum
      }

      console.log(factor(4))

______________________________________________________________________________
513) Algo - różnica tablic

      function arrDiff(arr1, arr2) {
        return arr1.filter(el => {
          return !arr2.includes(el)
        })
      }

      const arr1 = [1, 2, 3, 4]
      const arr2 = [1, 2, 3, 5]

      console.log(arrDiff(arr1, arr2))  // [4]
______________________________________________________________________________
514) Algo - iloczyn tablic

    function arrDiff(arr1, arr2) {
      return arr1.filter(el => {
        return arr2.includes(el)
      })
    }

    const arr1 = [1, 2, 3, 4]
    const arr2 = [1, 2, 3, 5]

    console.log(arrDiff(arr1, arr2))  // [1, 2, 3]


______________________________________________________________________________
520) Algo - Codility: Lesson 1 - BinaryGap

      app.codility.com/programmers/lessons/1-iterations/

      Find longest sequence of zeros in binary representation of an integer.

    --------------------------------------------------
      function longestZeroes(num) {
        const zeroesCounts = []
        const binary = num.toString(2)
        console.log('binary = ' , binary)

        const arr = binary.split('')
        console.log('arr = ' , arr)

        const onesArr = arr.map((el, ix) => {
          if (el === '1' ) return ix
        }).filter(el => el !== undefined)

        onesArr.push(binary.length)

        console.log('onesArr = ' , onesArr)

        for (let i = 0; i < onesArr.length - 1; i++) {
          zeroesCounts.push(onesArr[i+1] - onesArr[i] -1)
        }

        return Math.max(...zeroesCounts)

      }

      console.log(longestZeroes(42048))

      // console.log(parseInt('1010010001000000', 2))

______________________________________________________________________________
521) Algo - Codility: Lesson 2/1 - OddOccurrencesInArray

      app.codility.com/programmers/lessons/2-arrays/

      Find value that occurs in odd number of elements.

      ------------------------------------------------
        const str = '122333344'
        let re = ''

        const uniq = [... new Set(str.split(''))]
        console.log('uniq = ' , uniq)

        const count = uniq.map(el => {
          re = new RegExp(el, 'g');
          return str.match(re)
        }).map(el => {
          return { letter: el[0], count: el.length }
        }).filter(el => el.count % 2 !== 0)

        console.log('result = ' , count)  // [ { letter: '1', count: 1 } ]

______________________________________________________________________________
522) Algo - Codility: Lesson 2/2 - CyclicRotation

      Rotate an array to the right by a given number of steps.

        const arr = [1, 2, 3, 4]

        function move(arr, times) {
          for (let i = 1; i <= times + 1; i++) {
            console.log(arr)
            arr.unshift(arr.pop())
          }

          return arr
        }

        move(arr, 4)
______________________________________________________________________________
600) DOM - tips

    1) sprawdzenie propertek elementu:
         const items = document.getElementsByClassName('lista')
         console.log('items = ' , items)
       .. i w devtoolsach rozwinąć obiekt

______________________________________________________________________________________________
601) DOM - interwiucha

      Dlaczego to nie działa:

        <button>KlikMi</button>

        <script>
          const counter = {
            cnt: 0,
            inc: function() {
              cnt++
              console.log(cnt)
            }
          }

          const button = document.getElementsByName('button')[0]
          button.addEventListener('click', counter.inc(), false)
        </script>

       Odp:
            a) zamiast cnt++ powinno być this.cnt++ (i console.log(this.cnt))

            b) zamiast:
                 button.addEventListener('click', counter.inc(), false)
               powinno być:
                 button.addEventListener('click', counter.inc.bind(counter), false)

______________________________________________________________________________________________
602) DOM - access methods

      Tuba - Traversy: JS DOM Crash Course - Part 1

      jQuery znak $, to skrót od JS'owego document.querySelector. Reszta jest taka sama

      document.
        1) getElementById('dupa')          <tag id='dupa'>
        2) getElementByClass('dupa')       <tag class='dupa'>
        3) getElementsByTagName('div')        <div> unikaj divów, bo b wolne - bo mnóstwo divów
        4) getElementName('koza')          <div name='koza>
        5) querySelector(#car)             bierze tylko 1 css'owy selektor, albo zwraca tylko 1-szy znaleziony element
        6) querySelectorAll('#car, .high)  może mieścić klasy i id, rozdzielone przecinkami

    --------- index.html -----------------------------------------------------------------

      <p id="dupa">1. To paragraf z id</p>
      <p class="nasaklasa">2. To paragraf z klasą</p>
      <div id="demo1">3. To div z id</div>
      <div id="demo2" class="memo">4. To div z id i klasą</div>


      <ul id='ul' style="width: 200px; height: 200px; background: green">
        <li class="lista">item 1</li>
        <li class="lista">item 2</li>
        <li class="lista">item 3</li>
      </ul>

      <input id="baton" type="button" value="Placeholder">

      <select>
        <option value="1">Jeden</option>
        <option value="2">Dwa</option>
        <option value="3">Trzy</option>
      </select>

      <form id="foremka">
        <input type="submit" value="Submit">
      </form>


      <script>
        console.log(document.getElementById('dupa').innerText)
        console.log(document.getElementById('dupa').innerHTML)

        console.log((document.getElementsByClassName('nasaklasa')[0].innerText))
        console.log((document.getElementsByClassName('nasaklasa')[0].innerHTML))

        console.log((document.getElementsByTagName('p')[0].innerText))
        console.log((document.getElementsByTagName('p')[1].innerHTML))

        console.log((document.querySelector('#demo1').innerHTML))
        console.log((document.querySelector('.memo').innerHTML))

        document.querySelector('#demo1').innerHTML = '<h2>innerHTML</h2>'
        document.querySelector('#demo2').textContent = 'textContent'

        document.querySelector('#demo2').style.border = '1px solid red'

        document.querySelector('#ul').style.color = 'green'
        document.querySelector('.lista').style.color = 'red'  // zakomentuj
        document.querySelector('li').style.color = 'blue'

        document.querySelectorAll('#demo1, .memo')[0].style.color = 'red'
        document.querySelectorAll('#demo1, .memo')[1].style.color = 'green'

        const items = document.getElementsByClassName('lista')
        // const items = document.getElementsByTagName('li')  // jak wyżej tylko w wersji ByTagName

        console.log('items = ' , items.length)
        console.log(items[0].style.color)

        document.querySelector('input[type="button"]').value = 'SEND'

      </script>
______________________________________________________________________________________________
603) DOM - :first-child, :last-child, :nth-child, firstElementChild, lastElementChild

      Tuba - Traversy: JS DOM Crash Course - Part 1

      nth-child(number) - tablica 1-based

      Wygląda, że :first-child, :last-child, :nth-child działają tylko z querySelector'em
      Za to firstElementChild, lastElementChild - na każdy, tylko przy klasie trzeba stawiać [index]

      document.querySelector('.lista:first-child').style.color = 'green'
      document.querySelector('.lista:last-child').style.color = 'blue'
      document.querySelector('.lista:nth-child(2)').style.color = 'red'

      document.querySelector('#ul').firstElementChild.style.color = 'blue'
      document.querySelector('#ul').lastElementChild.style.color = 'red'
______________________________________________________________________________________________
604) DOM - iteracja

      Tuba - Traversy: JS DOM Crash Course - Part 1

      for (let i = 0; i < items.length; i++) {
        items[i].style.backgroundColor = '#0f0'  // koniecznie w cudzysłowie
      }
______________________________________________________________________________________________
605) DOM - traversing: parentElement / parentNode

      Tuba - Traversy: JS DOM Crash Course - Part 2

      const itemList = document.querySelector('.lista')
      console.log('itemList = ' , itemList.parentElement)

      itemList.parentNode.style.color = 'red'
______________________________________________________________________________________________
606) DOM - traversing: children

      Tuba - Traversy: JS DOM Crash Course - Part 2

      'children' to tablica (zero-based)

      document.querySelector('#ul').children[2].style.color = 'red'

    -----------------------------------------------------------------

      <div id='kupa'> Div 1
        <div> Div 2
          <div>Div 3</div>
        </div>
      </div>

     const x = document.getElementById('kupa').children[0].children[0].style.color = 'red'
______________________________________________________________________________________________
607) DOM - innerText, innerHTML, textContent

      Jeśli nie ma kontroli nad osadzanym tekstem (np tekst przychodzący od juzka),
      to lepiej użyć innerText lub textContent
______________________________________________________________________________________________
608) DOM - nextElementSibling, previousElementSibling

      Tuba - Traversy: JS DOM Crash Course - Part 2

      document.querySelector('p').nextElementSibling.style.color = 'blue'
      document.querySelector('div').previousElementSibling.style.color = 'blue'
_______________________________________________________________________________________________
609) DOM - createElement (id, class, setAttribute), createTextNode, appendChild, insert.., replace

      Tuba - Traversy: JS DOM Crash Course - Part 2

      Tworzenie nowego node'a

      I wklejanie go przed i po:
         a) tagu
         b) tagu z id
         c) tagu z  klasą
         d) i na końcu dokumentu

      UWAGA !
        Tam gdzie selektor wybiera więcej niż 1 element,
        na końcu selektora trzeba dopisać indeks tablicowy:

          document.getElementsByClassName('memo')[0]
          document.getElementsByTagName('input')[0]

      ------- wersja krótka --------------------------------------------------------

      const newDiv = document.createElement('div')
      const newDivText = document.createTextNode(' *** TEKST ***')
      newDiv.appendChild(newDivText)

      const dest = document.getElementById('demo2')
      document.body.insertBefore(newDiv, dest)

      ------- wersja długa --------------------------------------------------------

      const newDiv = document.createElement('div')
      console.log('newDiv = ' , newDiv)
      newDiv.className = 'klasa'
      newDiv.id = 'ajdi'
      newDiv.setAttribute('title', 'Newborn Div')

      const newDivText = document.createTextNode('***** NEW NODE *****')
      newDiv.appendChild(newDivText)

      /// const destination = document.getElementById('demo2')
      /// const destination = document.getElementsByClassName('memo')[0]
      /// const destination = document.getElementsByTagName('input')[0]
      console.log('destination = ' , destination)

      /// document.body.insertBefore(newDiv, destination)  // wstawia siblinga przed
      /// document.body.insertBefore(newDiv, destination.nextSibling)

      /// albo document.body.insertBefore(newDiv, destination).nextSibling

      /// destination.appendChild(newDiv)                  // wstawia childa
      /// document.body.append(newDiv)                     // wstawia diva w root'cie documentu

      /// document.body.replaceChild(newDiv, destination) // wymienia istniejący na podany

______________________________________________________________________________________________
610) DOM - events

      Tuba - Traversy: JS DOM Crash Course - Part 2

      Jako callback można dołączyć tylko zwykłą funkcję, arrow function nie działa

      Eventy działające na elemencie:
        a) button: click i dblclick
        b) input: focus, blur, mousedown, mouseup, keydown, keyup, cut, copy, paste
        c) inne: mouseenter, mouseover, mouseleave, mouseout, mousemove

      ---------------------------------------------------------------------
      const baton = document.getElementById('baton')
      baton.addEventListener('click', () => console.log('Kilkłeś batona'))

      ---------------------------------------------------------------------

      function klik() {
        console.log('Kilkłeś batona')
      }

      const baton = document.getElementById('baton')
      baton.addEventListener('click', klik)
______________________________________________________________________________
611) DOM - event object

      Tuba - Traversy: JS DOM Crash Course - Part 3

      Po kliku, jako parametr callbacka podawany jest eventObject
      Z ciekawszych propertek są współrzędne kliknietego ekranu,
      czy wciśnięte w chwili kliku, były klawisze: alt, ctrl i shift

        function klik(e) {
          console.log('e = ' , e)
          console.log('e.ctrlKey = ' , e.ctrlKey)
          console.log('e.shiftlKey = ' , e.shiftKey)
          console.log('e.altKey = ' , e.altKey)
          console.log('e.target = ' , e.target)
          console.log('e.type = ' , e.type)                 // click
          console.log('e.target.id = ' , e.target.id)       // baton
          console.log('e.target.type = ' , e.target.type)   // submit
          console.log('e.target.value = ' , e.target.value) // Placeholder
          console.log('Kilkłeś batona')

          const newDiv = document.createElement('div')
          const newDivText = document.createTextNode('*****' + e.target.value + '*****')
          newDiv.appendChild(newDivText)

          document.body.append(newDiv)
        }

        const baton = document.getElementById('baton')
        console.log('baton = ' , baton)

        // baton.addEventListener('click', () => console.log('Kilkłeś batona'))
        baton.addEventListener('click', klik)

______________________________________________________________________________
612) DOM - events: button

      click, dblclick, mousedown, mouseup

      Działają na chyba wszystkich elementach,
      np: button, div#id, div.class, p, ul, li

      Przy multielementach tzn innych niż tag#id, trzeba dodać indeks tablicowy, np:
        document.getElementsByClassName('memo')[0]

      ------------------------------------------------------------------
        function klik(e) {
          console.log('e.type = ' , e.type)                 // click
        }

        const baton = document.getElementById('baton')
        console.log('baton = ' , baton)

        // baton.addEventListener('click', klik)
        // baton.addEventListener('dblclick', klik)
        // baton.addEventListener('mousedown', klik)
        // baton.addEventListener('mouseup', klik)

______________________________________________________________________________________________
613) DOM - events: mouse

      mouseenter, mouseover, mouseleave, mouseout, mousemove

      const klik = e => console.log('e.type = ' , e.type)

      const ul = document.getElementById('ul')
      console.log('ul = ' , ul)

      ul.addEventListener('mouseenter', klik)  // oba przy wjechaniu w obszar
      ul.addEventListener('mouseover', klik)   // tylko ten po wjechaniu na dowolny element

      ul.addEventListener('mouseleave', klik)   // oba przy wyjechaniu z obszaru
      ul.addEventListener('mouseout', klik)    // tylko ten po wjechaniu na dowolny element

      ul.addEventListener('mousemove', klik)  // non-stop gdy mysz rusza się w obszarze

______________________________________________________________________________
614) DOM - events: <input>

      click, focus, blur, keydown, keyup, copy, cut, paste, input

     ---------------------------------------------------------------
      const inputBox = document.getElementById('email')
      console.log('inputBox = ' , inputBox)

      inputBox.addEventListener('click', e => console.log('e.type = ', e.type) )
      inputBox.addEventListener('focus', e => console.log('e.type = ', e.type) )
      inputBox.addEventListener('blur', e => console.log('e.type = ', e.type) )
      inputBox.addEventListener('keydown', e => console.log('e.target.value = ', e.target.value) )
      inputBox.addEventListener('keyup', e => console.log('e.target.value = ', e.target.value) )

      inputBox.addEventListener('copy', e => console.log('e.type = ', e.type) )
      inputBox.addEventListener('cut', e => console.log('e.type = ', e.type) )
      inputBox.addEventListener('paste', e => console.log('e.type = ', e.type) )

      inputBox.addEventListener('input', e => console.log('e.type = ', e.type)) // keydown, cut, paste
______________________________________________________________________________
615) DOM - events: form

      const form = document.getElementById('foremka')
      console.log('form = ' , form)

      form.addEventListener('submit', e => {
        e.preventDefault()
        e.stopPropagation()
        console.log('e.type = ', e.type)
      })

______________________________________________________________________________________________
616) DOM - event bubbling vs event capturing

      Tuba (sith) - Event Bubbling and Capturing in JS

      Oba dotyczą obsługi eventów, przy więcej niż jednym event handlerze
      Rozważmy nast sytuację. DOM z divami wygląda tak:

                                body

                                #main

                      click()   #parent

                  click() #child        #other

      Po kliku w #child, odpalany jest jego event, po czym event parenta
      Po kliku w #other - tylko event #parenta
      Po kliku w #parenta - jak wyżej

      Taka kolejność - to event bubbling (lowest first)

      Teraz, jeśli w komendzie eventListenera, dodamy na końcu 'true',
      będzie to oznaczało wybranie event capturing:

        el.addEventListener('click', () => {
          console.log('Tu #child')
        }, true)

      W event capturingu, kolejność odpalania eventów jest odwrotna,
      tzn od góry. I dlatego, po kliku w #child, najpierw odpalony zostanie
      event #parenta, a dopiero potem event #childa

      Podobnie, po kliku w #other, odpalony zostanie tylko event #parenta
      (highest first)

      Standardem w przeglądarkach jest używanie event bublingu

______________________________________________________________________________
620) DOM - form hello weird

      Przykładowa forma robiąca sanityzację, walidację i śląca axiosem POSTa na serwer:
        https://kupasiku.free.beeceptor.com'

      Style w scss

      UWAGA !!
        Wytnij komentarze i wzmień ww adres serwera

      -------- index.html --------------------------------

        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta http-equiv="X-UA-Compatible" content="IE=edge">
          <title>Registration</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <link rel="stylesheet" type="text/css" media="screen" href="style.css">
          <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
        </head>
        <body>

          <main>
            <div id="regForm">
              <h2>Registration Form</h2>

              <form name="form">
                <div><label for="name">Name</label></div>         <input name="name"/>
                <div><label for="password">Password</label></div> <input name="password" type="password"/>
                <div><label for="email">E-mail</label></div>      <input name="email"/>
                <div><label for="phone">Phone</label></div>       <input name="phone" type="number"/>
                <div><label for="address">Address</label></div>   <input name="address"/>
                <div><label for="comments">Comments</label></div> <textarea name="comments"/></textarea>

                <div>
                  <input type="submit" value="Send" name="submit">
                  <input type="reset" value="Reset" name="reset">
                </div>
              </form>

            </div>
          </main>

          <script src="index.js"></script>
        </body>
        </html>

      -------- style.scss ---------------------------------

        main {
          display: flex;
          justify-content: center;
          align-items: center;
          height: 100vh;
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif
        }

        #regForm {
          height: 85vh;
          width: 21vw;
          background: grey;
          padding-left: 30px;
          color: white;
          border-radius: 5px;
          box-shadow: 3px 5px 8px black;
          font-size: 1rem;
        }

        input, textarea {
          height: 3vh;
          width: 18vw;
          margin-bottom: 7px;
          box-shadow: 3px 5px 8px black;
          font-size: 0.8rem;
        }

        .button {
          margin-top: 15px;
          height: 35px;

          &:hover {
            background: darkgrey;
          }
        }

      -------- index.js ----------------------------------

        const form = document.getElementById('regForm')
        const sanitize = str => str.replace(/[^a-z0-9áéíóúñü \.,_-]/gim,"").trim()

        const formValidation = (name, password, email, phone, address, comments = '') => {
          name.value = sanitize(name.value)
          password.value = sanitize(password.value)
          phone.value = sanitize(phone.value)
          address.value = sanitize(address.value)
          comments.value = sanitize(comments.value)

          if (name.value === '') {
            alert('Please enter your name')
            name.focus()
            return false
          }

          if (password.value === '') {
            alert('Please enter your password')
            password.focus()
            return false
          }

          console.log('email.value = ' , email.value)
          console.log('isValid email.value = ', !!email.value.match(/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/gim))

          if (!email.value.match(/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/gim)) {
              alert('Please enter your valid e-mail address')
              email.focus()
              return false
          }

          if (phone.value === '') {
            alert('Please enter your phone number')
            phone.focus()
            return false
          }

          if (address.value === '') {
            alert('Please enter your address')
            address.focus()
            return false
          }

          return {
            name: name.value,
            password: password.value,
            email: email.value,
            phone: phone.value,
            address: address.value,
            comments: comments.value
          }
        }

        form.addEventListener('submit', e => {
          e.preventDefault()
          e.stopPropagation()

          const name = document.forms.form.name
          const password = document.forms.form.password
          const email = document.forms.form.email
          const phone = document.forms.form.phone
          const address = document.forms.form.address
          const comments = document.forms.form.comments

          console.log('name = ' , name.value)
          console.log('password = ' , password.value)
          console.log('email = ' , email.value)
          console.log('phone = ' , phone.value)
          console.log('address = ' , address.value)
          console.log('comments = ' , phone.comments)

          const obj = formValidation(name, password, email, phone, address, comments)
          console.log(obj)

          if (!obj) return false

          const url = 'https://kupasiku.free.beeceptor.com'

          axios.post(url, obj)
            .then(res => {
              console.log(res)
              alert('Thank you for the registration.\nYour data have just been saved on the server')
            })
            .catch(err => {
              console.log('Err: ', err)
              alert('Problem occured saving your info\nPlease check you internet connection, or try later')
            })
        })

______________________________________________________________________________
621) DOM - edipresse: ilość celi w tabeli

    Znajdź tabelę o max ilości td (cells)
    Poniżej, jedna = 9 td, deruga = 4 td, więc max = 9

    ---------------------------------------------------------------

    <div>
    <p>First table</p>
        <table>
            <tr>
                <td>First</td>
                <td>row</td>
            </tr>
            <tr>
                <td>and</td>
                <td>second</td>
                <td>row</td>
            </tr>
            <tr>
                <td>and</td>
                <td>the</td>
                <td>third</td>
                <td>one</td>
                <td>one</td>
            </tr>
        </table>
    </div>
    <p>Second table</p>
    <table>
        <tr>
            <td>Not</td>
            <td>so</td>
        </tr>
        <tr>
            <td>many</td>
            <td>cells</td>
            <td>cells</td>
            <td>cells</td>
        </tr>
    </table>

    ---------------------------------------------------------

    function solution() {
      let cellsCount = 0, maxCellsCount = 0
      const tables = document.getElementsByTagName('table')

      if (tables.length === 0) return 0


      for (let table of tables) {
        for (let row of table.rows) {
          // console.log(row.cells.length)
          cellsCount = cellsCount + row.cells.length
        }
        console.log('cellsCount = ' , cellsCount)
        if (cellsCount > maxCellsCount) maxCellsCount = cellsCount
        cellsCount = 0
      }

      return maxCellsCount
    }

    console.log(solution())
______________________________________________________________________________
700) PWA - tips

      1) utworzenie kesza i przechwycenie przezeń requesta z serwera

        a) odpal w devtoolsach
            caches.open('test-cache').then(cache => { cache.add('https://jsonplaceholder.typicode.com/users/')})

        b) w Network znajdź request 'users' i otwórz tab 'Preview'

        c) w Application > Cache Storage znajdź linię 'test-cache'

      2) Dev-tools > Application > klik Clear site data

      3) app.webmanifest

          Wg nowej konwencji, manifest zwie się app.webmanifest
          Dodaj go do workbox-config.js:

            "globPatterns": [
              "**/*.{css,js,png,html,webmanifest}"

      4) linki
          https://developers.google.com/web/tools/workbox/guides/common-recipes
          https://developers.google.com/web/fundamentals/web-app-manifest/
          https://developers.google.com/web/tools/chrome-devtools/progressive-web-apps
          https://pwafire.org/developer/pwa/started/#workbox
          https://pwafire.org/developer/docs/how-to-use-vscode-pwa-in-vscode/

      5) manifest generator
          https://app-manifest.firebaseapp.com/

      6) Lighthouse > PWA > 'content not sized correctly for viewport'
          a) ustaw devtoolsy na dole (a nie jak teraz po prawej)
          b) zmaksymalizuj okno

      7) By PWApka mogła być umieszczona na Google Pleju:
            a) strona musi być na https
            b) lighthouse performance musi > 80

      8) TWA will work only after a digital domain handshake with the application.
         The mechanism is known as Digital Assets Links

         Oznacza to, że w katalogu głównym apki musi być podkatalog /.well-known
         z plikiem assetlinks.json w formie:

          [{
            "relation": ["delegate_permission/common.handle_all_urls"],
            "target": {
              "namespace": "android_app",
              "package_name": "com.netlify.mk04",
              "sha256_cert_fingerprints":
              ["77:16:E5:FD:47:7F:A0:ED:07:3B:41:0E:B1:85:99:55:4B:79:CE:73:DF:21:A0:56:03:3C:F8:0A:92:D6:57:C5"]
            }
          }]

______________________________________________________________________________
701) PWA - hello weird

    -------- index.html ---------------------------------

      <header>
        Attendees
      </header>

      <div id="attendees"></div>

      <script src="app.js"></script>

      <script>
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('sw.js')
            .then(registration => {
              console.log(registration)
            })
            .catch(console.error)
        }
      </script>

    -------- app.css ---------------------------------

      body {
        margin: 0;
        background: #cfd8dc
      }

      header {
        background: #00897b;
        color: white;
        position: fixed;
        top: 0;
        right: 0;
        left: 0;
        padding: 10px 30px;
        font-size: 22px;
      }

      #attendees {
        margin-top: 60px;
      }

      .card {
        background: white;
        padding: 10px;
        margin: 20px;
        border-radius: 6px;
        box-shadow: 2px 2px 1px rgba(0, 0, 0, 0.8);
      }

    -------- app.js ---------------------------------

      const axios = require('axios')
      const attendees = document.querySelector('#attendees')


      axios.get('https://jsonplaceholder.typicode.com/users/')
        .then(res => {
          console.log(res.data)
          let html = ''
          res.data.map(user => {
            html += '<div class= "card"' + '<h2>' + user.name + '</h2><h4>'
              + user.email + '</h4></div>';
          })

          attendees.innerHTML = html
        })


        .catch(err => console.log('Erroras:', err))

      //! caches.open('test-cache').then(cache => { cache.add('https://jsonplaceholder.typicode.com/users/')})

    -------- sw.js ---------------------------------

      self.addEventListener('install', event => {
        event.waitUntil(
          caches.open('precache-v1').then(cache => {
            cache.addAll(['/', 'app.js'])
          })
        )
      })

      self.addEventListener('fetch', event => {
        event.respondWith(
          caches.match(event.request).then(response => {
            return response || fetch(event.request)
          })
        )
      })
______________________________________________________________________________________________
702) PWA - caching strategies

      medium.com/@krukmat/workbox-improving-the-pwa-4a5f5bda8c9d
      https://developers.google.com/web/tools/workbox/guides/common-recipes

        1) Stale While Revalidate (js, css i fonts)

            workbox.routing.registerRoute(
              /\.(?:js|css)$/,
              workbox.strategies.staleWhileRevalidate({
                cacheName: 'static-resources',
              })
            )

            workbox.routing.registerRoute(
              /^https:\/\/fonts\.googleapis\.com/,
              new workbox.strategies.StaleWhileRevalidate({
                cacheName: 'google-fonts-stylesheets',
              })
            );

        2) Network First (treść)

            workbox.routing.registerRoute(
              'https://hacker-news.firebaseio.com/v0/api',
              workbox.strategies.networkFirst({
                  networkTimeoutSeconds: 3,
                  cacheName: 'stories',
                  plugins: [
                    new workbox.expiration.Plugin({
                      maxEntries: 50,
                      maxAgeSeconds: 5 * 60, // 5 minutes
                    }),
                  ],
              })
            )

        3) Cache First (obrazki)

            workbox.routing.registerRoute(
              /\.(?:png|gif|jpg|jpeg|svg)$/,
              workbox.strategies.cacheFirst({
                cacheName: 'images',
                plugins: [
                  new workbox.expiration.Plugin({
                    maxEntries: 60,
                    maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
                  }),
                ],
              })
            );

        4) Network Only (form POST to backend)

            const bgSyncPlugin = new workbox.backgroundSync.Plugin('myQueueName', {
              maxRetentionTime: 24 * 60 // Retry for max of 24 Hours
            })

            workbox.routing.registerRoute(
              /\/api\/.*\/*.json/,
              workbox.strategies.networkOnly({
                plugins: [bgSyncPlugin]
              }),
              'POST'
            )

        5) Cache Only (static site/app - no fresh content needed)

            workbox.routing.registerRoute(
              match,
              workbox.strategies.cacheOnly()
            )

______________________________________________________________________________________________
703) PWA - workbox: generateSW

      a) npx workbox
      b) npx workbox wizard (js, css, html)
      c) npx workbox generateSW workbox-config.js   // lub yarn build
      d) w index.html, po tagu
           <script src="app.js"></script>
         wbij:

          <script>
            if ('serviceWorker' in navigator) {
              window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                  .then(console.log)
                  .catch(console.error)
              })
            }
          </script>

      e) na końcu workbox-config, po 'swDest', wbij:

           runtimeCaching: [{
             urlPattern: /https:\/\/jsonplaceholder\.typicode\.com\/users/,
             handler: 'networkFirst'
           }]

       f) .. i odpal yarn build, czyli
            workbox generateSW workbox-config.js

       g) na razie, uruchomimy go z ręki. Otwórz taba Application
          i kliknij w linkę 'skipWaiting'

       h) reload strony i w Networks widać, że 'users' są pobrane przez Service Workers

       i) tab Application > Cache Storage > workbox-runtime > users
          wyświetla pobranego z serwera jsona

       j) tab Application > Service Workers

       k) czeknij Offline, refresh (F5) i dane się wyświetlają.
          Bo zostały przez service workera wzięte z kesza

______________________________________________________________________________________________
704) PWA - workbox: injectManifest - lokalnie

      Mocniejsza wersja ww

      a) w package.json zmień linijkę z buildem, na:
          "build": "workbox injectManifest workbox-config.js"

      b) sw.js wykasuj wszystko, ma być pusty

      c) wklej poniższe i odpal yarn build

      d) do sw wklejona zostanie zawartość src-sw.js wraz z wygenerowanymi
         haszami dla index.html, style.css, app.js, src-sw.js i workbox-config.js

      e) Application > Clear Storage > Clear site data

      f) refresh (F5) > Offline > refresh

      g) w Console pokaże się 'Siemanko z Service Workiera' i wyświetlą się dane


      ------- workbox-config.js ----------------------------------------------

        module.exports = {
          "globDirectory": ".",
          "globPatterns": [
            "**/*.{css,js,html}"
          ],
          "swDest": "sw.js",
          "swSrc": "src-sw.js"

        };

      ------- src-sw.js ----------------------------------------------

        importScripts("https://storage.googleapis.com/workbox-cdn/releases/4.3.1/workbox-sw.js")
        console.log('Siemanko z Service Workiera')

        workbox.routing.registerRoute(
          /https:\/\/jsonplaceholder\.typicode\.com\/users/,
          workbox.strategies.networkFirst()
        )

        workbox.precaching.precacheAndRoute([])

        workbox.core.skipWaiting()
        workbox.core.clientsClaim()

______________________________________________________________________________________________
705) PWA - workbox: injectManifest - netlifajka

    UWAGA !
      Wg nowej konwencji, manifest zwie się app.webmanifest
      Dodaj go do workbox-config.js:

        "globPatterns": [
          "**/*.{css,js,png,html,webmanifest}"
    -----------------------------------------------------------------------
     o) wygeneruj manifest i ikonki, uploadując 1 .png 512x512, na stronę
          https://app-manifest.firebaseapp.com/

     a) "box": "workbox injectManifest workbox-config.js"
     b) yarn box
     c) devtools > Application > Clear Storage > Clear site data
     d) devtools > Application > ServiceWorkers > skipWaiting
     e) refresh (F5)
     f) devtools > Network > Offline > refresh (F5)
     g) pchnąć repo na githuba
     h) deplojka na netlifajkę
          https://app.netlify.com/teams/nabu1312/sites > New site from Git > Github ..

     i) zrobienie pliku .apk i jego ściągnięcie
          https://pwa2apk.com

     j) upload na smarka przez HiSuite (win android manager)

     k) jeśli chce się upnąć apkę do Google Playa, to w katalogu głównym
        zrób katalog /.well-known i wklej doń ściągnięty razem z plikiem .apk
        plik assetlinks.json. Poniżej dane które chyba trzeba wbić na GugielPleju

          appmaker-store-Y1FUQ7MEFQcrJ3YSZIFA
          Store Password	x28nxqpnq
          Key Password	7u9vma97j

     Dane powinny się wyświetlić, a linia 'users' powinna pokazywać
     że brana jest z Service Workera

    ---- index.html -------------------------------

      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="msapplication-starturl" content="/">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta name="theme-color" content="#fff" />

        <title>PWA 2</title>
        <link rel="stylesheet" type="text/css" media="screen" href="app.css">
        <link rel="manifest" href="/app.webmanifest">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.19.0/axios.min.js"></script>
      </head>
      <body>

        <header>Attendees 2</header>
        <div id="attendees"></div>

        <script src="app.js"></script>

        <script>
          if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
              navigator.serviceWorker.register('sw.js')
                .then(console.log)
                .catch(console.error)
            })
          }
        </script>

      </body>
      </html>

    ---- app.css -------------------------------

        body {
          margin: 0;
          background: #cfd8dc
        }

        header {
          background: #00897b;
          color: white;
          position: fixed;
          top: 0;
          right: 0;
          left: 0;
          padding: 10px 30px;
          font-size: 22px;
        }

        #attendees {
          margin-top: 60px;
        }

        .card {
          background: white;
          padding: 10px;
          margin: 20px;
          border-radius: 6px;
          box-shadow: 2px 2px 1px rgba(0, 0, 0, 0.8);
        }

    ---- app.js -------------------------------

      const attendees = document.querySelector('#attendees')

      console.log('111')

      axios.get('https://jsonplaceholder.typicode.com/users')
        .then(res => {
          console.log(res.data)
          let html = ''
          res.data.map(user => {
            html += '<div class= "card"' + '<h2>' + user.name + '</h2><h4>'
              + user.email + '</h4></div>';
          })

          attendees.innerHTML = html
        })
        .catch(err => console.log('Erroras:', err))

    ---- src-sw.js -------------------------------

      importScripts("https://storage.googleapis.com/workbox-cdn/releases/4.3.1/workbox-sw.js")
      console.log('Siemanko z Service Workiera')

      workbox.routing.registerRoute(
        /https:\/\/jsonplaceholder\.typicode\.com\/users/,
        new workbox.strategies.NetworkFirst()
      )

      workbox.routing.registerRoute(
        /\.(?:js|css)$/,
        new workbox.strategies.staleWhileRevalidate({
          cacheName: 'static-resources',
        })
      )

      workbox.routing.registerRoute(
        /^https:\/\/fonts\.googleapis\.com/,
        new workbox.strategies.StaleWhileRevalidate({
          cacheName: 'google-fonts-stylesheets',
        })
      );

      workbox.routing.registerRoute(
        /\.(?:png|gif|jpg|jpeg|svg)$/,
        workbox.strategies.cacheFirst({
          cacheName: 'images',
          plugins: [
            new workbox.expiration.Plugin({
              maxEntries: 60,
              maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
            }),
          ],
        })
      );


      workbox.precaching.precacheAndRoute([])

      workbox.core.skipWaiting()
      workbox.core.clientsClaim()


    ---- workbox-config.js -------------------------------

      module.exports = {
        "globDirectory": ".",
        "globPatterns": [
          "**/*.{css,js,png,html,webmanifest}"
        ],
        "swDest": "sw.js",
        "swSrc": "src-sw.js"
      };

    ---- app.webmanifest -------------------------------

      {
        "name": "Attendees",
        "short_name": "Attendees",
        "theme_color": "#00897b",
        "background_color": "#000000",
        "display": "standalone",
        "orientation":"portrait",
        "lang": "en-US",
        "scope": "/",
        "start_url": "/",
        "icons": [
          {
            "src": "images/icons/icon-72x72.png",
            "sizes": "72x72",
            "type": "image/png"
          },
          {
            "src": "images/icons/icon-96x96.png",
            "sizes": "96x96",
            "type": "image/png"
          },
          {
            "src": "images/icons/icon-128x128.png",
            "sizes": "128x128",
            "type": "image/png"
          },
          {
            "src": "images/icons/icon-144x144.png",
            "sizes": "144x144",
            "type": "image/png"
          },
          {
            "src": "images/icons/icon-152x152.png",
            "sizes": "152x152",
            "type": "image/png"
          },
          {
            "src": "images/icons/icon-192x192.png",
            "sizes": "192x192",
            "type": "image/png"
          },
          {
            "src": "images/icons/icon-384x384.png",
            "sizes": "384x384",
            "type": "image/png"
          },
          {
            "src": "images/icons/icon-512x512.png",
            "sizes": "512x512",
            "type": "image/png"
          }
        ],
        "splash_pages": null
      }
_____________________________________________________________________
710) PWA - Vue 1

      a) vue create nowyProjekt > ... PWA ...
      b) yarn add axios
      c) y  - upewnij się że projekt działa
      d) yarn build
      e) cd dist
      f) touch manifest.json service-worker.js
      g) serve - uruchamia apkę
      h) devtools: Application, Network, Console
      i) devtools > Application > Offline > Refresh (F5)
      j) now (będąc w katalogu /dist)

      --------- index.html ----------------------------------

        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width,initial-scale=1.0">
            <link rel="icon" href="<%= BASE_URL %>favicon.ico">
            <title>vuepwa1</title>
          </head>
          <body>
            <noscript>
              <strong>We're sorry but vuepwa1 doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
            </noscript>
            <div id="app"></div>
            <!-- built files will be auto injected -->

            <script>
              if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                  navigator.serviceWorker.register('service-worker.js')
                    .then(console.log)
                    .catch(console.error)
                })
              }
            </script>
          </body>
        </html>


      --------- manifest.json ----------------------------------

        {
          "name": "vuepwa1",
          "short_name": "vuepwa1",
          "icons": [
            {
              "src": "./img/icons/android-chrome-192x192.png",
              "sizes": "192x192",
              "type": "image/png"
            },
            {
              "src": "./img/icons/android-chrome-512x512.png",
              "sizes": "512x512",
              "type": "image/png"
            }
          ],
          "start_url": "./index.html",
          "display": "standalone",
          "background_color": "#000000",
          "theme_color": "#4DBA87"
        }


      --------- service-worker.js  ----------------------------------

        importScripts("https://storage.googleapis.com/workbox-cdn/releases/4.3.1/workbox-sw.js");

        importScripts(
          "/precache-manifest.510d5efd15864780ea1d15a5ca082ab4.js"
        );

        workbox.core.setCacheNameDetails({prefix: "vuepwa1"});

        self.__precacheManifest = [].concat(self.__precacheManifest || []);
        workbox.precaching.precacheAndRoute(self.__precacheManifest, {});

        workbox.routing.registerRoute(
          /https:\/\/jsonplaceholder\.typicode\.com\/users/,
          new workbox.strategies.NetworkFirst()
        )

        workbox.routing.registerRoute(
          /\.(?:js|css)$/,
          workbox.strategies.staleWhileRevalidate({
            cacheName: 'static-resources',
          })
        )

        workbox.routing.registerRoute(
          /^https:\/\/fonts\.googleapis\.com/,
          new workbox.strategies.StaleWhileRevalidate({
            cacheName: 'google-fonts-stylesheets',
          })
        );

        workbox.routing.registerRoute(
          /\.(?:png|gif|jpg|jpeg|svg)$/,
          workbox.strategies.cacheFirst({
            cacheName: 'images',
            plugins: [
              new workbox.expiration.Plugin({
                maxEntries: 60,
                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
              }),
            ],
          })
        );

        workbox.core.skipWaiting()
        workbox.core.clientsClaim()

      --------- components / Kumpo.html  ----------------------------------

        <div>
          <div v-for='user in users'>{{user.id}}. {{user.name}}</div>
        </div>

      --------- components / Kumpo.vue  ----------------------------------

        <template src = './Kumpo.html'> </template>

        <script>
          import axios from 'axios'

          export default {
            data() {
              return {
                users: {}
              }
            },
            created() {
              axios.get('https://jsonplaceholder.typicode.com/users')
                .then(res => {
                  console.log(res.data)
                  this.users = res.data
                })
                .catch(err => console.log('Erroras:', err))
            }
          }
        </script>
_____________________________________________________________________
711) PWA - Vue 2

      https://github.com/vuejs/vue-cli/tree/v3/packages/%40vue/cli-plugin-pwa

      UWAGA !
        Poniższe nie działa, tzn po czeknięciu Offline, zamiast danych wyświetla dinozarła 'No internet',
        ale zero komunkatów o błędzie i wszystko inne też wygląda zdrowo

      a) vue create nowyProjekt > czeknij PWA
      b) yarn add axios
      c) y  - upewnij się że projekt działa
      d) wklej poniższe pliki

      d) yarn build
      e) cd dist
      g) serve - uruchamia apkę

      h) devtools: Application, Network, Console
      i) devtools > Application > Offline > Refresh (F5)


      ------- vue.config.js ------------------------------------------------

        module.exports = {
          // ...other vue-cli plugin options...
          pwa: {
            name: 'My App',
            themeColor: '#4DBA87',
            msTileColor: '#000000',
            appleMobileWebAppCapable: 'yes',
            appleMobileWebAppStatusBarStyle: 'black',

            workboxPluginMode: 'InjectManifest',
            workboxOptions: {
              "globDirectory": ".",
              "globPatterns": [
                "**/*.{css, js, png, jpg, gif, html, json}"
              ],
              "swSrc": "service-worker.js"
            }
          }
        }

      ------- public / index.html -------------------------------------------

        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta name="Description" content="Matching developers skills with a project requirements, booking their calendars">
            <meta name="keywords" content="developers, projects, calendar, assignment, matching, crud, table, selection">
            <meta name="keywords" content="resourcing, skills, requirements">
            <meta charset="utf-8" />
            <meta http-equiv=X-UA-Compatible content="IE=edge">
            <meta name=viewport content="width=device-width,initial-scale=1">
            <link href='https://fonts.googleapis.com/css?family=Roboto:400|Material+Icons' rel="stylesheet">
            <link rel="preconnect" href="https://api.mlab.com">
            <link rel="preconnect" href="https://randomuser.me">
            <script type="module"></script>
            <title>SkillBill</title>
          </head>
          <body>
            <div id="app" data-server-rendered="true"></div>

            <noscript>
              <strong>We're sorry but vuepwa1 doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
            </noscript>
            <div id="app"></div>

            <script>
              if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                  navigator.serviceWorker.register('service-worker.js')
                    .then(console.log)
                    .catch(console.error)
                })
              }
            </script>
          </body>
        </html>

        <style>
          body {
            background: #46494c;
          }
        </style>


      ------- public / manifest.json -------------------------------------------

        {
          "name": "skillbill2",
          "short_name": "skillbill2",
          "start_url": "./index.html",
          "display": "standalone",
          "background_color": "#000000",
          "theme_color": "#4DBA87",
          "icons": [
            {
              "src": "./img/icons/android-chrome-192x192.png",
              "sizes": "192x192",
              "type": "image/png"
            },
            {
              "src": "./img/icons/android-chrome-512x512.png",
              "sizes": "512x512",
              "type": "image/png"
            }
          ]
        }


      ------- /service-worker.js  -------------------------------------------

        console.log('Siemanko z Service Workiera')

        workbox.routing.registerRoute(
          /https:\/\/api.mlab.com\/api\/1\/databases\/skillbill\/collections\/skillbill/,
          new workbox.strategies.NetworkFirst()
        )

        workbox.routing.registerRoute(
          /\.(?:js|css)$/,
          new workbox.strategies.StaleWhileRevalidate({
            cacheName: 'static-resources',
          })
        )

        workbox.routing.registerRoute(
          /^https:\/\/fonts\.googleapis\.com/,
          new workbox.strategies.StaleWhileRevalidate({
            cacheName: 'google-fonts-stylesheets',
          })
        );

        workbox.routing.registerRoute(
          /\.(?:png|gif|jpg|jpeg|svg)$/,
          new workbox.strategies.CacheFirst({
            cacheName: 'images',
            plugins: [
              new workbox.expiration.Plugin({
                maxEntries: 60,
                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
              }),
            ],
          })
        )


        workbox.precaching.precacheAndRoute([])

        // workbox.core.skipWaiting()
        // workbox.core.clientsClaim()

_____________________________________________________________________
720) TWA - tips

      1) jeśli Lighthouse > PWA > 'content not sized correctly for viewport'
        a) ustaw devtoolsy na dole (a nie jak teraz po prawej)
        b) zmaksymalizuj okno

      2) PWA to .apk - generator
          https://appmaker.xyz/pwa-to-apk

      3) assetlinks - weryfikator
          https://developers.google.com/digital-asset-links/tools/generator

_____________________________________________________________________
721) TWA - intro

      PWA można przerobić na TWA i wygenerować plik .apk do użytku lokalnego
      (wgrania android managerem), albo umieścić na Google Pleju.

      Do umieszczenia na Pleju, konieczne jest by narpief apka PWA działa na stronie, która:
        a) musi być na https
        b) jej lighthouse performance musi > 80
        c) będzie działała z domain handshakiem ze swoją stroną (tzw Digital Assets Links)

         Oznacza to, że w katalogu głównym apki (a potem na netlifajce),
         musi być podkatalog /.well-known, z plikiem assetlinks.json w formie:

          [{
            "relation": ["delegate_permission/common.handle_all_urls"],
            "target": {
              "namespace": "android_app",
              "package_name": "com.netlify.mk04",
              "sha256_cert_fingerprints":
              ["77:16:E5:FD:47:7F:A0:ED:07:3B:41:0E:B1:85:99:55:4B:79:CE:73:DF:21:A0:56:03:3C:F8:0A:92:D6:57:C5"]
            }
          }]

_____________________________________________________________________
722) TWA - Android Studio

      https://css-tricks.com/how-to-get-a-progressive-web-app-into-the-google-play-store/

      UWAGA !
        Niestety, zarówno w przypadku strony pwa2apk jak i poniższej wersji Android Studyjnej,
        apka odpala się z address barem u góry.
        Powodem jest to, że niewidoczny jest plik https://mk04.netlify.com/.well-known/assetlinks.json
        Pytanie: jak zrobić tego endpointa na netlifajce - nie znalazłem w guglu odpowiedzi


      Generowanie pliku .apk przy pomocy Android Studio zamiast https://appmaker.xyz/pwa-to-apk
      Narpief upewnij się, że odpalona na stronie PWApka (np z p.705) działa ok

      1) odpal nowy projekt w Android Studio (Language: java, Min API: 19)

      2) w build.gradle (Project), dodaj

          allprojects {
            repositories {
              ...
              maven { url 'https://jitpack.io' }
              ...
            }
          }

      3) build.gradle (Module) - dodaj poniższe w odpowiednich miejscach

          dependencies {
            implementation 'com.github.GoogleChrome:custom-tabs-client:a0f7418972'
          }

          android {
            ...
            compileOptions {
              sourceCompatibility JavaVersion.VERSION_1_8
              targetCompatibility JavaVersion.VERSION_1_8
            }
            ...
          }

          defaultConfig {
            ...
            manifestPlaceholders = [
              hostName: "wordguru.netguru.com",
              defaultUrl: "https://wordguru.netguru.com",
              launcherName: "Wordguru",
              assetStatements: '[{ "relation": ["delegate_permission/common.handle_all_urls"], ' +
              '"target": {"namespace": "web", "site": "https://wordguru.netguru.com"}}]'
            ]
            ...
          }

      4) AndroidManifest.xml

          <manifest
            xmlns:android="http://schemas.android.com/apk/res/android"
            package="com.netguru.wordguru"> // highlight

            <application
              android:allowBackup="true"
              android:icon="@mipmap/ic_launcher"
              android:label="${launcherName}" // highlight
              android:supportsRtl="true"
              android:theme="@style/AppTheme">

              <activity
                android:name="android.support.customtabs.trusted.LauncherActivity"
                android:label="${launcherName}"> // highlight

                <meta-data
                  android:name="android.support.customtabs.trusted.DEFAULT_URL"
                  android:value="${defaultUrl}" /> // highlight

                <meta-data
                  android:name="asset_statements"
                  android:value="${assetStatements}" />

                <intent-filter>
                  <action android:name="android.intent.action.MAIN" />
                  <category android:name="android.intent.category.LAUNCHER" />
                </intent-filter>

                <intent-filter android:autoVerify="true">
                  <action android:name="android.intent.action.VIEW"/>
                  <category android:name="android.intent.category.DEFAULT" />
                  <category android:name="android.intent.category.BROWSABLE"/>
                  <data
                    android:scheme="https"
                    android:host="${hostName}"/> // highlight
                </intent-filter>
              </activity>
            </application>
          </manifest>

      5) AS > Build > Generate Signed Bundle > APK > Create New
           Wypełnij Password, Confirm; Key: Alias, Password, Confirm i First and Last ..
         > release > V1, V2 > Finish

      6) AS > Tools > App Links Assistant
          Wypełnij Site domain i App ID
          Klik Select keystore file
          Klik Generate Digital Asset Links file

          Wyświetli coś jak:
            [{
              "relation": ["delegate_permission/common.handle_all_urls"],
              "target": {
                "namespace": "android_app",
                "package_name": "com.netguru.wordguru",
                "sha256_cert_fingerprints": ["8A:F4:....:29:28"]
              }
            }]

          Skopiuj to do pliku assetlinks.json i umieść w katalogu /.well-known apki
          Wrzuć do githuba a potem na netlifajkę

      7) AS > Build > Generate Signed Bundle
          plik .apk będzie w katalogu projektu w podkatalogu /release
          (klik w dolną belkę z info czy linkę 'locate' go otwiera)


_____________________________________________________________________

Roman - Przepis na layout @ 6:00


<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Web1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" media="screen" href="style.css">
</head>
<body>

  <div class="info">
    <h1 class="info__title">Our courses</h1>
    <p class="info__paragraph">
    We’ve prepared a special list of courses so that you can easily start with CSS styles. Feel free to filter them by level of advancement.
    </p>
    <ul class="info__filters filters">
      <li class="filters__item">
        <button class="filters__button filters__button--active">all</button>
      </li>
      <li class="filters__item">
        <button class="filters__button">beginner</button>
      </li>
      <li class="filters__item">
        <button class="filters__button">developer</button>
      </li>
      <li class="filters__item">
        <button class="filters__button">expert</button>
      </li>
    </ul>
  </div>

  <div class="container">

    <div class="item">
      <div class="item__header">
        <h2 class="item__title">Intro to css layouts 1</h2>
      </div>
      <div class="item__content">
        <p class="item__paragraph">
          This course is dedicated for beginners, who want to start
          their journey with CSS layouts.
        </p>
        <button class="item__button button">take the course</button>
      </div>
    </div>

    <div class="item">
      <div class="item__header">
        <h2 class="item__title">Intro to css layouts 2</h2>
      </div>
      <div class="item__content">
        <p class="item__paragraph">
          This course is dedicated for beginners, who want to start
          their journey with CSS layouts.
        </p>
        <button class="item__button button">take the course</button>
      </div>
    </div>

    <div class="item">
      <div class="item__header">
        <h2 class="item__title">Intro to css layouts 3</h2>
      </div>
      <div class="item__content">
        <p class="item__paragraph">
          This course is dedicated for beginners, who want to start
          their journey with CSS layouts.
        </p>
        <button class="item__button button">take the course</button>
      </div>
    </div>

    <div class="item">
      <div class="item__header">
        <h2 class="item__title">Intro to css layouts 4</h2>
      </div>
      <div class="item__content">
        <p class="item__paragraph">
          This course is dedicated for beginners, who want to start
          their journey with CSS layouts.
        </p>
        <button class="item__button button">take the course</button>
      </div>
    </div>

    <div class="item">
      <div class="item__header">
        <h2 class="item__title">Intro to css layouts 5</h2>
      </div>
      <div class="item__content">
        <p class="item__paragraph">
          This course is dedicated for beginners, who want to start
          their journey with CSS layouts.
        </p>
        <button class="item__button button">take the course</button>
      </div>
    </div>

    <div class="item">
      <div class="item__header">
        <h2 class="item__title">Intro to css layouts 6</h2>
      </div>
      <div class="item__content">
        <p class="item__paragraph">
          This course is dedicated for beginners, who want to start
          their journey with CSS layouts.
        </p>
        <button class="item__button button">take the course</button>
      </div>
    </div>

    <div class="item">
      <div class="item__header">
        <h2 class="item__title">Intro to css layouts 7</h2>
      </div>
      <div class="item__content">
        <p class="item__paragraph">
          This course is dedicated for beginners, who want to start
          their journey with CSS layouts.
        </p>
        <button class="item__button button">take the course</button>
      </div>
    </div>

    <div class="item">
      <div class="item__header">
        <h2 class="item__title">Intro to css layouts 8</h2>
      </div>
      <div class="item__content">
        <p class="item__paragraph">
          This course is dedicated for beginners, who want to start
          their journey with CSS layouts.
        </p>
        <button class="item__button button">take the course</button>
      </div>
    </div>

    <div class="item">
      <div class="item__header">
        <h2 class="item__title">Intro to css layouts 9</h2>
      </div>
      <div class="item__content">
        <p class="item__paragraph">
          This course is dedicated for beginners, who want to start
          their journey with CSS layouts.
        </p>
        <button class="item__button button">take the course</button>
      </div>
    </div>

    <div class="item">
      <div class="item__header">
        <h2 class="item__title">Intro to css layouts 10</h2>
      </div>
      <div class="item__content">
        <p class="item__paragraph">
          This course is dedicated for beginners, who want to start
          their journey with CSS layouts.
        </p>
        <button class="item__button button">take the course</button>
      </div>
    </div>

    <div class="item">
      <div class="item__header">
        <h2 class="item__title">Intro to css layouts 11</h2>
      </div>
      <div class="item__content">
        <p class="item__paragraph">
          This course is dedicated for beginners, who want to start
          their journey with CSS layouts.
        </p>
        <button class="item__button button">take the course</button>
      </div>
    </div>

    <div class="item">
      <div class="item__header">
        <h2 class="item__title">Intro to css layouts 12</h2>
      </div>
      <div class="item__content">
        <p class="item__paragraph">
          This course is dedicated for beginners, who want to start
          their journey with CSS layouts.
        </p>
        <button class="item__button button">take the course</button>
      </div>
    </div>

    <div class="item">
      <div class="item__header">
        <h2 class="item__title">Intro to css layouts 13</h2>
      </div>
      <div class="item__content">
        <p class="item__paragraph">
          This course is dedicated for beginners, who want to start
          their journey with CSS layouts.
        </p>
        <button class="item__button button">take the course</button>
      </div>
    </div>

    <div class="item">
      <div class="item__header">
        <h2 class="item__title">Intro to css layouts 14</h2>
      </div>
      <div class="item__content">
        <p class="item__paragraph">
          This course is dedicated for beginners, who want to start
          their journey with CSS layouts.
        </p>
        <button class="item__button button">take the course</button>
      </div>
    </div>

  </div>
  <script src="index.js"></script>
</body>
</html>

_____________________________________________________________________

* {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

*, *::before, *::after {
  box-sizing: border-box;
}

body {
  background-color: #171717;
  font-family: 'Fira Code', sans-serif;
  color: white;
  padding: 100px 50px;
}

.button {
  margin-top: 50px;
  background-color: white;
  border: none;
  font-size: 14px;
  font-family: 'Fira Code', sans-serif;
  padding: 10px 19px;
  font-weight: 600;
  // display: block;
}

.info {
  max-width: 700px;

  &__title {
    font-size: 48px;
  }

  &__paragraph {
    font-size: 21px;
  }
}

.filters {
  padding: 0;
  display: flex;
  list-style: none;

  &__item {
    border: 1px solid white;
  }

  &__item:not(:last-child) {
    border-right: none;
  }

  &__button {
    font-size: 12px;
    font-family: 'Fira Code', sans-serif;
    background: transparent;
    padding: 10px 30px;
    border: none;
    color: white;

    &--active {
      background: white;
      color: #171717;
    }
  }
}

.container {
  margin-top: 100px;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  grid-gap: 100px 50px;
}

.item {
  border: 2px solid white;
  display: grid;
  min-height: 400px;
  grid-template-rows: 100px 1fr;

  &__header {
    background: white;
    display: flex;
    justify-content: center;
    align-content: center;
    padding: 20px 30px;
  }

  &__content {
    padding: 20px 30px;
    display: flex;
    justify-content: space-between;
    flex-direction: column;
    align-items: center;
  }

  &__title {
    margin: 0;
    color: #171717;
    font-size: 21px;
  }

  &__paragraph, &__button {
    font-size: 14px;
  }
}

